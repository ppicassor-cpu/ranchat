==================================================
   N_BBANG PROJECT SOURCE CODE
   Exported at: 2026-02-19 11:14:19
==================================================


================================================================================
 FILE: app.json
================================================================================

{
  "expo": {
    "name": "ranchat",
    "slug": "ranchat",
    "version": "3.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "enabled": true,
      "url": "https://u.expo.dev/f6fabec8-bc52-4dc4-9088-0acb4d47a258",
      "checkAutomatically": "ON_LOAD",
      "fallbackToCacheTimeout": 0,
      "useNativeDebug": false,
      "requestHeaders": {
        "expo-channel-name": "production"
      }
    },
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "versionCode": 3,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.ranchat",
      "permissions": [
        "CAMERA",
        "RECORD_AUDIO",
        "MODIFY_AUDIO_SETTINGS",
        "INTERNET",
        "ACCESS_NETWORK_STATE",
        "BLUETOOTH",
        "BLUETOOTH_CONNECT"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "./plugins/withAndroidReleaseSigning",
      "./plugins/withAdIdPermission",
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-5144004139813427~4624974702",
          "iosAppId": "ca-app-pub-3940256099942544~1458002511"
        }
      ],
      "expo-secure-store",
      "expo-font"
    ],
    "extra": {
      "react-native-google-mobile-ads": {
        "androidAppId": "ca-app-pub-5144004139813427~4624974702",
        "iosAppId": "ca-app-pub-3940256099942544~1458002511"
      },
      "eas": {
        "projectId": "f6fabec8-bc52-4dc4-9088-0acb4d47a258"
      },
      "update": {
        "channel": "production",
        "branch": "main"
      },
      "EXPO_PUBLIC_REVENUECAT_PUBLIC_SDK_KEY": "goog_uUnNMCAjkegLjEYuqDCYwvwPTGX",
      "EXPO_PUBLIC_REVENUECAT_ENTITLEMENT_ID": "ranchat_premium"
    }
  }
}


================================================================================
 FILE: App.tsx
================================================================================

﻿// FILE: C:\ranchat\App.tsx
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ActivityIndicator, PermissionsAndroid, Platform, StyleSheet, View } from "react-native";
import { SafeAreaProvider } from "react-native-safe-area-context";
import * as Location from "expo-location";
import RootNavigator from "./src/navigation/RootNavigator";

import { initAds } from "./src/services/ads/AdManager";
import { initPurchases } from "./src/services/purchases/PurchaseManager";

import AppModal from "./src/components/AppModal";
import PrimaryButton from "./src/components/PrimaryButton";
import AppText from "./src/components/AppText";
import { theme } from "./src/config/theme";
import { useAppStore } from "./src/store/useAppStore";

type SupportedLang = "ko" | "en" | "ja" | "zh" | "es" | "de" | "fr" | "it" | "ru";

const TXT = {
  permTitle: "권한이 필요합니다\nPermissions Required",
  permMsg:
    "아래 권한을 허용해야 영상채팅을 시작할 수 있습니다.\nYou need to allow the following permissions to start video chat.",
  allowBtn: "권한 허용 / Allow Permissions",
  loadingBtn: "요청 중... / Loading...",
  cam: "카메라 / Camera",
  mic: "마이크(소리) / Microphone",
  loc: "위치(GPS) / Location (GPS)",
  required: "권한허용필요 / Required",

  setupTitle: "설정 중... / Setting up...",
  setupMsg: "위치와 언어를 찾고 있습니다.\nFinding your location and language...",
};

function countryToLang(cc: string): SupportedLang {
  const c = String(cc || "").trim().toUpperCase();

  if (c === "KR") return "ko";
  if (c === "JP") return "ja";
  if (c === "RU") return "ru";
  if (c === "DE") return "de";
  if (c === "FR") return "fr";
  if (c === "IT") return "it";
  if (c === "ES" || c === "MX") return "es";
  if (c === "CN" || c === "TW" || c === "HK") return "zh";

  // 그 외 대부분은 영어로
  return "en";
}

async function resolveIsoCountryCode(): Promise<string | null> {
  try {
    if (Platform.OS !== "android") {
      const perm = await Location.requestForegroundPermissionsAsync();
      if (perm.status !== "granted") return null;
    }

    const pos = await Location.getCurrentPositionAsync({
      accuracy: Location.Accuracy.Balanced,
    });

    const geo = await Location.reverseGeocodeAsync({
      latitude: pos.coords.latitude,
      longitude: pos.coords.longitude,
    });

    const cc = String(geo?.[0]?.isoCountryCode || "").trim().toUpperCase();
    return cc && cc.length === 2 ? cc : null;
  } catch {
    return null;
  }
}

export default function App() {
  const didInitRef = useRef(false);

  const hasHydrated = useAppStore((s: any) => s.hasHydrated);
  const prefs = useAppStore((s: any) => s.prefs);
  const setPrefs = useAppStore((s: any) => s.setPrefs);

  const [permChecked, setPermChecked] = useState(false);
  const [permBusy, setPermBusy] = useState(false);
  const [permState, setPermState] = useState({ cam: false, mic: false, loc: false });

  const [setupBusy, setSetupBusy] = useState(false);
  const [setupDone, setSetupDone] = useState(false);

  const permOk = useMemo(() => Boolean(permState.cam && permState.mic && permState.loc), [permState]);

  useEffect(() => {
    if (didInitRef.current) return;
    didInitRef.current = true;

    // ✅ 앱 부팅 시 광고/결제 SDK 초기화 1회 보장
    try {
      initAds();
    } catch {}
    try {
      initPurchases();
    } catch {}
  }, []);

  const hasAndroidPermission = useCallback(async (perm: string) => {
    try {
      const r = await PermissionsAndroid.check(perm as any);
      return Boolean(r);
    } catch {
      return false;
    }
  }, []);

  const checkPermissions = useCallback(async () => {
    if (Platform.OS !== "android") {
      setPermState({ cam: true, mic: true, loc: true });
      setPermChecked(true);
      return;
    }

    const cam = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA);
    const mic = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
    const loc =
      (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
      (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

    setPermState({ cam, mic, loc });
    setPermChecked(true);
  }, [hasAndroidPermission]);

  useEffect(() => {
    checkPermissions();
  }, [checkPermissions]);

  const requestPermissions = useCallback(async () => {
    if (permBusy) return;
    setPermBusy(true);

    try {
      if (Platform.OS !== "android") {
        setPermState({ cam: true, mic: true, loc: true });
        return;
      }

      const camBefore = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA);
      const micBefore = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
      const locBefore =
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

      const needs: string[] = [];
      if (!camBefore) needs.push(PermissionsAndroid.PERMISSIONS.CAMERA);
      if (!micBefore) needs.push(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
      if (!locBefore) needs.push(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION);

      const results: Record<string, string> = {};

      if (needs.length > 0) {
        const multi = await PermissionsAndroid.requestMultiple(needs as any);
        results.camera = multi[PermissionsAndroid.PERMISSIONS.CAMERA];
        results.mic = multi[PermissionsAndroid.PERMISSIONS.RECORD_AUDIO];
        results.loc = multi[PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION];
      }

      const cam =
        camBefore ||
        results.camera === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA));
      const mic =
        micBefore ||
        results.mic === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO));
      const loc =
        locBefore ||
        results.loc === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

      setPermState({ cam, mic, loc });
    } catch {
      // 실패 시에도 모달은 계속 떠있고, 다시 시도 가능
    } finally {
      setPermBusy(false);
    }
  }, [hasAndroidPermission, permBusy]);

  useEffect(() => {
    if (!permChecked) return;
    if (!permOk) return;
    if (!hasHydrated) return;
    if (setupBusy || setupDone) return;

    (async () => {
      setSetupBusy(true);
      try {
        const st: any = useAppStore.getState?.() ?? {};
        const curPrefs = st.prefs ?? prefs ?? {};
        const curCountry = String(curPrefs.country || "").trim().toUpperCase();

        const rawLang = String(curPrefs.language || "").trim().toLowerCase();
        const curLang = rawLang === "kr" ? "ko" : rawLang;

        const hasCountry = curCountry.length === 2;
        const hasLang =
          curLang === "ko" ||
          curLang === "en" ||
          curLang === "ja" ||
          curLang === "zh" ||
          curLang === "es" ||
          curLang === "de" ||
          curLang === "fr" ||
          curLang === "it" ||
          curLang === "ru";

        // 이미 사용자가 설정해둔 값이 있으면 덮어쓰지 않음
        if (hasCountry && hasLang) return;

        const cc = await resolveIsoCountryCode();

        if (cc) {
          const lang = countryToLang(cc);
          if (!hasCountry) setPrefs({ country: cc });
          if (!hasLang) setPrefs({ language: lang });
        } else {
          // 위치를 못 얻은 경우: 언어가 비어있으면 최소 영어로
          if (!hasLang) setPrefs({ language: "en" });
        }
      } finally {
        setSetupBusy(false);
        setSetupDone(true);
      }
    })();
  }, [hasHydrated, permChecked, permOk, prefs, setPrefs, setupBusy, setupDone]);

  if (permChecked && permOk && hasHydrated && setupDone) {
    return (
      <SafeAreaProvider>
        <RootNavigator />
      </SafeAreaProvider>
    );
  }

  const showSetup = permChecked && permOk && (!hasHydrated || !setupDone);

  return (
    <SafeAreaProvider>
      <View style={styles.gateRoot}>
        {/* 권한 모달 (KO+EN 고정) */}
        <AppModal
          visible={!showSetup && (permChecked ? !permOk : true)}
          title={TXT.permTitle}
          dismissible={false}
          footer={
            <View style={{ gap: 10 }}>
              <PrimaryButton
                title={permBusy ? TXT.loadingBtn : TXT.allowBtn}
                onPress={requestPermissions}
                disabled={permBusy || permOk}
              />
            </View>
          }
        >
          <AppText style={styles.modalText}>{TXT.permMsg}</AppText>

          <View style={{ height: 12 }} />

          <View style={styles.permList}>
            <View style={styles.permRow}>
              <AppText style={[styles.permLeft, !permState.cam ? styles.permLeftNeed : null]}>• {TXT.cam}</AppText>
              {!permState.cam && <AppText style={styles.permNeed}>({TXT.required})</AppText>}
            </View>

            <View style={styles.permRow}>
              <AppText style={[styles.permLeft, !permState.mic ? styles.permLeftNeed : null]}>• {TXT.mic}</AppText>
              {!permState.mic && <AppText style={styles.permNeed}>({TXT.required})</AppText>}
            </View>

            <View style={styles.permRow}>
              <AppText style={[styles.permLeft, !permState.loc ? styles.permLeftNeed : null]}>• {TXT.loc}</AppText>
              {!permState.loc && <AppText style={styles.permNeed}>({TXT.required})</AppText>}
            </View>
          </View>
        </AppModal>

        {/* 위치/언어 저장 스피너 */}
        <AppModal
          visible={showSetup}
          title={TXT.setupTitle}
          dismissible={false}
          footer={<View />}
        >
          <View style={styles.setupBox}>
            <ActivityIndicator />
            <View style={{ height: 12 }} />
            <AppText style={styles.modalTextCenter}>{TXT.setupMsg}</AppText>
          </View>
        </AppModal>
      </View>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  gateRoot: { flex: 1, backgroundColor: theme.colors.bg, justifyContent: "center" },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },
  modalTextCenter: { fontSize: 14, color: theme.colors.sub, lineHeight: 20, textAlign: "center" },

  permList: { width: "100%", gap: 8 },
  permRow: { width: "100%", flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  permLeft: { fontSize: 14, color: theme.colors.text, fontWeight: "800" },
  permLeftNeed: { color: "#ff4d4f" },
  permNeed: { fontSize: 12, color: "#ff4d4f", fontWeight: "900" },

  setupBox: { alignItems: "center", justifyContent: "center" },
});


================================================================================
 FILE: firebase.json
================================================================================

{
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}


================================================================================
 FILE: index.ts
================================================================================

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


================================================================================
 FILE: package.json
================================================================================

{
  "name": "ranchat",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-navigation/bottom-tabs": "^7.13.0",
    "@react-navigation/native": "^7.1.28",
    "@react-navigation/native-stack": "^7.12.0",
    "event-target-shim": "^6.0.2",
    "expo": "~54.0.33",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.11",
    "expo-location": "~19.0.8",
    "expo-secure-store": "~15.0.8",
    "expo-status-bar": "~3.0.9",
    "expo-system-ui": "~6.0.9",
    "expo-updates": "~29.0.16",
    "react": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-get-random-values": "~1.11.0",
    "react-native-google-mobile-ads": "^16.0.3",
    "react-native-incall-manager": "^4.2.1",
    "react-native-purchases": "^9.9.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-webrtc": "^124.0.7",
    "react-native-worklets": "0.5.1",
    "uuid": "^13.0.0",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "typescript": "~5.9.2"
  },
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "react-native-webrtc"
        ]
      }
    }
  },
  "private": true
}


================================================================================
 FILE: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  },
  "exclude": [
    "server-auth",
    "android",
    "ios",
    "node_modules"
  ]
}


================================================================================
 FILE: dist\assetmap.json
================================================================================

{"dbc3af23c3cbbe45d326afc1d31c2e92":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets","httpServerLocation":"/assets/node_modules/@react-navigation/elements/lib/module/assets","width":24,"height":24,"scales":[1,2,3,4],"files":["C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon@1x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon@2x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon@3x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon@4x.android.png"],"hash":"dbc3af23c3cbbe45d326afc1d31c2e92","name":"back-icon","type":"png","fileHashes":["778ffc9fe8773a878e9c30a6304784de","c79c3606a1cf168006ad3979763c7e0c","02bc1fa7c0313217bde2d65ccbff40c9","35ba0eaec5a4f5ed12ca16fabeae451d"]},"0a328cd9c1afd0afe8e3b1ec5165b1b4":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets","httpServerLocation":"/assets/node_modules/@react-navigation/elements/lib/module/assets","width":50,"height":85,"scales":[1],"files":["C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\back-icon-mask.png"],"hash":"0a328cd9c1afd0afe8e3b1ec5165b1b4","name":"back-icon-mask","type":"png","fileHashes":["0a328cd9c1afd0afe8e3b1ec5165b1b4"]},"61378328a719f21f093de82dd89ecfb0":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets","httpServerLocation":"/assets/node_modules/@react-navigation/elements/lib/module/assets","width":64,"height":64,"scales":[1,1,2,3,4],"files":["C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon@1x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon@2x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon@3x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\clear-icon@4x.png"],"hash":"61378328a719f21f093de82dd89ecfb0","name":"clear-icon","type":"png","fileHashes":["3cd68ccdb8938e3711da2e8831b85493","61ca7e64b7d605716c57706cef640b9a","aff2c65b39a296d4f7e96d0f58169170","d8e7601e3df962f83c62371ac14964d8","3cd68ccdb8938e3711da2e8831b85493"]},"3162e8a244d8f6fbd259e79043e23ce4":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets","httpServerLocation":"/assets/node_modules/@react-navigation/elements/lib/module/assets","width":96,"height":96,"scales":[1,1,2,3,4],"files":["C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon@1x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon@2x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon@3x.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\close-icon@4x.png"],"hash":"3162e8a244d8f6fbd259e79043e23ce4","name":"close-icon","type":"png","fileHashes":["0747a1317bbe9c6fc340b889ef8ab3ae","d84e297c3b3e49a614248143d53e40ca","1190ab078c57159f4245a328118fcd9a","78c625386b4d0690b421eb0fc78f7b9c","0747a1317bbe9c6fc340b889ef8ab3ae"]},"940453dc5cbfaa96cf907b3aa7791ece":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets","httpServerLocation":"/assets/node_modules/@react-navigation/elements/lib/module/assets","width":24,"height":24,"scales":[1,2,3,4],"files":["C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\search-icon@1x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\search-icon@2x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\search-icon@3x.android.png","C:\\ranchat\\node_modules\\@react-navigation\\elements\\lib\\module\\assets\\search-icon@4x.android.png"],"hash":"940453dc5cbfaa96cf907b3aa7791ece","name":"search-icon","type":"png","fileHashes":["4403c6117ec30c859bc95d70ce4a71d3","069d99eb1fa6712c0b9034a58c6b57dd","c3273c9e5321f20d1e42c2efae2578c4","286d67d3f74808a60a78d3ebf1a5fb57"]},"3f78af31cca60105799838a1a7a59fbd":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\AntDesign.ttf"],"hash":"3f78af31cca60105799838a1a7a59fbd","name":"AntDesign","type":"ttf","fileHashes":["3f78af31cca60105799838a1a7a59fbd"]},"31b5ffea3daddc69dd01a1f3d6cf63c5":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Entypo.ttf"],"hash":"31b5ffea3daddc69dd01a1f3d6cf63c5","name":"Entypo","type":"ttf","fileHashes":["31b5ffea3daddc69dd01a1f3d6cf63c5"]},"140c53a7643ea949007aa9a282153849":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\EvilIcons.ttf"],"hash":"140c53a7643ea949007aa9a282153849","name":"EvilIcons","type":"ttf","fileHashes":["140c53a7643ea949007aa9a282153849"]},"ca4b48e04dc1ce10bfbddb262c8b835f":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Feather.ttf"],"hash":"ca4b48e04dc1ce10bfbddb262c8b835f","name":"Feather","type":"ttf","fileHashes":["ca4b48e04dc1ce10bfbddb262c8b835f"]},"b49ae8ab2dbccb02c4d11caaacf09eab":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Fontisto.ttf"],"hash":"b49ae8ab2dbccb02c4d11caaacf09eab","name":"Fontisto","type":"ttf","fileHashes":["b49ae8ab2dbccb02c4d11caaacf09eab"]},"b06871f281fee6b241d60582ae9369b9":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome.ttf"],"hash":"b06871f281fee6b241d60582ae9369b9","name":"FontAwesome","type":"ttf","fileHashes":["b06871f281fee6b241d60582ae9369b9"]},"1f77739ca9ff2188b539c36f30ffa2be":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome5_Regular.ttf"],"hash":"1f77739ca9ff2188b539c36f30ffa2be","name":"FontAwesome5_Regular","type":"ttf","fileHashes":["1f77739ca9ff2188b539c36f30ffa2be"]},"605ed7926cf39a2ad5ec2d1f9d391d3d":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome5_Solid.ttf"],"hash":"605ed7926cf39a2ad5ec2d1f9d391d3d","name":"FontAwesome5_Solid","type":"ttf","fileHashes":["605ed7926cf39a2ad5ec2d1f9d391d3d"]},"3b89dd103490708d19a95adcae52210e":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome5_Brands.ttf"],"hash":"3b89dd103490708d19a95adcae52210e","name":"FontAwesome5_Brands","type":"ttf","fileHashes":["3b89dd103490708d19a95adcae52210e"]},"370dd5af19f8364907b6e2c41f45dbbf":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Regular.ttf"],"hash":"370dd5af19f8364907b6e2c41f45dbbf","name":"FontAwesome6_Regular","type":"ttf","fileHashes":["370dd5af19f8364907b6e2c41f45dbbf"]},"adec7d6f310bc577f05e8fe06a5daccf":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Solid.ttf"],"hash":"adec7d6f310bc577f05e8fe06a5daccf","name":"FontAwesome6_Solid","type":"ttf","fileHashes":["adec7d6f310bc577f05e8fe06a5daccf"]},"56c8d80832e37783f12c05db7c8849e2":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\FontAwesome6_Brands.ttf"],"hash":"56c8d80832e37783f12c05db7c8849e2","name":"FontAwesome6_Brands","type":"ttf","fileHashes":["56c8d80832e37783f12c05db7c8849e2"]},"e20945d7c929279ef7a6f1db184a4470":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Foundation.ttf"],"hash":"e20945d7c929279ef7a6f1db184a4470","name":"Foundation","type":"ttf","fileHashes":["e20945d7c929279ef7a6f1db184a4470"]},"b4eb097d35f44ed943676fd56f6bdc51":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Ionicons.ttf"],"hash":"b4eb097d35f44ed943676fd56f6bdc51","name":"Ionicons","type":"ttf","fileHashes":["b4eb097d35f44ed943676fd56f6bdc51"]},"6e435534bd35da5fef04168860a9b8fa":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\MaterialCommunityIcons.ttf"],"hash":"6e435534bd35da5fef04168860a9b8fa","name":"MaterialCommunityIcons","type":"ttf","fileHashes":["6e435534bd35da5fef04168860a9b8fa"]},"4e85bc9ebe07e0340c9c4fc2f6c38908":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\MaterialIcons.ttf"],"hash":"4e85bc9ebe07e0340c9c4fc2f6c38908","name":"MaterialIcons","type":"ttf","fileHashes":["4e85bc9ebe07e0340c9c4fc2f6c38908"]},"871378c6eab492a3e689a9385dc45a12":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Octicons.ttf"],"hash":"871378c6eab492a3e689a9385dc45a12","name":"Octicons","type":"ttf","fileHashes":["871378c6eab492a3e689a9385dc45a12"]},"d2285965fe34b05465047401b8595dd0":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\SimpleLineIcons.ttf"],"hash":"d2285965fe34b05465047401b8595dd0","name":"SimpleLineIcons","type":"ttf","fileHashes":["d2285965fe34b05465047401b8595dd0"]},"1681f34aaca71b8dfb70756bca331eb2":{"__packager_asset":true,"fileSystemLocation":"C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts","httpServerLocation":"/assets/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts","scales":[1],"files":["C:\\ranchat\\node_modules\\@expo\\vector-icons\\build\\vendor\\react-native-vector-icons\\Fonts\\Zocial.ttf"],"hash":"1681f34aaca71b8dfb70756bca331eb2","name":"Zocial","type":"ttf","fileHashes":["1681f34aaca71b8dfb70756bca331eb2"]}}

================================================================================
 FILE: dist\metadata.json
================================================================================

{"version":0,"bundler":"metro","fileMetadata":{"android":{"bundle":"_expo/static/js/android/index-13a592afc0c878e6776c802aba38496e.hbc","assets":[{"path":"assets\\778ffc9fe8773a878e9c30a6304784de","ext":"png"},{"path":"assets\\c79c3606a1cf168006ad3979763c7e0c","ext":"png"},{"path":"assets\\02bc1fa7c0313217bde2d65ccbff40c9","ext":"png"},{"path":"assets\\35ba0eaec5a4f5ed12ca16fabeae451d","ext":"png"},{"path":"assets\\0a328cd9c1afd0afe8e3b1ec5165b1b4","ext":"png"},{"path":"assets\\3cd68ccdb8938e3711da2e8831b85493","ext":"png"},{"path":"assets\\61ca7e64b7d605716c57706cef640b9a","ext":"png"},{"path":"assets\\aff2c65b39a296d4f7e96d0f58169170","ext":"png"},{"path":"assets\\d8e7601e3df962f83c62371ac14964d8","ext":"png"},{"path":"assets\\3cd68ccdb8938e3711da2e8831b85493","ext":"png"},{"path":"assets\\0747a1317bbe9c6fc340b889ef8ab3ae","ext":"png"},{"path":"assets\\d84e297c3b3e49a614248143d53e40ca","ext":"png"},{"path":"assets\\1190ab078c57159f4245a328118fcd9a","ext":"png"},{"path":"assets\\78c625386b4d0690b421eb0fc78f7b9c","ext":"png"},{"path":"assets\\0747a1317bbe9c6fc340b889ef8ab3ae","ext":"png"},{"path":"assets\\4403c6117ec30c859bc95d70ce4a71d3","ext":"png"},{"path":"assets\\069d99eb1fa6712c0b9034a58c6b57dd","ext":"png"},{"path":"assets\\c3273c9e5321f20d1e42c2efae2578c4","ext":"png"},{"path":"assets\\286d67d3f74808a60a78d3ebf1a5fb57","ext":"png"},{"path":"assets\\3f78af31cca60105799838a1a7a59fbd","ext":"ttf"},{"path":"assets\\31b5ffea3daddc69dd01a1f3d6cf63c5","ext":"ttf"},{"path":"assets\\140c53a7643ea949007aa9a282153849","ext":"ttf"},{"path":"assets\\ca4b48e04dc1ce10bfbddb262c8b835f","ext":"ttf"},{"path":"assets\\b49ae8ab2dbccb02c4d11caaacf09eab","ext":"ttf"},{"path":"assets\\b06871f281fee6b241d60582ae9369b9","ext":"ttf"},{"path":"assets\\1f77739ca9ff2188b539c36f30ffa2be","ext":"ttf"},{"path":"assets\\605ed7926cf39a2ad5ec2d1f9d391d3d","ext":"ttf"},{"path":"assets\\3b89dd103490708d19a95adcae52210e","ext":"ttf"},{"path":"assets\\370dd5af19f8364907b6e2c41f45dbbf","ext":"ttf"},{"path":"assets\\adec7d6f310bc577f05e8fe06a5daccf","ext":"ttf"},{"path":"assets\\56c8d80832e37783f12c05db7c8849e2","ext":"ttf"},{"path":"assets\\e20945d7c929279ef7a6f1db184a4470","ext":"ttf"},{"path":"assets\\b4eb097d35f44ed943676fd56f6bdc51","ext":"ttf"},{"path":"assets\\6e435534bd35da5fef04168860a9b8fa","ext":"ttf"},{"path":"assets\\4e85bc9ebe07e0340c9c4fc2f6c38908","ext":"ttf"},{"path":"assets\\871378c6eab492a3e689a9385dc45a12","ext":"ttf"},{"path":"assets\\d2285965fe34b05465047401b8595dd0","ext":"ttf"},{"path":"assets\\1681f34aaca71b8dfb70756bca331eb2","ext":"ttf"}]}}}

================================================================================
 FILE: plugins\withAdIdPermission.js
================================================================================

﻿const { withAndroidManifest } = require("@expo/config-plugins");

const AD_ID_PERMISSION = "com.google.android.gms.permission.AD_ID";

function ensureAdIdPermission(androidManifest) {
  const manifest = androidManifest.manifest;

  if (!manifest["uses-permission"]) manifest["uses-permission"] = [];
  const list = manifest["uses-permission"];

  const exists = list.some((p) => p?.$?.["android:name"] === AD_ID_PERMISSION);
  if (!exists) {
    list.push({ $: { "android:name": AD_ID_PERMISSION } });
  }

  return androidManifest;
}

module.exports = function withAdIdPermission(config) {
  return withAndroidManifest(config, (config) => {
    config.modResults = ensureAdIdPermission(config.modResults);
    return config;
  });
};


================================================================================
 FILE: plugins\withAndroidReleaseSigning.js
================================================================================

﻿const { withAppBuildGradle, withGradleProperties } = require("@expo/config-plugins");
const fs = require("fs");
const path = require("path");

function readPropertiesFile(filePath) {
  const out = {};
  const raw = fs.readFileSync(filePath, "utf8");
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const s = String(line || "").trim();
    if (!s || s.startsWith("#")) continue;

    const idx = s.indexOf("=");
    if (idx < 0) continue;

    const key = s.slice(0, idx).trim();
    const value = s.slice(idx + 1).trim();
    if (!key) continue;

    out[key] = value;
  }
  return out;
}

function upsertGradleProp(list, key, value) {
  const idx = list.findIndex((x) => x.type === "property" && x.key === key);
  if (idx >= 0) {
    list[idx].value = value;
    return;
  }
  list.push({ type: "property", key, value });
}

function findBlockRange(text, name, from = 0) {
  const re = new RegExp(`\\b${name}\\b\\s*\\{`, "m");
  re.lastIndex = from;
  const m = re.exec(text);
  if (!m) return null;

  const keywordStart = m.index;
  const braceStart = text.indexOf("{", keywordStart);
  if (braceStart < 0) return null;

  let depth = 0;
  for (let i = braceStart; i < text.length; i++) {
    const ch = text[i];
    if (ch === "{") depth += 1;
    else if (ch === "}") {
      depth -= 1;
      if (depth === 0) return { keywordStart, braceStart, braceEnd: i };
    }
  }
  return null;
}

function ensureReleaseSigningConfig(gradle) {
  const android = findBlockRange(gradle, "android");
  if (!android) return gradle;

  let androidBody = gradle.slice(android.braceStart + 1, android.braceEnd);

  // 1) signingConfigs 블록 없으면 생성
  let signingConfigs = findBlockRange(androidBody, "signingConfigs");
  if (!signingConfigs) {
    const buildTypes = findBlockRange(androidBody, "buildTypes");
    const insertAt = buildTypes ? buildTypes.keywordStart : androidBody.length;

    const insert =
      "\n\n    signingConfigs {\n" +
      "    }\n";

    androidBody = androidBody.slice(0, insertAt) + insert + androidBody.slice(insertAt);
  }

  // 2) buildTypes 블록 없으면 생성
  let buildTypes = findBlockRange(androidBody, "buildTypes");
  if (!buildTypes) {
    const insert =
      "\n\n    buildTypes {\n" +
      "        release {\n" +
      "        }\n" +
      "        debug {\n" +
      "        }\n" +
      "    }\n";
    androidBody = androidBody.replace(/\s*$/, "") + insert;
  }

  // 3) signingConfigs 안에 release 없으면 추가 (기본값 제거: findProperty만 사용)
  signingConfigs = findBlockRange(androidBody, "signingConfigs");
  if (!signingConfigs) return gradle;

  let scBody = androidBody.slice(signingConfigs.braceStart + 1, signingConfigs.braceEnd);
  const hasReleaseConfig = /\brelease\s*\{/.test(scBody);

  if (!hasReleaseConfig) {
    const releaseBlock =
      "\n\n        release {\n" +
      "            def storeFilePath = findProperty('RN_STORE_FILE')\n" +
      "            storeFile file(storeFilePath)\n" +
      "            storePassword findProperty('RN_STORE_PASSWORD')\n" +
      "            keyAlias findProperty('RN_KEY_ALIAS')\n" +
      "            keyPassword findProperty('RN_KEY_PASSWORD')\n" +
      "        }\n";

    scBody = scBody.replace(/\s*$/, "") + releaseBlock + "\n";
    androidBody =
      androidBody.slice(0, signingConfigs.braceStart + 1) +
      scBody +
      androidBody.slice(signingConfigs.braceEnd);
  }

  // 4) buildTypes.release에 signingConfig signingConfigs.release 강제 + debug 제거
  buildTypes = findBlockRange(androidBody, "buildTypes");
  if (!buildTypes) return gradle;

  let btBody = androidBody.slice(buildTypes.braceStart + 1, buildTypes.braceEnd);

  let releaseBt = findBlockRange(btBody, "release");
  if (!releaseBt) {
    const addRelease =
      "\n\n        release {\n" +
      "            signingConfig signingConfigs.release\n" +
      "        }\n";
    btBody = btBody.replace(/\s*$/, "") + addRelease + "\n";
  } else {
    let releaseBody = btBody.slice(releaseBt.braceStart + 1, releaseBt.braceEnd);

    // signingConfig 라인 전부 제거 후 release로 1개만 삽입
    releaseBody = releaseBody.replace(/^\s*signingConfig\s+signingConfigs\.\w+\s*$/gm, "");
    releaseBody = releaseBody.replace(/\n{3,}/g, "\n\n");
    releaseBody = releaseBody.replace(/^\s*\n/, "\n");

    const hasReleaseSigning = /^\s*signingConfig\s+signingConfigs\.release\s*$/m.test(releaseBody);
    if (!hasReleaseSigning) {
      releaseBody = "\n            signingConfig signingConfigs.release\n" + releaseBody;
    }

    btBody =
      btBody.slice(0, releaseBt.braceStart + 1) +
      releaseBody +
      btBody.slice(releaseBt.braceEnd);
  }

  androidBody =
    androidBody.slice(0, buildTypes.braceStart + 1) +
    btBody +
    androidBody.slice(buildTypes.braceEnd);

  // android 블록 재조립
  return gradle.slice(0, android.braceStart + 1) + androidBody + gradle.slice(android.braceEnd);
}

module.exports = function withAndroidReleaseSigning(config) {
  // ✅ 목표 1) 루트 keystore.properties -> android/gradle.properties에 매번 주입 (prebuild에도 유지)
  config = withGradleProperties(config, (config) => {
    const projectRoot = config.modRequest.projectRoot;
    const srcPath = path.join(projectRoot, "keystore.properties");

    if (!fs.existsSync(srcPath)) {
      throw new Error(`Missing ${srcPath} (RN_STORE_* values source).`);
    }

    const props = readPropertiesFile(srcPath);
    const required = ["RN_STORE_FILE", "RN_STORE_PASSWORD", "RN_KEY_ALIAS", "RN_KEY_PASSWORD"];

    for (const k of required) {
      const v = String(props[k] ?? "").trim();
      if (!v) throw new Error(`Missing "${k}" in ${srcPath}`);
    }

    const list = config.modResults;

    upsertGradleProp(list, "RN_STORE_FILE", props.RN_STORE_FILE);
    upsertGradleProp(list, "RN_STORE_PASSWORD", props.RN_STORE_PASSWORD);
    upsertGradleProp(list, "RN_KEY_ALIAS", props.RN_KEY_ALIAS);
    upsertGradleProp(list, "RN_KEY_PASSWORD", props.RN_KEY_PASSWORD);

    config.modResults = list;
    return config;
  });

  // ✅ 목표 2) app/build.gradle의 release 빌드 타입에 release signingConfig 강제 (debug 서명 방지)
  return withAppBuildGradle(config, (config) => {
    const src = config.modResults.contents;
    config.modResults.contents = ensureReleaseSigningConfig(src);
    return config;
  });
};


================================================================================
 FILE: src\components\AppModal.tsx
================================================================================

﻿import React from "react";
import { Modal, Pressable, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";

type Props = {
  visible: boolean;
  title?: string;
  children?: React.ReactNode;
  onClose?: () => void;
  footer?: React.ReactNode;
  dismissible?: boolean;
};

export default function AppModal({ visible, title, children, onClose, footer, dismissible = true }: Props) {
  return (
    <Modal transparent visible={visible} animationType="fade" statusBarTranslucent>
      <View style={styles.backdrop}>
        <Pressable
          style={styles.backdropPress}
          onPress={() => {
            if (dismissible) onClose?.();
          }}
        />
        <View style={styles.card}>
          {title ? <AppText style={styles.title}>{title}</AppText> : null}
          <View style={styles.body}>{children}</View>
          {footer ? <View style={styles.footer}>{footer}</View> : null}
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  backdrop: {
    flex: 1,
    backgroundColor: theme.colors.dim,
    alignItems: "center",
    justifyContent: "center",
    padding: theme.spacing.lg,
  },
  backdropPress: {
    ...StyleSheet.absoluteFillObject,
  },
  card: {
    width: "100%",
    maxWidth: 520,
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  title: {
    width: "100%",
    textAlign: "center",
    fontSize: 18,
    fontWeight: "700",
    color: theme.colors.text,
    marginBottom: theme.spacing.sm,
  },
  body: {
    width: "100%",
    alignItems: "center",
    gap: theme.spacing.sm,
  },
  footer: {
    width: "100%",
    marginTop: theme.spacing.md,
  },
});


================================================================================
 FILE: src\components\AppText.tsx
================================================================================

import React, { useMemo } from "react";
import { Text, TextProps, TextStyle, StyleProp } from "react-native";
import { useAppStore } from "../store/useAppStore";

function scaleOneStyle(s: TextStyle, scale: number): TextStyle {
  const out: TextStyle = { ...s };

  if (typeof out.fontSize === "number") out.fontSize = Math.round(out.fontSize * scale);
  if (typeof out.lineHeight === "number") out.lineHeight = Math.round(out.lineHeight * scale);

  // fontWeight 700 초과 방지
  if (typeof out.fontWeight === "string") {
    const n = Number(out.fontWeight);
    if (!Number.isNaN(n) && n > 700) out.fontWeight = "700";
  }

  return out;
}

function scaleStyle(style: StyleProp<TextStyle>, scale: number): StyleProp<TextStyle> {
  if (!style) return style;

  if (Array.isArray(style)) {
    return style.map((x) => scaleStyle(x as any, scale)) as any;
  }

  if (typeof style === "object") {
    return scaleOneStyle(style as TextStyle, scale);
  }

  return style;
}

type Props = TextProps & {
  children?: React.ReactNode;
};

export default function AppText(props: Props) {
  const scale = useAppStore((s) => s.ui.fontScale);

  const scaledStyle = useMemo(() => scaleStyle(props.style as any, scale), [props.style, scale]);

  return (
    <Text {...props} allowFontScaling={false} maxFontSizeMultiplier={1} style={scaledStyle}>
      {props.children}
    </Text>
  );
}


================================================================================
 FILE: src\components\FontSizeSlider.tsx
================================================================================

//C:\ranchat\src\components\FontSizeSlider.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import { LayoutChangeEvent, PanResponder, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";

type Props = {
  value: number;          // 예: 1.0
  min?: number;           // 기본 0.85
  max?: number;           // 기본 1.25
  onChange: (v: number) => void;
};

export default function FontSizeSlider({ value, min = 0.85, max = 1.25, onChange }: Props) {
  const [w, setW] = useState(1);
  const draggingRef = useRef(false);
  const wrapRef = useRef<View>(null);

  const clamp = (v: number) => Math.min(max, Math.max(min, v));

  const pct = useMemo(() => {
    const p = (value - min) / (max - min);
    return Math.min(1, Math.max(0, p));
  }, [value, min, max]);

  const knobLeft = useMemo(() => Math.max(0, Math.round(pct * (w - 18))), [pct, w]);

  const setFromX = (x: number) => {
    const denom = Math.max(1, w - 18);
    const p = Math.min(1, Math.max(0, x / denom));
    const v = min + p * (max - min);
    onChange(Number(clamp(v).toFixed(2)));
  };

  const pan = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponder: () => true,
        onPanResponderGrant: (evt) => {
          draggingRef.current = true;
          const x = evt.nativeEvent.locationX - 9;
          setFromX(x);
        },
        onPanResponderMove: (evt, g) => {
          // g.moveX는 화면 절대좌표라서 locationX 기반으로 처리하기가 더 안정적임
          const x = evt.nativeEvent.locationX - 9;
          setFromX(x);
        },
        onPanResponderRelease: () => {
          draggingRef.current = false;
        },
      }),
    [w, min, max]
  );

  // move 이벤트는 PanResponder에서 locationX로 처리, onTouchMove는 보조로만 유지
  const onTouchMove = (evt: any) => {
    if (!draggingRef.current) return;
    const x = evt?.nativeEvent?.locationX - 9;
    if (typeof x === "number") setFromX(x);
  };

  const onLayout = (e: LayoutChangeEvent) => {
    const next = Math.max(1, Math.floor(e.nativeEvent.layout.width));
    setW(next);

    // Release에서 onLayout 폭이 0~1로 잡히는 케이스 보정
    if (next <= 1) {
      requestAnimationFrame(() => {
        wrapRef.current?.measure((_x, _y, width) => {
          const measured = Math.max(1, Math.floor(width));
          if (measured > 1) setW(measured);
        });
      });
    }
  };

  useEffect(() => {
    if (!Number.isFinite(value)) onChange(1);
  }, [value, onChange]);

  return (
    <View ref={wrapRef} style={styles.wrap} onLayout={onLayout} {...pan.panHandlers} onTouchMove={onTouchMove}>
      <View style={styles.track} />
      <View style={[styles.fill, { width: Math.max(0, knobLeft + 9) }]} />
      <View style={[styles.knob, { left: knobLeft }]} />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    height: 28,
    justifyContent: "center",
    width: "100%",
    alignSelf: "stretch",
  },
  track: {
    height: 8,
    borderRadius: 999,
    backgroundColor: theme.colors.line,
  },
  fill: {
    position: "absolute",
    left: 0,
    height: 8,
    borderRadius: 999,
    backgroundColor: theme.colors.pinkDeep,
  },
  knob: {
    position: "absolute",
    width: 18,
    height: 18,
    borderRadius: 999,
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.line,
  },
});


================================================================================
 FILE: src\components\PremiumPaywallModal.tsx
================================================================================

﻿// FILE: C:\ranchat\src\components\PremiumPaywallModal.tsx
import React from "react";
import { Modal, Pressable, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";
import PrimaryButton from "./PrimaryButton";
import { useTranslation } from "../i18n/LanguageProvider";

export default function PremiumPaywallModal({
  visible,
  onClose,
  title,
  price,
  discountText,
  benefitLines,
  busy,
  onConfirm,
}: {
  visible: boolean;
  onClose: () => void;
  title: string;
  price: string;
  discountText?: string;
  benefitLines: string[];
  busy: boolean;
  onConfirm: () => void;
}) {
  const { t } = useTranslation();

  return (
    <Modal visible={visible} transparent animationType="fade" onRequestClose={onClose}>
      <Pressable style={styles.backdrop} onPress={onClose} />

      <View style={styles.sheetWrap} pointerEvents="box-none">
        <View style={styles.sheet}>
          <View style={styles.top}>
            <AppText style={styles.title}>{title}</AppText>
            <AppText onPress={onClose} style={styles.close}>
              {t("common.close")}
            </AppText>
          </View>

          <View style={{ height: 8 }} />

          <View style={styles.priceBox}>
            <AppText style={styles.price}>{price}</AppText>
            {discountText ? <AppText style={styles.discount}>{discountText}</AppText> : null}
          </View>

          <View style={{ height: 10 }} />

          <View style={styles.benefits}>
            {benefitLines.map((text, i) => (
              <View key={i} style={styles.bRow}>
                <View style={styles.dot} />
                <AppText style={styles.bTxt}>{text}</AppText>
              </View>
            ))}
          </View>

          <View style={{ height: 14 }} />

          <View style={{ gap: 10 }}>
            <PrimaryButton title={busy ? t("payment.processing") : t("payment.proceed")} onPress={onConfirm} disabled={busy} />
            <PrimaryButton title={t("common.cancel")} onPress={onClose} variant="ghost" />
          </View>

          <View style={{ height: 10 }} />

          <AppText style={styles.notice}>
            {t("payment.notice")}
          </AppText>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  backdrop: { ...StyleSheet.absoluteFillObject, backgroundColor: "rgba(0,0,0,0.55)" },

  sheetWrap: {
    flex: 1,
    justifyContent: "flex-end",
    padding: theme.spacing.lg,
  },
  sheet: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },

  top: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  title: { fontSize: 17, fontWeight: "900", color: theme.colors.text },
  close: { fontSize: 13, fontWeight: "900", color: theme.colors.pinkDeep },

  priceBox: {
    backgroundColor: theme.colors.white,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
  },
  price: { fontSize: 18, fontWeight: "900", color: theme.colors.text, marginBottom: 6 },
  discount: { fontSize: 13, fontWeight: "900", color: theme.colors.pinkDeep },

  benefits: {
    backgroundColor: theme.colors.white,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    paddingVertical: 8,
    paddingHorizontal: theme.spacing.lg,
  },
  bRow: { flexDirection: "row", alignItems: "center", gap: 10, paddingVertical: 8 },
  dot: { width: 8, height: 8, borderRadius: 99, backgroundColor: theme.colors.pinkDeep },
  bTxt: { fontSize: 13, fontWeight: "800", color: theme.colors.text },

  notice: { fontSize: 12, color: theme.colors.sub, lineHeight: 18 },
});

================================================================================
 FILE: src\components\PrimaryButton.tsx
================================================================================

﻿//C:\ranchat\src\components\PrimaryButton.tsx
import React from "react";
import { Pressable, StyleSheet, ViewStyle } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";

type Props = {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  variant?: "primary" | "ghost" | "danger";
  style?: ViewStyle;
};

export default function PrimaryButton({ title, onPress, disabled, variant = "primary", style }: Props) {
  const bg =
    variant === "primary" ? theme.colors.pinkDeep : variant === "danger" ? theme.colors.danger : "transparent";
  const border = variant === "ghost" ? theme.colors.line : "transparent";
  const text = variant === "ghost" ? theme.colors.text : theme.colors.white;

  return (
    <Pressable
      onPress={onPress}
      disabled={disabled}
      style={[
        styles.btn,
        { backgroundColor: bg, borderColor: border, opacity: disabled ? 0.5 : 1 },
        style,
      ]}
    >
      <AppText style={[styles.txt, { color: text }]}>{title}</AppText>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  btn: {
    height: 50,
    borderRadius: theme.radius.lg,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  txt: {
    fontSize: 16,
    fontWeight: "700",
  },
});


================================================================================
 FILE: src\components\Spinner.tsx
================================================================================

﻿// FILE: C:\ranchat\src\components\Spinner.tsx
import React from "react";
import { ActivityIndicator, Platform, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";
import { useTranslation } from "../i18n/LanguageProvider";

export default function Spinner() {
  const { t } = useTranslation();

  return (
    <View style={styles.wrap}>
      <AppText style={styles.text}>{t("call.connecting")}</AppText>
      <ActivityIndicator
        size={Platform.OS === "android" ? "large" : 100}
        style={Platform.OS === "android" ? { transform: [{ scale: 3.2 }] } : undefined}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    paddingVertical: theme.spacing.sm,
    alignItems: "center",
    justifyContent: "center",
    gap: 10,
    transform: [{ translateY: 80 }],
  },
  text: {
    color: "rgba(112, 112, 112, 0.85)",
    fontSize: 18,
    fontWeight: "400",
    textAlign: "center",
  },
});

================================================================================
 FILE: src\config\app.ts
================================================================================

﻿// FILE: C:\ranchat\src\config\app.ts
import Constants from "expo-constants";

const env = (Constants.expoConfig?.extra ?? {}) as Record<string, any>;

const read = (k: string, fallback = ""): string => {
  const v = (process.env as any)?.[k];
  if (typeof v === "string" && v.trim().length > 0) return v.trim();
  const e = env?.[k];
  if (typeof e === "string" && e.trim().length > 0) return e.trim();
  return fallback;
};

const readNumber = (k: string, fallback: number): number => {
  const raw = read(k, String(fallback));
  const n = Number(raw);
  return Number.isFinite(n) ? n : fallback;
};

const readPort = (k: string, fallback: number): number => {
  const n = readNumber(k, fallback);
  if (!Number.isFinite(n) || n < 1 || n > 65535) return fallback;
  return Math.trunc(n);
};

const readBool = (k: string, fallback: boolean): boolean => {
  const raw = read(k, fallback ? "1" : "0").trim().toLowerCase();
  if (raw === "1" || raw === "true" || raw === "yes" || raw === "y" || raw === "on") return true;
  if (raw === "0" || raw === "false" || raw === "no" || raw === "n" || raw === "off") return false;
  return fallback;
};

const readList = (k: string): string[] => {
  const raw = read(k, "").trim();
  if (!raw) return [];
  return raw
    .split(",")
    .map((s) => String(s || "").trim())
    .filter((s) => s.length > 0);
};

function normalizeWssUrl(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^wss:\/\//i.test(s)) return s;
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "wss://");
  if (/^https:\/\//i.test(s)) return s.replace(/^https:\/\//i, "wss://");
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "wss://");
  return `wss://${s.replace(/^\/+/, "")}`;
}

function normalizeHttpsBase(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^https:\/\//i.test(s)) return s;
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "https://");
  if (/^wss:\/\//i.test(s)) return s.replace(/^wss:\/\//i, "https://");
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "https://");
  return `https://${s.replace(/^\/+/, "")}`;
}

function normalizeIceUrl(v: string, defaultScheme: "stun" | "turn" = "stun"): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^(stun|stuns|turn|turns):/i.test(s)) return s;
  return `${defaultScheme}:${s.replace(/^\/+/, "")}`;
}

const freeRemoteVideoSeconds = readNumber("EXPO_PUBLIC_FREE_REMOTE_VIDEO_SECONDS", 3000);

const stunUrlsRaw = readList("EXPO_PUBLIC_STUN_URLS")
  .map((u) => normalizeIceUrl(u, "stun"))
  .filter((u) => u.length > 0);

const stunUrls =
  stunUrlsRaw.length > 0
    ? stunUrlsRaw
    : ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"];

export const APP_CONFIG = {
  SIGNALING_URL: normalizeWssUrl(read("EXPO_PUBLIC_SIGNALING_URL", "wss://comspc.duckdns.org")),

  ICE: {
    stunUrls,
  },

  TURN: {
    host: read("EXPO_PUBLIC_TURN_HOST", "152.67.213.225"),
    port: readPort("EXPO_PUBLIC_TURN_PORT", 3478),
    username: read("EXPO_PUBLIC_TURN_USERNAME", "testuser"),
    password: read("EXPO_PUBLIC_TURN_PASSWORD", "testpass"),
    tcpEnabled: readBool("EXPO_PUBLIC_TURN_TCP_ENABLED", false),
  },

  AUTH_HTTP_BASE_URL: normalizeHttpsBase(read("EXPO_PUBLIC_AUTH_HTTP_BASE_URL", "https://comspc.duckdns.org")),

  ADS: {
    bannerAndroid: read("EXPO_PUBLIC_AD_UNIT_BANNER_ANDROID", ""),
    interstitialAndroid: read("EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_ANDROID", ""),
  },

  PURCHASES: {
    revenueCatKey: read(
      "EXPO_PUBLIC_REVENUECAT_ANDROID_KEY",
      read("EXPO_PUBLIC_REVENUECAT_PUBLIC_SDK_KEY", "goog_uUnNMCAjkegLjEYuqDCYwvwPTGX")
    ),
    entitlementId: read("EXPO_PUBLIC_REVENUECAT_ENTITLEMENT_ID", "ranchat_premium"),
  },

  POLICY: {
    privacyUrl: read("EXPO_PUBLIC_PRIVACY_POLICY_URL", ""),
  },

  MATCH_TIMEOUT_MS: readNumber("EXPO_PUBLIC_MATCH_TIMEOUT_MS", 1200000),
  FREE_CALL_LIMIT_MS: readNumber("EXPO_PUBLIC_FREE_CALL_LIMIT_MS", freeRemoteVideoSeconds * 1000),

  FREE_LIMITS: {
    remoteVideoSeconds: freeRemoteVideoSeconds,
  },

  PLANS: {
    weekly: { label: "1주", price: 4900, productId: "ranchat_premium:weekly_-plan" },
    monthly: { label: "1개월", price: 14900, productId: "ranchat_premium:monthly2_-plan" },
    yearly: { label: "1년", price: 89000, productId: "ranchat_premium:yearly2_-plan" },
  },
} as const;

export type Gender = "male" | "female";
export type Language = "ko" | "en" | "ja" | "zh" | "es" | "de" | "fr" | "it" | "ru";

export const COUNTRY_OPTIONS: { code: string; label: string; dial?: string }[] = [
  { code: "KR", label: "대한민국", dial: "+82" },
  { code: "JP", label: "일본", dial: "+81" },
  { code: "CN", label: "중국", dial: "+86" },
  { code: "TW", label: "대만", dial: "+886" },
  { code: "HK", label: "홍콩", dial: "+852" },
  { code: "SG", label: "싱가포르", dial: "+65" },
  { code: "TH", label: "태국", dial: "+66" },
  { code: "VN", label: "베트남", dial: "+84" },
  { code: "ID", label: "인도네시아", dial: "+62" },
  { code: "PH", label: "필리핀", dial: "+63" },
  { code: "MY", label: "말레이시아", dial: "+60" },
  { code: "IN", label: "인도", dial: "+91" },
  { code: "US", label: "미국", dial: "+1" },
  { code: "CA", label: "캐나다", dial: "+1" },
  { code: "GB", label: "영국", dial: "+44" },
  { code: "AU", label: "호주", dial: "+61" },
  { code: "DE", label: "독일", dial: "+49" },
  { code: "FR", label: "프랑스", dial: "+33" },
  { code: "RU", label: "러시아", dial: "+7" },
  { code: "ES", label: "스페인", dial: "+34" },
  { code: "IT", label: "이탈리아", dial: "+39" },
  { code: "BR", label: "브라질", dial: "+55" },
  { code: "MX", label: "멕시코", dial: "+52" },
];


================================================================================
 FILE: src\config\theme.ts
================================================================================

﻿export const theme = {
  colors: {
    bg: "#FFF5FA",
    card: "#FFFFFF",
    cardSoft: "#FFE8F2",
    line: "#F3C7D9",
    text: "#2B2230",
    sub: "#6F5E6A",
    danger: "#D93A5A",
    ok: "#2E7D5B",
    pink: "#F2A8C6",
    pinkDeep: "#E983AD",
    black: "#111111",
    white: "#FFFFFF",
    dim: "rgba(0,0,0,0.45)",
  },
  radius: {
    xl: 22,
    lg: 16,
    md: 12,
  },
  spacing: {
    xs: 8,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 28,
  },
  shadow: {
    card: {
      shadowColor: "#000",
      shadowOpacity: 0.08,
      shadowRadius: 10,
      shadowOffset: { width: 0, height: 6 },
      elevation: 3,
    },
  },
};

================================================================================
 FILE: src\i18n\LanguageProvider.tsx
================================================================================

import React, { createContext, useContext, useEffect, useState, ReactNode } from "react";
import { useAppStore } from "../store/useAppStore";
import { translations } from "./translations";

type LanguageContextType = {
  currentLang: keyof typeof translations;
  t: (key: string, params?: Record<string, any>) => string;
  setLanguage: (lang: keyof typeof translations) => void;
};

const LanguageContext = createContext<LanguageContextType | null>(null);

export function LanguageProvider({ children }: { children: ReactNode }) {
  const prefsLang = useAppStore((s) => s.prefs.language);
  const setPrefs = useAppStore((s) => s.setPrefs);

  const [currentLang, setCurrentLang] = useState<keyof typeof translations>("ko");

  useEffect(() => {
    const lang = prefsLang && translations[prefsLang as keyof typeof translations] ? (prefsLang as keyof typeof translations) : "ko";
    setCurrentLang(lang);
  }, [prefsLang]);

  const t = (key: string, params?: Record<string, any>): string => {
    const dict = translations[currentLang] || translations.ko;
    let text = (dict as any)[key] || key;

    if (params) {
      Object.keys(params).forEach((k) => {
        text = text.replace(`{${k}}`, String(params[k]));
      });
    }
    return text;
  };

  const setLanguage = (lang: keyof typeof translations) => {
    setCurrentLang(lang);
    setPrefs({ language: lang });
  };

  return <LanguageContext.Provider value={{ currentLang, t, setLanguage }}>{children}</LanguageContext.Provider>;
}

export const useTranslation = () => {
  const context = useContext(LanguageContext);
  if (!context) throw new Error("useTranslation must be used within LanguageProvider");
  return context;
};


================================================================================
 FILE: src\i18n\translations.ts
================================================================================

export const translations = {
  ko: {
    "home.title": "랜덤 영상채팅",
    "home.subtitle": "지역/언어/성별을 설정한 뒤 매칭을 시작하세요.",
    "home.match_button": "매칭하기",
    "home.permission_setting": "권한 설정",
    "perm.title": "권한이 필요합니다",
    "perm.message": "아래 권한을 허용해야 영상채팅을 시작할 수 있습니다.",
    "perm.all_granted": "모든 권한 허용됨",
    "perm.allow": "권한 허용하기",
    "perm.camera": "카메라",
    "perm.mic": "마이크(소리)",
    "perm.location": "위치(GPS)",
    "perm.required": "권한허용필요",
    "setting.title": "설정",
    "setting.description": "나라/언어/성별을 설정하세요.",
    "setting.country": "나라(지역)",
    "setting.language": "언어",
    "setting.gender": "성별",
    "setting.font_size": "글자 크기",
    "setting.font_size_desc": "바를 좌우로 드래그해서 조절하세요. ({percent}%)",
    "common.save": "저장",
    "common.close": "닫기",
    "common.loading": "요청 중...",
    "common.not_set": "미설정",
    "profile.title": "프로필",
    "profile.subscription_status": "구독 상태",
    "profile.premium_active": "프리미엄 이용 중",
    "profile.free_active": "무료 이용 중",
    "profile.apply_premium": "프리미엄 신청하기",
    "profile.manage_subscription": "구독 관리",
    "profile.language_section": "언어 설정",
    "profile.current_language": "현재 언어: {language}",
    "profile.change_language": "언어 변경",
    "profile.terms_and_policies": "이용약관 및 정책",
    "profile.withdraw": "회원탈퇴",
    "modal.prefs.title": "설정",
    "modal.prefs.body": "나라/언어/성별을 설정하세요.",
    "prefs.current_country": "현재 나라",
    "prefs.current_gender": "현재 성별",
    "prefs.country_title": "나라(지역)",
    "prefs.gender_title": "성별",
    "modal.lang.title": "언어 선택",
    "modal.lang.body": "사용할 언어를 선택하세요.",
    "prefs.language_title": "언어",
    "modal.update.title": "업데이트 있음",
    "modal.update.body": "새 버전이 있습니다. 지금 업데이트하시겠습니까?",
    "modal.update.applying": "업데이트 적용 중...",
    "modal.update.apply": "지금 업데이트",
    "modal.update.later": "나중에",
    "modal.withdraw.title": "회원탈퇴",
    "modal.withdraw.body": "정말 탈퇴하시겠습니까? 모든 데이터가 삭제됩니다.",
    "modal.withdraw.confirm": "탈퇴하기",
    "modal.withdraw.cancel": "취소",
    "modal.policy.title": "정책",
    "modal.policy.terms": "이용약관",
    "modal.policy.privacy": "개인정보처리방침",
    "modal.policy.operation": "운영정책",
    "policy.title": "정책",
    "policy.url_missing": "정책 URL이 없습니다.",
    "gender.male": "남성",
    "gender.female": "여성",
    "common.hyphen": "-",
    "premium.title": "프리미엄",
    "premium.description": "광고 없이 더 쾌적하게 이용하세요.",
    "premium.benefit_ad": "광고 제거",
    "premium.benefit_ad_detail": "배너/전면 광고 제거",
    "premium.benefit_ux": "쾌적한 UX",
    "premium.benefit_ux_detail": "더 빠르고 매끄럽게",
    "premium.current_premium": "현재 프리미엄 이용 중",
    "premium.current_free": "현재 무료 이용 중",
    "premium.plan_select": "요금제 선택",
    "premium.weekly": "주간",
    "premium.monthly": "월간",
    "premium.yearly": "연간",
    "premium.light": "가볍게",
    "premium.recommended": "추천",
    "premium.discount": "할인",
    "premium.discount_tag": "약 {percent}% 할인",
    "premium.week": "주",
    "premium.month": "월",
    "premium.year": "년",
    "premium.start_weekly": "주간 시작",
    "premium.pay_monthly": "월간 결제",
    "premium.pay_yearly": "연간 결제",
    "premium.manage_subscription": "구독 관리",
    "premium.ad_remove_benefit": "광고 제거 혜택",
    "premium.benefit_ad_remove": "배너 광고 제거",
    "premium.benefit_fullscreen": "전면 광고 제거",
    "premium.benefit_manage_anytime": "언제든 구독 관리 가능",
    "premium.weekly_pay": "주간 결제",
    "premium.monthly_pay": "월간 결제",
    "premium.yearly_pay": "연간 결제",
    "premium.weekly_compare": "주간 대비",
    "premium.monthly_compare": "월간 대비",
    "premium.buy": "구매하기",
    "premium.upgrade_desc": "프리미엄으로 업그레이드하면 광고 없이 이용할 수 있습니다.",

    "call.free_time_over": "무료 통화 시간이 종료되었습니다.",
    "call.peer_left": "상대방이 방을 떠났습니다.\n새로운 상대를 찾는중...",
    "call.fast_matching": "빠른 매칭 중...",
    "call.connecting": "연결 중...",
    "call.matched": "매칭됨",
    "call.network_unstable": "네트워크 불안정",
    "common.settings": "설정",
    "auth.title": "인증",
    "common.error_occurred": "오류가 발생했습니다.",
    "payment.proceed": "결제 진행",
    "common.cancel": "취소",
    "screen.premium": "프리미엄",
  },
  en: {
    "home.title": "Random Video Chat",
    "home.subtitle": "Set region/language/gender then start matching.",
    "home.match_button": "Start Matching",
    "home.permission_setting": "Permission Settings",
    "perm.title": "Permissions Required",
    "perm.message": "You need to allow the following permissions to start video chat.",
    "perm.all_granted": "All permissions granted",
    "perm.allow": "Allow Permissions",
    "perm.camera": "Camera",
    "perm.mic": "Microphone",
    "perm.location": "Location (GPS)",
    "perm.required": "(Required)",
    "setting.title": "Settings",
    "setting.description": "Set country / language / gender.",
    "setting.country": "Country",
    "setting.language": "Language",
    "setting.gender": "Gender",
    "setting.font_size": "Font Size",
    "setting.font_size_desc": "Drag the bar to adjust. ({percent}%)",
    "common.save": "Save",
    "common.close": "Close",
    "common.loading": "Loading...",
    "common.not_set": "Not set",
    "profile.title": "Profile",
    "profile.subscription_status": "Subscription Status",
    "profile.premium_active": "Premium Active",
    "profile.free_active": "Free Active",
    "profile.apply_premium": "Apply Premium",
    "profile.manage_subscription": "Manage Subscription",
    "profile.language_section": "Language",
    "profile.current_language": "Current language: {language}",
    "profile.change_language": "Change Language",
    "profile.terms_and_policies": "Terms & Policies",
    "profile.withdraw": "Withdraw",
    "modal.prefs.title": "Settings",
    "modal.prefs.body": "Set country / language / gender.",
    "prefs.current_country": "Current Country",
    "prefs.current_gender": "Current Gender",
    "prefs.country_title": "Country",
    "prefs.gender_title": "Gender",
    "modal.lang.title": "Select Language",
    "modal.lang.body": "Choose your language.",
    "prefs.language_title": "Language",
    "modal.update.title": "Update Available",
    "modal.update.body": "New version available. Update now?",
    "modal.update.applying": "Applying...",
    "modal.update.apply": "Update Now",
    "modal.update.later": "Later",
    "modal.withdraw.title": "Withdraw Account",
    "modal.withdraw.body": "All data will be deleted. Confirm?",
    "modal.withdraw.confirm": "Withdraw",
    "modal.withdraw.cancel": "Cancel",
    "modal.policy.title": "Policies",
    "modal.policy.terms": "Terms of Service",
    "modal.policy.privacy": "Privacy Policy",
    "modal.policy.operation": "Operation Policy",
    "policy.title": "Policy",
    "policy.url_missing": "Policy URL missing.",
    "gender.male": "Male",
    "gender.female": "Female",
    "premium.title": "Premium",
    "premium.description": "Enjoy an ad-free, smoother experience.",
    "premium.benefit_ad": "No Ads",
    "premium.benefit_ad_detail": "Remove banner & interstitial ads",
    "premium.benefit_ux": "Better UX",
    "premium.benefit_ux_detail": "Faster and smoother",
    "premium.current_premium": "Premium is active",
    "premium.current_free": "Free plan is active",
    "premium.plan_select": "Choose a plan",
    "premium.weekly": "Weekly",
    "premium.monthly": "Monthly",
    "premium.yearly": "Yearly",
    "premium.light": "Light",
    "premium.recommended": "Recommended",
    "premium.discount": "off",
    "premium.discount_tag": "Save about {percent}%",
    "premium.week": "week",
    "premium.month": "month",
    "premium.year": "year",
    "premium.start_weekly": "Start weekly",
    "premium.pay_monthly": "Pay monthly",
    "premium.pay_yearly": "Pay yearly",
    "premium.manage_subscription": "Manage subscription",
    "premium.ad_remove_benefit": "Ad removal benefits",
    "premium.benefit_ad_remove": "Remove banner ads",
    "premium.benefit_fullscreen": "Remove interstitial ads",
    "premium.benefit_manage_anytime": "Manage anytime",
    "premium.weekly_pay": "Weekly payment",
    "premium.monthly_pay": "Monthly payment",
    "premium.yearly_pay": "Yearly payment",
    "premium.weekly_compare": "Compared to weekly",
    "premium.monthly_compare": "Compared to monthly",
    "premium.buy": "Buy",
    "premium.upgrade_desc": "Upgrade to Premium to remove ads.",

    "call.free_time_over": "Free call time is over.",
    "call.peer_left": "The other user left.\nFinding a new match...",
    "call.fast_matching": "Fast matching...",
    "call.connecting": "Connecting...",
    "call.matched": "Matched",
    "call.network_unstable": "Network unstable",
    "common.settings": "Settings",
    "auth.title": "Authentication",
    "common.error_occurred": "An error occurred.",
    "payment.proceed": "Proceed to payment",
    "common.cancel": "Cancel",
    "screen.premium": "Premium",

    "common.hyphen": "-"
  },
  ja: {
    "home.title": "ランダムビデオチャット",
    "home.subtitle": "地域/言語/性別を設定してからマッチングを開始してください。",
    "home.match_button": "マッチング開始",
    "home.permission_setting": "権限設定",
    "perm.title": "権限が必要です",
    "perm.message": "ビデオチャットを開始するには以下の権限を許可する必要があります。",
    "perm.all_granted": "すべての権限が許可されました",
    "perm.allow": "権限を許可する",
    "perm.camera": "カメラ",
    "perm.mic": "マイク",
    "perm.location": "位置情報(GPS)",
    "perm.required": "(必要)",
    "setting.title": "設定",
    "setting.description": "国/言語/性別を設定してください。",
    "setting.country": "国・地域",
    "setting.language": "言語",
    "setting.gender": "性別",
    "setting.font_size": "文字サイズ",
    "setting.font_size_desc": "バーを左右にドラッグして調整してください。({percent}%)",
    "common.save": "保存",
    "common.close": "閉じる",
    "common.loading": "リクエスト中...",
    "common.not_set": "未設定",
    "profile.title": "プロフィール",
    "profile.subscription_status": "サブスクリプション状況",
    "profile.premium_active": "プレミアム利用中",
    "profile.free_active": "無料利用中",
    "profile.apply_premium": "プレミアムを申し込む",
    "profile.manage_subscription": "サブスクリプション管理",
    "profile.language_section": "言語設定",
    "profile.current_language": "現在の言語: {language}",
    "profile.change_language": "言語を変更",
    "profile.terms_and_policies": "利用規約・ポリシー",
    "profile.withdraw": "退会",
    "modal.prefs.title": "設定",
    "modal.prefs.body": "国/言語/性別を設定してください。",
    "prefs.current_country": "現在の国",
    "prefs.current_gender": "現在の性別",
    "prefs.country_title": "国・地域",
    "prefs.gender_title": "性別",
    "modal.lang.title": "言語選択",
    "modal.lang.body": "使用する言語を選択してください。",
    "prefs.language_title": "言語",
    "modal.update.title": "アップデートあり",
    "modal.update.body": "新しいバージョンがあります。今すぐ更新しますか？",
    "modal.update.applying": "適用中...",
    "modal.update.apply": "今すぐ更新",
    "modal.update.later": "後で",
    "modal.withdraw.title": "退会",
    "modal.withdraw.body": "すべてのデータが削除されます。よろしいですか？",
    "modal.withdraw.confirm": "退会する",
    "modal.withdraw.cancel": "キャンセル",
    "modal.policy.title": "ポリシー",
    "modal.policy.terms": "利用規約",
    "modal.policy.privacy": "プライバシーポリシー",
    "modal.policy.operation": "運営ポリシー",
    "policy.title": "ポリシー",
    "policy.url_missing": "ポリシーURLがありません。",
    "gender.male": "男性",
    "gender.female": "女性",
    "premium.title": "プレミアム",
    "premium.description": "広告なしで、より快適にご利用いただけます。",
    "premium.benefit_ad": "広告削除",
    "premium.benefit_ad_detail": "バナー/全画面広告を削除",
    "premium.benefit_ux": "快適な体験",
    "premium.benefit_ux_detail": "より速く、よりスムーズに",
    "premium.current_premium": "現在：プレミアム利用中",
    "premium.current_free": "現在：無料利用中",
    "premium.plan_select": "プランを選択",
    "premium.weekly": "週間",
    "premium.monthly": "月間",
    "premium.yearly": "年間",
    "premium.light": "ライト",
    "premium.recommended": "おすすめ",
    "premium.discount": "割引",
    "premium.discount_tag": "約{percent}%割引",
    "premium.week": "週",
    "premium.month": "月",
    "premium.year": "年",
    "premium.start_weekly": "週間を開始",
    "premium.pay_monthly": "月間で支払う",
    "premium.pay_yearly": "年間で支払う",
    "premium.manage_subscription": "購読を管理",
    "premium.ad_remove_benefit": "広告削除の特典",
    "premium.benefit_ad_remove": "バナー広告を削除",
    "premium.benefit_fullscreen": "全画面広告を削除",
    "premium.benefit_manage_anytime": "いつでも購読を管理可能",
    "premium.weekly_pay": "週間のお支払い",
    "premium.monthly_pay": "月間のお支払い",
    "premium.yearly_pay": "年間のお支払い",
    "premium.weekly_compare": "週間と比べて",
    "premium.monthly_compare": "月間と比べて",
    "premium.buy": "購入する",
    "premium.upgrade_desc": "プレミアムにアップグレードすると広告なしで利用できます。",

    "call.free_time_over": "無料通話時間が終了しました。",
    "call.peer_left": "相手が退室しました。\n新しい相手を探しています...",
    "call.fast_matching": "高速マッチング中...",
    "call.connecting": "接続中...",
    "call.matched": "マッチしました",
    "call.network_unstable": "ネットワークが不安定です",
    "common.settings": "設定",
    "auth.title": "認証",
    "common.error_occurred": "エラーが発生しました。",
    "payment.proceed": "支払いを続行",
    "common.cancel": "キャンセル",
    "screen.premium": "プレミアム",

    "common.hyphen": "-"
  },
  zh: {
    "home.title": "随机视频聊天",
    "home.subtitle": "设置地区/语言/性别后开始匹配。",
    "home.match_button": "开始匹配",
    "home.permission_setting": "权限设置",
    "perm.title": "需要权限",
    "perm.message": "需要允许以下权限才能开始视频聊天。",
    "perm.all_granted": "所有权限已允许",
    "perm.allow": "允许权限",
    "perm.camera": "摄像头",
    "perm.mic": "麦克风",
    "perm.location": "位置(GPS)",
    "perm.required": "(需要)",
    "setting.title": "设置",
    "setting.description": "请设置国家/语言/性别。",
    "setting.country": "国家/地区",
    "setting.language": "语言",
    "setting.gender": "性别",
    "setting.font_size": "字体大小",
    "setting.font_size_desc": "左右拖动滑块调整。({percent}%)",
    "common.save": "保存",
    "common.close": "关闭",
    "common.loading": "请求中...",
    "common.not_set": "未设置",
    "profile.title": "个人资料",
    "profile.subscription_status": "订阅状态",
    "profile.premium_active": "高级会员使用中",
    "profile.free_active": "免费使用中",
    "profile.apply_premium": "申请高级会员",
    "profile.manage_subscription": "管理订阅",
    "profile.language_section": "语言设置",
    "profile.current_language": "当前语言: {language}",
    "profile.change_language": "更改语言",
    "profile.terms_and_policies": "条款与政策",
    "profile.withdraw": "注销账号",
    "modal.prefs.title": "设置",
    "modal.prefs.body": "请设置国家/语言/性别。",
    "prefs.current_country": "当前国家",
    "prefs.current_gender": "当前性别",
    "prefs.country_title": "国家/地区",
    "prefs.gender_title": "性别",
    "modal.lang.title": "选择语言",
    "modal.lang.body": "请选择使用的语言。",
    "prefs.language_title": "语言",
    "modal.update.title": "有更新",
    "modal.update.body": "有新版本可用。立即更新吗？",
    "modal.update.applying": "正在应用...",
    "modal.update.apply": "立即更新",
    "modal.update.later": "稍后",
    "modal.withdraw.title": "注销账号",
    "modal.withdraw.body": "所有数据将被删除。确认吗？",
    "modal.withdraw.confirm": "注销",
    "modal.withdraw.cancel": "取消",
    "modal.policy.title": "政策",
    "modal.policy.terms": "服务条款",
    "modal.policy.privacy": "隐私政策",
    "modal.policy.operation": "运营政策",
    "policy.title": "政策",
    "policy.url_missing": "政策链接不存在。",
    "gender.male": "男性",
    "gender.female": "女性",
    "premium.title": "高级会员",
    "premium.description": "无广告，更流畅的使用体验。",
    "premium.benefit_ad": "去除广告",
    "premium.benefit_ad_detail": "去除横幅/插屏广告",
    "premium.benefit_ux": "更佳体验",
    "premium.benefit_ux_detail": "更快更顺畅",
    "premium.current_premium": "当前：高级会员已开通",
    "premium.current_free": "当前：免费使用中",
    "premium.plan_select": "选择套餐",
    "premium.weekly": "周",
    "premium.monthly": "月",
    "premium.yearly": "年",
    "premium.light": "轻量",
    "premium.recommended": "推荐",
    "premium.discount": "优惠",
    "premium.discount_tag": "约省{percent}%",
    "premium.week": "周",
    "premium.month": "月",
    "premium.year": "年",
    "premium.start_weekly": "开通周套餐",
    "premium.pay_monthly": "开通月套餐",
    "premium.pay_yearly": "开通年套餐",
    "premium.manage_subscription": "管理订阅",
    "premium.ad_remove_benefit": "去广告权益",
    "premium.benefit_ad_remove": "去除横幅广告",
    "premium.benefit_fullscreen": "去除插屏广告",
    "premium.benefit_manage_anytime": "可随时管理订阅",
    "premium.weekly_pay": "周套餐支付",
    "premium.monthly_pay": "月套餐支付",
    "premium.yearly_pay": "年套餐支付",
    "premium.weekly_compare": "相比周套餐",
    "premium.monthly_compare": "相比月套餐",
    "premium.buy": "购买",
    "premium.upgrade_desc": "升级高级会员即可去除广告。",

    "call.free_time_over": "免费通话时间已结束。",
    "call.peer_left": "对方已离开。\n正在寻找新的匹配...",
    "call.fast_matching": "快速匹配中...",
    "call.connecting": "连接中...",
    "call.matched": "已匹配",
    "call.network_unstable": "网络不稳定",
    "common.settings": "设置",
    "auth.title": "认证",
    "common.error_occurred": "发生错误。",
    "payment.proceed": "继续支付",
    "common.cancel": "取消",
    "screen.premium": "高级会员",

    "common.hyphen": "-"
  },
  es: {
    "home.title": "Chat de Video Aleatorio",
    "home.subtitle": "Configura región/idioma/género y comienza a emparejar.",
    "home.match_button": "Iniciar Emparejamiento",
    "home.permission_setting": "Configuración de Permisos",
    "perm.title": "Se necesitan permisos",
    "perm.message": "Debes permitir los siguientes permisos para iniciar el chat de video.",
    "perm.all_granted": "Todos los permisos concedidos",
    "perm.allow": "Permitir Permisos",
    "perm.camera": "Cámara",
    "perm.mic": "Micrófono",
    "perm.location": "Ubicación (GPS)",
    "perm.required": "(Requerido)",
    "setting.title": "Ajustes",
    "setting.description": "Configura país/idioma/género.",
    "setting.country": "País",
    "setting.language": "Idioma",
    "setting.gender": "Género",
    "setting.font_size": "Tamaño de fuente",
    "setting.font_size_desc": "Arrastra la barra para ajustar. ({percent}%)",
    "common.save": "Guardar",
    "common.close": "Cerrar",
    "common.loading": "Cargando...",
    "common.not_set": "No establecido",
    "profile.title": "Perfil",
    "profile.subscription_status": "Estado de suscripción",
    "profile.premium_active": "Premium activo",
    "profile.free_active": "Gratis activo",
    "profile.apply_premium": "Solicitar Premium",
    "profile.manage_subscription": "Gestionar suscripción",
    "profile.language_section": "Configuración de idioma",
    "profile.current_language": "Idioma actual: {language}",
    "profile.change_language": "Cambiar idioma",
    "profile.terms_and_policies": "Términos y políticas",
    "profile.withdraw": "Eliminar cuenta",
    "modal.prefs.title": "Ajustes",
    "modal.prefs.body": "Configura país/idioma/género.",
    "prefs.current_country": "País actual",
    "prefs.current_gender": "Género actual",
    "prefs.country_title": "País",
    "prefs.gender_title": "Género",
    "modal.lang.title": "Seleccionar idioma",
    "modal.lang.body": "Elige tu idioma.",
    "prefs.language_title": "Idioma",
    "modal.update.title": "Actualización disponible",
    "modal.update.body": "¿Actualizar ahora?",
    "modal.update.applying": "Aplicando...",
    "modal.update.apply": "Actualizar ahora",
    "modal.update.later": "Más tarde",
    "modal.withdraw.title": "Eliminar cuenta",
    "modal.withdraw.body": "Todos los datos se eliminarán. ¿Confirmar?",
    "modal.withdraw.confirm": "Eliminar",
    "modal.withdraw.cancel": "Cancelar",
    "modal.policy.title": "Políticas",
    "modal.policy.terms": "Términos de servicio",
    "modal.policy.privacy": "Política de privacidad",
    "modal.policy.operation": "Política de operación",
    "policy.title": "Política",
    "policy.url_missing": "URL de política no encontrada.",
    "gender.male": "Masculino",
    "gender.female": "Femenino",
    "premium.title": "Premium",
    "premium.description": "Disfruta sin anuncios y con una experiencia más fluida.",
    "premium.benefit_ad": "Sin anuncios",
    "premium.benefit_ad_detail": "Elimina banners e intersticiales",
    "premium.benefit_ux": "Mejor experiencia",
    "premium.benefit_ux_detail": "Más rápido y estable",
    "premium.current_premium": "Estado: Premium activo",
    "premium.current_free": "Estado: Plan gratuito",
    "premium.plan_select": "Elegir plan",
    "premium.weekly": "Semanal",
    "premium.monthly": "Mensual",
    "premium.yearly": "Anual",
    "premium.light": "Ligero",
    "premium.recommended": "Recomendado",
    "premium.discount": "de descuento",
    "premium.discount_tag": "Ahorra ~{percent}%",
    "premium.week": "semana",
    "premium.month": "mes",
    "premium.year": "año",
    "premium.start_weekly": "Empezar semanal",
    "premium.pay_monthly": "Pagar mensual",
    "premium.pay_yearly": "Pagar anual",
    "premium.manage_subscription": "Gestionar suscripción",
    "premium.ad_remove_benefit": "Beneficios sin anuncios",
    "premium.benefit_ad_remove": "Eliminar banners",
    "premium.benefit_fullscreen": "Eliminar intersticiales",
    "premium.benefit_manage_anytime": "Gestionar en cualquier momento",
    "premium.weekly_pay": "Pago semanal",
    "premium.monthly_pay": "Pago mensual",
    "premium.yearly_pay": "Pago anual",
    "premium.weekly_compare": "Comparado con semanal",
    "premium.monthly_compare": "Comparado con mensual",
    "premium.buy": "Comprar",
    "premium.upgrade_desc": "Actualiza a Premium para eliminar anuncios.",

    "call.free_time_over": "El tiempo de llamada gratis ha terminado.",
    "call.peer_left": "La otra persona salió.\nBuscando una nueva coincidencia...",
    "call.fast_matching": "Emparejamiento rápido...",
    "call.connecting": "Conectando...",
    "call.matched": "Emparejado",
    "call.network_unstable": "Red inestable",
    "common.settings": "Ajustes",
    "auth.title": "Autenticación",
    "common.error_occurred": "Ocurrió un error.",
    "payment.proceed": "Proceder al pago",
    "common.cancel": "Cancelar",
    "screen.premium": "Premium",

    "common.hyphen": "-"
  },
  de: {
    "home.title": "Zufälliger Videochat",
    "home.subtitle": "Stelle Region/Sprache/Geschlecht ein und starte das Matching.",
    "home.match_button": "Matching starten",
    "home.permission_setting": "Berechtigungseinstellungen",
    "perm.title": "Berechtigungen erforderlich",
    "perm.message": "Du musst die folgenden Berechtigungen erlauben, um den Videochat zu starten.",
    "perm.all_granted": "Alle Berechtigungen erteilt",
    "perm.allow": "Berechtigungen erlauben",
    "perm.camera": "Kamera",
    "perm.mic": "Mikrofon",
    "perm.location": "Standort (GPS)",
    "perm.required": "(Erforderlich)",
    "setting.title": "Einstellungen",
    "setting.description": "Land/Sprache/Geschlecht einstellen.",
    "setting.country": "Land",
    "setting.language": "Sprache",
    "setting.gender": "Geschlecht",
    "setting.font_size": "Schriftgröße",
    "setting.font_size_desc": "Schieberegler ziehen zum Anpassen. ({percent}%)",
    "common.save": "Speichern",
    "common.close": "Schließen",
    "common.loading": "Wird geladen...",
    "common.not_set": "Nicht gesetzt",
    "profile.title": "Profil",
    "profile.subscription_status": "Abonnement-Status",
    "profile.premium_active": "Premium aktiv",
    "profile.free_active": "Kostenlos aktiv",
    "profile.apply_premium": "Premium beantragen",
    "profile.manage_subscription": "Abonnement verwalten",
    "profile.language_section": "Spracheinstellung",
    "profile.current_language": "Aktuelle Sprache: {language}",
    "profile.change_language": "Sprache ändern",
    "profile.terms_and_policies": "Nutzungsbedingungen & Richtlinien",
    "profile.withdraw": "Konto löschen",
    "modal.prefs.title": "Einstellungen",
    "modal.prefs.body": "Land/Sprache/Geschlecht einstellen.",
    "prefs.current_country": "Aktuelles Land",
    "prefs.current_gender": "Aktuelles Geschlecht",
    "prefs.country_title": "Land",
    "prefs.gender_title": "Geschlecht",
    "modal.lang.title": "Sprache wählen",
    "modal.lang.body": "Wähle deine Sprache.",
    "prefs.language_title": "Sprache",
    "modal.update.title": "Update verfügbar",
    "modal.update.body": "Neue Version verfügbar. Jetzt aktualisieren?",
    "modal.update.applying": "Wird angewendet...",
    "modal.update.apply": "Jetzt aktualisieren",
    "modal.update.later": "Später",
    "modal.withdraw.title": "Konto löschen",
    "modal.withdraw.body": "Alle Daten werden gelöscht. Bestätigen?",
    "modal.withdraw.confirm": "Löschen",
    "modal.withdraw.cancel": "Abbrechen",
    "modal.policy.title": "Richtlinien",
    "modal.policy.terms": "Nutzungsbedingungen",
    "modal.policy.privacy": "Datenschutz",
    "modal.policy.operation": "Betriebsrichtlinie",
    "policy.title": "Richtlinie",
    "policy.url_missing": "Richtlinien-URL fehlt.",
    "gender.male": "Männlich",
    "gender.female": "Weiblich","premium.title": "Premium",
    "premium.description": "Werbefrei und mit einer flüssigeren Nutzung.",
    "premium.benefit_ad": "Keine Werbung",
    "premium.benefit_ad_detail": "Banner- & Interstitial-Werbung entfernen",
    "premium.benefit_ux": "Bessere UX",
    "premium.benefit_ux_detail": "Schneller und stabiler",
    "premium.current_premium": "Status: Premium aktiv",
    "premium.current_free": "Status: Kostenlos aktiv",
    "premium.plan_select": "Plan auswählen",
    "premium.weekly": "Wöchentlich",
    "premium.monthly": "Monatlich",
    "premium.yearly": "Jährlich",
    "premium.light": "Light",
    "premium.recommended": "Empfohlen",
    "premium.discount": "Rabatt",
    "premium.discount_tag": "Ca. {percent}% sparen",
    "premium.week": "Woche",
    "premium.month": "Monat",
    "premium.year": "Jahr",
    "premium.start_weekly": "Wöchentlich starten",
    "premium.pay_monthly": "Monatlich zahlen",
    "premium.pay_yearly": "Jährlich zahlen",
    "premium.manage_subscription": "Abo verwalten",
    "premium.ad_remove_benefit": "Werbefrei-Vorteile",
    "premium.benefit_ad_remove": "Banner entfernen",
    "premium.benefit_fullscreen": "Interstitials entfernen",
    "premium.benefit_manage_anytime": "Jederzeit verwalten",
    "premium.weekly_pay": "Wöchentliche Zahlung",
    "premium.monthly_pay": "Monatliche Zahlung",
    "premium.yearly_pay": "Jährliche Zahlung",
    "premium.weekly_compare": "Gegenüber wöchentlich",
    "premium.monthly_compare": "Gegenüber monatlich",
    "premium.buy": "Kaufen",
    "premium.upgrade_desc": "Upgrade auf Premium, um Werbung zu entfernen.",

    "call.free_time_over": "Die kostenlose Gesprächszeit ist abgelaufen.",
    "call.peer_left": "Der andere Nutzer hat den Raum verlassen.\nSuche nach einem neuen Match...",
    "call.fast_matching": "Schnelles Matching...",
    "call.connecting": "Verbindung wird hergestellt...",
    "call.matched": "Gematcht",
    "call.network_unstable": "Netzwerk instabil",
    "common.settings": "Einstellungen",
    "auth.title": "Authentifizierung",
    "common.error_occurred": "Ein Fehler ist aufgetreten.",
    "payment.proceed": "Zur Zahlung fortfahren",
    "common.cancel": "Abbrechen",
    "screen.premium": "Premium",

    "common.hyphen": "-"
  },
  fr: {
    "home.title": "Chat Vidéo Aléatoire",
    "home.subtitle": "Définissez région/langue/sexe puis commencez le matching.",
    "home.match_button": "Commencer le matching",
    "home.permission_setting": "Paramètres des permissions",
    "perm.title": "Permissions requises",
    "perm.message": "Vous devez autoriser les permissions suivantes pour démarrer le chat vidéo.",
    "perm.all_granted": "Toutes les permissions accordées",
    "perm.allow": "Autoriser les permissions",
    "perm.camera": "Caméra",
    "perm.mic": "Microphone",
    "perm.location": "Localisation (GPS)",
    "perm.required": "(Requis)",
    "setting.title": "Paramètres",
    "setting.description": "Définir pays/langue/sexe.",
    "setting.country": "Pays",
    "setting.language": "Langue",
    "setting.gender": "Sexe",
    "setting.font_size": "Taille de police",
    "setting.font_size_desc": "Faites glisser la barre pour ajuster. ({percent}%)",
    "common.save": "Enregistrer",
    "common.close": "Fermer",
    "common.loading": "Chargement...",
    "common.not_set": "Non défini",
    "profile.title": "Profil",
    "profile.subscription_status": "Statut d'abonnement",
    "profile.premium_active": "Premium actif",
    "profile.free_active": "Gratuit actif",
    "profile.apply_premium": "Demander Premium",
    "profile.manage_subscription": "Gérer l'abonnement",
    "profile.language_section": "Paramètres de langue",
    "profile.current_language": "Langue actuelle : {language}",
    "profile.change_language": "Changer de langue",
    "profile.terms_and_policies": "Conditions & politiques",
    "profile.withdraw": "Supprimer le compte",
    "modal.prefs.title": "Paramètres",
    "modal.prefs.body": "Définir pays/langue/sexe.",
    "prefs.current_country": "Pays actuel",
    "prefs.current_gender": "Sexe actuel",
    "prefs.country_title": "Pays",
    "prefs.gender_title": "Sexe",
    "modal.lang.title": "Choisir la langue",
    "modal.lang.body": "Choisissez votre langue.",
    "prefs.language_title": "Langue",
    "modal.update.title": "Mise à jour disponible",
    "modal.update.body": "Nouvelle version disponible. Mettre à jour maintenant ?",
    "modal.update.applying": "Application en cours...",
    "modal.update.apply": "Mettre à jour maintenant",
    "modal.update.later": "Plus tard",
    "modal.withdraw.title": "Supprimer le compte",
    "modal.withdraw.body": "Toutes les données seront supprimées. Confirmer ?",
    "modal.withdraw.confirm": "Supprimer",
    "modal.withdraw.cancel": "Annuler",
    "modal.policy.title": "Politiques",
    "modal.policy.terms": "Conditions d'utilisation",
    "modal.policy.privacy": "Politique de confidentialité",
    "modal.policy.operation": "Politique d'exploitation",
    "policy.title": "Politique",
    "policy.url_missing": "URL de politique manquante.",
    "gender.male": "Homme",
    "gender.female": "Femme",
    "premium.title": "Premium",
    "premium.description": "Sans publicité, avec une expérience plus fluide.",
    "premium.benefit_ad": "Sans pub",
    "premium.benefit_ad_detail": "Supprime les bannières et interstitiels",
    "premium.benefit_ux": "Meilleure UX",
    "premium.benefit_ux_detail": "Plus rapide et plus stable",
    "premium.current_premium": "Statut : Premium actif",
    "premium.current_free": "Statut : Gratuit actif",
    "premium.plan_select": "Choisir une offre",
    "premium.weekly": "Hebdomadaire",
    "premium.monthly": "Mensuel",
    "premium.yearly": "Annuel",
    "premium.light": "Light",
    "premium.recommended": "Recommandé",
    "premium.discount": "de réduction",
    "premium.discount_tag": "Économisez ~{percent}%",
    "premium.week": "semaine",
    "premium.month": "mois",
    "premium.year": "an",
    "premium.start_weekly": "Démarrer hebdo",
    "premium.pay_monthly": "Payer mensuel",
    "premium.pay_yearly": "Payer annuel",
    "premium.manage_subscription": "Gérer l’abonnement",
    "premium.ad_remove_benefit": "Avantages sans pub",
    "premium.benefit_ad_remove": "Supprimer les bannières",
    "premium.benefit_fullscreen": "Supprimer les interstitiels",
    "premium.benefit_manage_anytime": "Gérer à tout moment",
    "premium.weekly_pay": "Paiement hebdo",
    "premium.monthly_pay": "Paiement mensuel",
    "premium.yearly_pay": "Paiement annuel",
    "premium.weekly_compare": "Par rapport à l’hebdo",
    "premium.monthly_compare": "Par rapport au mensuel",
    "premium.buy": "Acheter",
    "premium.upgrade_desc": "Passez en Premium pour supprimer les pubs.",

    "call.free_time_over": "La durée d’appel gratuit est terminée.",
    "call.peer_left": "L’autre personne a quitté la salle.\nRecherche d’un nouvel utilisateur...",
    "call.fast_matching": "Matching rapide...",
    "call.connecting": "Connexion...",
    "call.matched": "Match trouvé",
    "call.network_unstable": "Réseau instable",
    "common.settings": "Paramètres",
    "auth.title": "Authentification",
    "common.error_occurred": "Une erreur s'est produite.",
    "payment.proceed": "Procéder au paiement",
    "common.cancel": "Annuler",
    "screen.premium": "Premium",

    "common.hyphen": "-"
  },
  it: {
    "home.title": "Chat Video Casuale",
    "home.subtitle": "Imposta regione/lingua/genere e inizia il matching.",
    "home.match_button": "Inizia Matching",
    "home.permission_setting": "Impostazioni Permessi",
    "perm.title": "Permessi richiesti",
    "perm.message": "Devi autorizzare i seguenti permessi per iniziare il chat video.",
    "perm.all_granted": "Tutti i permessi concessi",
    "perm.allow": "Autorizza Permessi",
    "perm.camera": "Fotocamera",
    "perm.mic": "Microfono",
    "perm.location": "Posizione (GPS)",
    "perm.required": "(Richiesto)",
    "setting.title": "Impostazioni",
    "setting.description": "Imposta paese/lingua/genere.",
    "setting.country": "Paese",
    "setting.language": "Lingua",
    "setting.gender": "Genere",
    "setting.font_size": "Dimensione carattere",
    "setting.font_size_desc": "Trascina la barra per regolare. ({percent}%)",
    "common.save": "Salva",
    "common.close": "Chiudi",
    "common.loading": "Caricamento...",
    "common.not_set": "Non impostato",
    "profile.title": "Profilo",
    "profile.subscription_status": "Stato abbonamento",
    "profile.premium_active": "Premium attivo",
    "profile.free_active": "Gratuito attivo",
    "profile.apply_premium": "Richiedi Premium",
    "profile.manage_subscription": "Gestisci abbonamento",
    "profile.language_section": "Impostazioni lingua",
    "profile.current_language": "Lingua attuale: {language}",
    "profile.change_language": "Cambia lingua",
    "profile.terms_and_policies": "Termini e politiche",
    "profile.withdraw": "Elimina account",
    "modal.prefs.title": "Impostazioni",
    "modal.prefs.body": "Imposta paese/lingua/genere.",
    "prefs.current_country": "Paese attuale",
    "prefs.current_gender": "Genere attuale",
    "prefs.country_title": "Paese",
    "prefs.gender_title": "Genere",
    "modal.lang.title": "Seleziona lingua",
    "modal.lang.body": "Scegli la tua lingua.",
    "prefs.language_title": "Lingua",
    "modal.update.title": "Aggiornamento disponibile",
    "modal.update.body": "Nuova versione disponibile. Aggiornare ora?",
    "modal.update.applying": "Applicazione in corso...",
    "modal.update.apply": "Aggiorna ora",
    "modal.update.later": "Più tardi",
    "modal.withdraw.title": "Elimina account",
    "modal.withdraw.body": "Tutti i dati saranno eliminati. Confermare?",
    "modal.withdraw.confirm": "Elimina",
    "modal.withdraw.cancel": "Annulla",
    "modal.policy.title": "Politiche",
    "modal.policy.terms": "Termini di servizio",
    "modal.policy.privacy": "Informativa sulla privacy",
    "modal.policy.operation": "Politica operativa",
    "policy.title": "Politica",
    "policy.url_missing": "URL politica mancante.",
    "gender.male": "Maschio",
    "gender.female": "Femmina",
    "premium.title": "Premium",
    "premium.description": "Senza pubblicità e con un’esperienza più fluida.",
    "premium.benefit_ad": "Niente annunci",
    "premium.benefit_ad_detail": "Rimuovi banner e interstiziali",
    "premium.benefit_ux": "Migliore UX",
    "premium.benefit_ux_detail": "Più veloce e stabile",
    "premium.current_premium": "Stato: Premium attivo",
    "premium.current_free": "Stato: Gratuito attivo",
    "premium.plan_select": "Scegli un piano",
    "premium.weekly": "Settimanale",
    "premium.monthly": "Mensile",
    "premium.yearly": "Annuale",
    "premium.light": "Light",
    "premium.recommended": "Consigliato",
    "premium.discount": "di sconto",
    "premium.discount_tag": "Risparmia ~{percent}%",
    "premium.week": "settimana",
    "premium.month": "mese",
    "premium.year": "anno",
    "premium.start_weekly": "Inizia settimanale",
    "premium.pay_monthly": "Paga mensile",
    "premium.pay_yearly": "Paga annuale",
    "premium.manage_subscription": "Gestisci abbonamento",
    "premium.ad_remove_benefit": "Vantaggi senza annunci",
    "premium.benefit_ad_remove": "Rimuovi banner",
    "premium.benefit_fullscreen": "Rimuovi interstiziali",
    "premium.benefit_manage_anytime": "Gestisci in qualsiasi momento",
    "premium.weekly_pay": "Pagamento settimanale",
    "premium.monthly_pay": "Pagamento mensile",
    "premium.yearly_pay": "Pagamento annuale",
    "premium.weekly_compare": "Rispetto al settimanale",
    "premium.monthly_compare": "Rispetto al mensile",
    "premium.buy": "Acquista",
    "premium.upgrade_desc": "Passa a Premium per rimuovere gli annunci.",

    "call.free_time_over": "Il tempo di chiamata gratuita è terminato.",
    "call.peer_left": "L'altra persona ha lasciato la stanza.\nRicerca di un nuovo match...",
    "call.fast_matching": "Matching rapido...",
    "call.connecting": "Connessione...",
    "call.matched": "Abbinato",
    "call.network_unstable": "Rete instabile",
    "common.settings": "Impostazioni",
    "auth.title": "Autenticazione",
    "common.error_occurred": "Si è verificato un errore.",
    "payment.proceed": "Procedi al pagamento",
    "common.cancel": "Annulla",
    "screen.premium": "Premium",

    "common.hyphen": "-"
  },
  ru: {
    "home.title": "Случайный видеочат",
    "home.subtitle": "Установите регион/язык/пол и начните поиск.",
    "home.match_button": "Начать поиск",
    "home.permission_setting": "Настройки разрешений",
    "perm.title": "Требуются разрешения",
    "perm.message": "Чтобы начать видеочат, разрешите следующие права.",
    "perm.all_granted": "Все разрешения выданы",
    "perm.allow": "Разрешить",
    "perm.camera": "Камера",
    "perm.mic": "Микрофон",
    "perm.location": "Местоположение (GPS)",
    "perm.required": "(Обязательно)",
    "setting.title": "Настройки",
    "setting.description": "Установите страну/язык/пол.",
    "setting.country": "Страна",
    "setting.language": "Язык",
    "setting.gender": "Пол",
    "setting.font_size": "Размер шрифта",
    "setting.font_size_desc": "Перетащите ползунок для настройки. ({percent}%)",
    "common.save": "Сохранить",
    "common.close": "Закрыть",
    "common.loading": "Загрузка...",
    "common.not_set": "Не установлено",
    "profile.title": "Профиль",
    "profile.subscription_status": "Статус подписки",
    "profile.premium_active": "Премиум активен",
    "profile.free_active": "Бесплатный активен",
    "profile.apply_premium": "Оформить премиум",
    "profile.manage_subscription": "Управление подпиской",
    "profile.language_section": "Настройка языка",
    "profile.current_language": "Текущий язык: {language}",
    "profile.change_language": "Сменить язык",
    "profile.terms_and_policies": "Условия и политика",
    "profile.withdraw": "Удалить аккаунт",
    "modal.prefs.title": "Настройки",
    "modal.prefs.body": "Установите страну/язык/пол.",
    "prefs.current_country": "Текущая страна",
    "prefs.current_gender": "Текущий пол",
    "prefs.country_title": "Страна",
    "prefs.gender_title": "Пол",
    "modal.lang.title": "Выбор языка",
    "modal.lang.body": "Выберите язык.",
    "prefs.language_title": "Язык",
    "modal.update.title": "Доступно обновление",
    "modal.update.body": "Доступна новая версия. Обновить сейчас?",
    "modal.update.applying": "Применение...",
    "modal.update.apply": "Обновить сейчас",
    "modal.update.later": "Позже",
    "modal.withdraw.title": "Удалить аккаунт",
    "modal.withdraw.body": "Все данные будут удалены. Подтвердить?",
    "modal.withdraw.confirm": "Удалить",
    "modal.withdraw.cancel": "Отмена",
    "modal.policy.title": "Политики",
    "modal.policy.terms": "Условия использования",
    "modal.policy.privacy": "Политика конфиденциальности",
    "modal.policy.operation": "Политика эксплуатации",
    "policy.title": "Политика",
    "policy.url_missing": "URL политики отсутствует.",
    "gender.male": "Мужской",
    "gender.female": "Женский",
    "premium.title": "Премиум",
    "premium.description": "Без рекламы и с более плавной работой.",
    "premium.benefit_ad": "Без рекламы",
    "premium.benefit_ad_detail": "Убрать баннеры и интерстициалы",
    "premium.benefit_ux": "Лучший опыт",
    "premium.benefit_ux_detail": "Быстрее и стабильнее",
    "premium.current_premium": "Статус: Премиум активен",
    "premium.current_free": "Статус: Бесплатно",
    "premium.plan_select": "Выберите план",
    "premium.weekly": "Недельный",
    "premium.monthly": "Месячный",
    "premium.yearly": "Годовой",
    "premium.light": "Лайт",
    "premium.recommended": "Рекомендуем",
    "premium.discount": "скидка",
    "premium.discount_tag": "Экономия ~{percent}%",
    "premium.week": "неделя",
    "premium.month": "месяц",
    "premium.year": "год",
    "premium.start_weekly": "Начать недельный",
    "premium.pay_monthly": "Оплатить месячный",
    "premium.pay_yearly": "Оплатить годовой",
    "premium.manage_subscription": "Управление подпиской",
    "premium.ad_remove_benefit": "Преимущества без рекламы",
    "premium.benefit_ad_remove": "Убрать баннеры",
    "premium.benefit_fullscreen": "Убрать интерстициалы",
    "premium.benefit_manage_anytime": "Управлять в любое время",
    "premium.weekly_pay": "Недельная оплата",
    "premium.monthly_pay": "Месячная оплата",
    "premium.yearly_pay": "Годовая оплата",
    "premium.weekly_compare": "По сравнению с недельным",
    "premium.monthly_compare": "По сравнению с месячным",
    "premium.buy": "Купить",
    "premium.upgrade_desc": "Перейдите на Премиум, чтобы убрать рекламу.",

    "call.free_time_over": "Бесплатное время звонка закончилось.",
    "call.peer_left": "Собеседник покинул комнату.\nИщем нового собеседника...",
    "call.fast_matching": "Быстрый поиск...",
    "call.connecting": "Подключение...",
    "call.matched": "Совпадение найдено",
    "call.network_unstable": "Нестабильная сеть",
    "common.settings": "Настройки",
    "auth.title": "Аутентификация",
    "common.error_occurred": "Произошла ошибка.",
    "payment.proceed": "Перейти к оплате",
    "common.cancel": "Отмена",
    "screen.premium": "Премиум",

    "common.hyphen": "-"
  }
} as const;


================================================================================
 FILE: src\navigation\MainStack.tsx
================================================================================

﻿// FILE: C:\ranchat\src\navigation\MainStack.tsx
import React from "react";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import HomeScreen from "../screens/HomeScreen";
import CallScreen from "../screens/CallScreen";
import ProfileScreen from "../screens/ProfileScreen";
import PremiumScreen from "../screens/PremiumScreen";
import { theme } from "../config/theme";
import { useTranslation } from "../i18n/LanguageProvider";

export type MainStackParamList = {
  Home: undefined;
  Call: undefined;
  Profile: undefined;
  Premium: undefined;
};

const Stack = createNativeStackNavigator<MainStackParamList>();

export default function MainStack() {
  const { t } = useTranslation();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: { backgroundColor: theme.colors.bg },
        headerShadowVisible: false,
        headerTitleStyle: { fontWeight: "700" },
        contentStyle: { backgroundColor: theme.colors.bg },
      }}
    >
      <Stack.Screen name="Home" component={HomeScreen} options={{ title: t("screen.home") }} />
      <Stack.Screen name="Call" component={CallScreen} options={{ title: t("screen.call") }} />
      <Stack.Screen name="Profile" component={ProfileScreen} options={{ title: t("screen.profile") }} />
      <Stack.Screen name="Premium" component={PremiumScreen} options={{ title: t("screen.premium") }} />
    </Stack.Navigator>
  );
}

================================================================================
 FILE: src\navigation\RootNavigator.tsx
================================================================================

﻿import React, { useEffect } from "react";
import { NavigationContainer } from "@react-navigation/native";
import MainStack from "./MainStack";
import { useAppStore } from "../store/useAppStore";

import { bootstrapDeviceBinding } from "../services/auth/AuthBootstrap";
import GlobalModalHost from "../screens/_GlobalModalHost";
import { LanguageProvider, useTranslation } from "../i18n/LanguageProvider";

function toErrMsg(e: unknown) {
  if (typeof e === "string") return e;
  if (e && typeof e === "object" && "message" in e) return String((e as any).message || "UNKNOWN_ERROR");
  return "UNKNOWN_ERROR";
}

function RootNavigatorInner() {
  const hasHydrated = useAppStore((s) => s.hasHydrated);
  const authNonce = useAppStore((s) => s.authNonce);

  const setAuth = useAppStore((s) => s.setAuth);
  const showGlobalModal = useAppStore((s) => s.showGlobalModal);
  const { t } = useTranslation();

  useEffect(() => {
    if (!hasHydrated) return;

    (async () => {
      try {
        await bootstrapDeviceBinding();
      } catch (e) {
        setAuth({ verified: true, token: null, userId: null });
        showGlobalModal(t("auth.title"), toErrMsg(e));
      }
    })();
  }, [hasHydrated, authNonce, setAuth, showGlobalModal, t]);

  return (
    <NavigationContainer>
      <MainStack />
      <GlobalModalHost />
    </NavigationContainer>
  );
}

export default function RootNavigator() {
  return (
    <LanguageProvider>
      <RootNavigatorInner />
    </LanguageProvider>
  );
}


================================================================================
 FILE: src\screens\CallScreen.tsx
================================================================================

﻿// FILE: C:\ranchat\src\screens\CallScreen.tsx
import React, { useEffect, useRef, useState, useCallback, useMemo } from "react";
import { ActivityIndicator, StyleSheet, View, Pressable, Dimensions, ScrollView, Text } from "react-native";
import { RTCView } from "react-native-webrtc";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { Ionicons } from "@expo/vector-icons";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { theme } from "../config/theme";
import { APP_CONFIG } from "../config/app";
import { bootstrapDeviceBinding } from "../services/auth/AuthBootstrap";
import { useAppStore } from "../store/useAppStore";
import { SignalClient, SignalMessage } from "../services/signal/SignalClient";
import { WebRTCSession } from "../services/webrtc/WebRTCSession";
import { BannerBar, createInterstitial, initAds } from "../services/ads/AdManager";
import mobileAds, { AdEventType, NativeAd, NativeAdView, NativeAsset, NativeAssetType, NativeMediaView, NativeMediaAspectRatio, TestIds } from "react-native-google-mobile-ads";
import { purchasePremium, refreshSubscription } from "../services/purchases/PurchaseManager";
import type { MainStackParamList } from "../navigation/MainStack";
import AppText from "../components/AppText";
import FontSizeSlider from "../components/FontSizeSlider";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useTranslation } from "../i18n/LanguageProvider";

type Props = NativeStackScreenProps<MainStackParamList, "Call">;

type Phase = "connecting" | "queued" | "matched" | "calling" | "ended";

// ✅ APP_CONFIG 타입에 값이 없어도 TS 에러 없이 동작하도록 fallback 상수로 사용
const MATCH_TIMEOUT_MS = (() => {
  const v = Number((APP_CONFIG as any)?.MATCH_TIMEOUT_MS);
  return Number.isFinite(v) ? v : 60000;
})();

// ✅ 무료 30초 제한을 3000초로 변경(사실상 비활성 수준)
const FREE_CALL_LIMIT_MS = (() => {
  const direct = Number((APP_CONFIG as any)?.FREE_CALL_LIMIT_MS);
  if (Number.isFinite(direct)) return direct;

  const sec = Number((APP_CONFIG as any)?.FREE_LIMITS?.remoteVideoSeconds);
  if (Number.isFinite(sec)) return sec * 1000;

  return 3000 * 1000;
})();

// ✅ 전면광고 재노출 쿨다운(3분)
const INTERSTITIAL_COOLDOWN_MS = 4 * 60 * 1000;

function countryCodeToFlagEmoji(code: string) {
  const cc = String(code || "").trim().toUpperCase();
  if (cc.length !== 2) return "";
  const A = 0x1f1e6;
  const c1 = cc.charCodeAt(0) - 65;
  const c2 = cc.charCodeAt(1) - 65;
  if (c1 < 0 || c1 > 25 || c2 < 0 || c2 > 25) return "";
  return String.fromCodePoint(A + c1, A + c2);
}

function normalizeLanguageLabel(v: string) {
  const s = String(v || "").trim();
  const lower = s.toLowerCase();
  if (!s) return "";
  if (lower === "ko" || lower === "kor" || lower === "korean") return "한국어";
  if (lower === "en" || lower === "eng" || lower === "english") return "English";
  if (lower === "ja" || lower === "jpn" || lower === "japanese") return "日本語";
  if (lower === "zh" || lower === "chi" || lower === "chinese") return "中文";
  return s;
}

const NATIVE_UNIT_ID = (process.env.EXPO_PUBLIC_AD_UNIT_NATIVE_ANDROID ?? "").trim() || "ca-app-pub-5144004139813427/8416045900";

function QueueNativeAd256x144() {
  const [nativeAd, setNativeAd] = useState<NativeAd | null>(null);
  const adRef = useRef<NativeAd | null>(null);
  const { t } = useTranslation();

  useEffect(() => {
    let alive = true;

    NativeAd.createForAdRequest(NATIVE_UNIT_ID, { aspectRatio: NativeMediaAspectRatio.LANDSCAPE })
      .then((ad) => {
        if (!alive) {
          try {
            ad.destroy();
          } catch {}
          return;
        }
        adRef.current = ad;
        setNativeAd(ad);
      })
      .catch(() => {});

    return () => {
      alive = false;
      try {
        adRef.current?.destroy();
      } catch {}
      adRef.current = null;
    };
  }, []);

  if (!nativeAd) return null;

  return (
    <NativeAdView nativeAd={nativeAd} style={[styles.nativeAd256, { width: W, height: Math.round((W * 202) / 360) }]}>
      <View style={styles.nativeAdInner}>
        <NativeMediaView style={styles.nativeAdMedia} resizeMode="cover" />
        <View style={styles.nativeAdFooter}>
          <NativeAsset assetType={NativeAssetType.HEADLINE}>
            <Text style={styles.nativeAdHeadline} numberOfLines={1}>
              {nativeAd.headline}
            </Text>
          </NativeAsset>
          <AppText style={styles.nativeAdTag}>{t("common.ad")}</AppText>
        </View>
      </View>
    </NativeAdView>
  );
}

export default function CallScreen({ navigation }: Props) {

  const insets = useSafeAreaInsets();
  const { t } = useTranslation();

  const queuedLabel = useMemo(() => {
    return String(t("call.connecting") || "");
  }, [t]);

  const prefs = useAppStore((s) => s.prefs);
  const token = useAppStore((s) => s.auth.token);
  const isPremium = useAppStore((s) => s.sub.isPremium);
  const showGlobalModal = useAppStore((s: any) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [phase, setPhase] = useState<Phase>("connecting");
  const [roomId, setRoomId] = useState<string | null>(null);
  const [isCaller, setIsCaller] = useState(false);

  const [localStreamURL, setLocalStreamURL] = useState<string | null>(null);
  const [remoteStreamURL, setRemoteStreamURL] = useState<string | null>(null);

  const [remoteCamOn, setRemoteCamOn] = useState(true);

  const [myCamOn, setMyCamOn] = useState(true);
  const [mySoundOn, setMySoundOn] = useState(true);

  const [limitModal, setLimitModal] = useState(false);
  const [remoteVideoAllowed, setRemoteVideoAllowed] = useState(true);

  const [upgradeModal, setUpgradeModal] = useState(false);
  const [noMatchModal, setNoMatchModal] = useState(false);
  const [fastMatchHint, setFastMatchHint] = useState(false);

  const [reMatchText, setReMatchText] = useState<string>("");

  const [prefsModal, setPrefsModal] = useState(false);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  const wsRef = useRef<SignalClient | null>(null);
  const rtcRef = useRef<WebRTCSession | null>(null);
  const limitTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const matchInterstitialRef = useRef<ReturnType<typeof createInterstitial> | null>(null);
  const lastInterstitialAtRef = useRef<number>(0);

  const enqueuedRef = useRef(false);
  const queueRunningRef = useRef(false);

  const rebindOnceRef = useRef(false);

  const noMatchTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const requeueTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const premiumNoMatchAutoCloseRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const noMatchShownThisCycleRef = useRef(false);

  const canStart = useRef(false);

  const [adsReady, setAdsReady] = useState(false);
  const adsReadyRef = useRef(false);
  const adsAliveRef = useRef(true);
  const adsInitPromiseRef = useRef<Promise<any> | null>(null);
  const [bannerMountKey, setBannerMountKey] = useState(0);

  const adAllowedRef = useRef(false);
  const interstitialTokenRef = useRef(0);
  const interstitialCleanupRef = useRef<(() => void) | null>(null);
  const interstitialTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const iceStatsTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const lastIceInfoRef = useRef<any>(null);
  const [iceInfoText, setIceInfoText] = useState<string>("");

  const [peerInfo, setPeerInfo] = useState<any>(null);

  // ✅ 최신 상태 참조용 ref들(통화 중 ws close 시 재매칭/종료 방지)
  const phaseRef = useRef<Phase>("connecting");
  const roomIdRef = useRef<string | null>(null);
  const myCamOnRef = useRef<boolean>(true);
  const mySoundOnRef = useRef<boolean>(true);

  const manualCloseRef = useRef(false);
  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const reconnectAttemptRef = useRef(0);

  const webrtcDownTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const webrtcDownTokenRef = useRef(0);

  const [signalUnstable, setSignalUnstable] = useState(false);

  const waitAdsReady = useCallback(async (maxWaitMs = 1000) => {
    if (adsReadyRef.current) return true;

    try {
      initAds();
    } catch {}

    if (!adsInitPromiseRef.current) {
      try {
        const p = mobileAds().initialize();
        adsInitPromiseRef.current = Promise.resolve(p as any);

        (p as any)?.then?.(() => {
          if (adsReadyRef.current) return;
          adsReadyRef.current = true;
          if (!adsAliveRef.current) return;
          setAdsReady(true);
        }).catch?.(() => {});
      } catch {}
    }

    const p = adsInitPromiseRef.current;
    if (!p) return adsReadyRef.current;

    try {
      await Promise.race([
        p,
        new Promise((resolve) => setTimeout(resolve, Math.max(0, maxWaitMs))),
      ]);
    } catch {}

    return adsReadyRef.current;
  }, []);

  const peerCountryRaw = useMemo(() => String((peerInfo as any)?.country ?? ""), [peerInfo]);
  const peerLangRaw = useMemo(() => String((peerInfo as any)?.language ?? (peerInfo as any)?.lang ?? ""), [peerInfo]);
  const peerFlag = useMemo(() => {
    const direct = String((peerInfo as any)?.flag ?? "").trim();
    return direct || countryCodeToFlagEmoji(peerCountryRaw);
  }, [peerInfo, peerCountryRaw]);
  const peerLangLabel = useMemo(() => {
    const direct = String((peerInfo as any)?.languageLabel ?? "").trim();
    return direct || normalizeLanguageLabel(peerLangRaw);
  }, [peerInfo, peerLangRaw]);
  const peerGenderRaw = useMemo(() => String((peerInfo as any)?.gender ?? ""), [peerInfo]);
  const peerGenderLabel = useMemo(() => {
    const direct = String((peerInfo as any)?.genderLabel ?? "").trim();
    if (direct) return direct;
    const g = String(peerGenderRaw || "").trim().toLowerCase();
    if (!g) return "";
    if (g === "male" || g === "m") return t("gender.male");
    if (g === "female" || g === "f") return t("gender.female");
    return peerGenderRaw;
  }, [peerInfo, peerGenderRaw, t]);

  const peerInfoText = useMemo(() => {
    const parts: string[] = [];
    if (peerLangLabel) parts.push(peerLangLabel);

    const countryPart = (peerFlag ? `${peerFlag} ` : "") + (peerCountryRaw || "");
    if (countryPart.trim()) parts.push(countryPart.trim());

    if (peerGenderLabel) parts.push(peerGenderLabel);

    return parts.join(" · ");
  }, [peerLangLabel, peerFlag, peerCountryRaw, peerGenderLabel]);

  const myCountryRaw = useMemo(() => String((prefs as any)?.country ?? ""), [prefs]);
  const myLangRaw = useMemo(() => String((prefs as any)?.language ?? (prefs as any)?.lang ?? ""), [prefs]);
  const myFlag = useMemo(() => countryCodeToFlagEmoji(myCountryRaw), [myCountryRaw]);
  const myLangLabel = useMemo(() => normalizeLanguageLabel(myLangRaw), [myLangRaw]);
  const myGenderRaw = useMemo(() => String((prefs as any)?.gender ?? ""), [prefs]);
  const myGenderLabel = useMemo(() => {
    const g = String(myGenderRaw || "").trim().toLowerCase();
    if (!g) return "";
    if (g === "male" || g === "m") return t("gender.male");
    if (g === "female" || g === "f") return t("gender.female");
    return myGenderRaw;
  }, [myGenderRaw, t]);


  useEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  useEffect(() => {
    canStart.current = Boolean(String(prefs.country || "").length > 0 && String(prefs.gender || "").length > 0);
  }, [prefs.country, prefs.gender]);

  useEffect(() => {
    phaseRef.current = phase;
  }, [phase]);

  useEffect(() => {
    roomIdRef.current = roomId;
  }, [roomId]);

  useEffect(() => {
    myCamOnRef.current = myCamOn;
  }, [myCamOn]);

  useEffect(() => {
    mySoundOnRef.current = mySoundOn;
  }, [mySoundOn]);

  useEffect(() => {
    adsAliveRef.current = true;
    waitAdsReady(1000);
    return () => {
      adsAliveRef.current = false;
    };
  }, [waitAdsReady]);

  useEffect(() => {
    if (!adsReady) return;
    setBannerMountKey((k) => k + 1);
  }, [adsReady]);

  const startNoMatchTimer = () => {
    if (noMatchShownThisCycleRef.current) return;
    if (noMatchTimerRef.current) clearTimeout(noMatchTimerRef.current);

    noMatchTimerRef.current = setTimeout(() => {
      if (noMatchShownThisCycleRef.current) return;
      noMatchShownThisCycleRef.current = true;

      if (isPremium) {
        setFastMatchHint(true);
        setNoMatchModal(true);

        if (premiumNoMatchAutoCloseRef.current) clearTimeout(premiumNoMatchAutoCloseRef.current);
        premiumNoMatchAutoCloseRef.current = setTimeout(() => {
          setNoMatchModal(false);
        }, 3000);

        return;
      }

      queueRunningRef.current = false;
      enqueuedRef.current = false;

      try {
        wsRef.current?.leaveQueue();
      } catch {}
      try {
        manualCloseRef.current = true;
        wsRef.current?.close();
      } catch {}
      wsRef.current = null;

      setNoMatchModal(true);
    }, MATCH_TIMEOUT_MS);
  };

  const clearNoMatchTimer = () => {
    if (noMatchTimerRef.current) clearTimeout(noMatchTimerRef.current);
    noMatchTimerRef.current = null;

    if (premiumNoMatchAutoCloseRef.current) clearTimeout(premiumNoMatchAutoCloseRef.current);
    premiumNoMatchAutoCloseRef.current = null;
  };

  const clearIceStatsTimer = () => {
    if (iceStatsTimerRef.current) clearInterval(iceStatsTimerRef.current);
    iceStatsTimerRef.current = null;
  };

  const clearReconnectTimer = () => {
    if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
    reconnectTimerRef.current = null;
    reconnectAttemptRef.current = 0;
  };

  const clearWebrtcDownTimer = () => {
    if (webrtcDownTimerRef.current) clearTimeout(webrtcDownTimerRef.current);
    webrtcDownTimerRef.current = null;
    webrtcDownTokenRef.current += 1;
  };

  const updateIceInfo = useCallback(async () => {
    try {
      const info = await (rtcRef.current as any)?.getIcePathInfo?.();
      if (!info) return;

      lastIceInfoRef.current = info;

      const lc = String(info.localCandidateType ?? "").trim();
      const rc = String(info.remoteCandidateType ?? "").trim();
      const lp = String(info.localProtocol ?? "").trim();
      const rp = String(info.remoteProtocol ?? "").trim();

      const rttMs = Number.isFinite(Number(info.currentRoundTripTimeMs)) ? `${Math.round(Number(info.currentRoundTripTimeMs))}ms` : "";
      const outKbps = Number.isFinite(Number(info.availableOutgoingBitrate))
        ? `${Math.max(0, Math.round(Number(info.availableOutgoingBitrate) / 1000))}kbps`
        : "";

      const parts: string[] = [];
      if (lc || lp) parts.push(`L:${lc || "?"}${lp ? `/${lp}` : ""}`);
      if (rc || rp) parts.push(`R:${rc || "?"}${rp ? `/${rp}` : ""}`);
      if (rttMs) parts.push(`RTT:${rttMs}`);
      if (outKbps) parts.push(`OUT:${outKbps}`);

      const text = parts.length ? `ICE ${parts.join(" · ")}` : "";

      setIceInfoText((prev) => (prev === text ? prev : text));
    } catch {}
  }, []);

  const stopAll = () => {
    adAllowedRef.current = false;
    interstitialTokenRef.current += 1;

    if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
    interstitialTimerRef.current = null;

    try {
      interstitialCleanupRef.current?.();
    } catch {}
    interstitialCleanupRef.current = null;

    matchInterstitialRef.current = null;

    if (requeueTimerRef.current) clearTimeout(requeueTimerRef.current);
    requeueTimerRef.current = null;

    clearNoMatchTimer();

    clearIceStatsTimer();
    lastIceInfoRef.current = null;
    setIceInfoText("");

    clearReconnectTimer();
    clearWebrtcDownTimer();

    setSignalUnstable(false);

    noMatchShownThisCycleRef.current = false;
    setFastMatchHint(false);

    queueRunningRef.current = false;
    enqueuedRef.current = false;

    try {
      wsRef.current?.leaveQueue();
    } catch {}
    try {
      manualCloseRef.current = true;
      wsRef.current?.close();
    } catch {}
    wsRef.current = null;

    try {
      rtcRef.current?.stop();
    } catch {}
    rtcRef.current = null;

    if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
    limitTimerRef.current = null;

    setLocalStreamURL(null);
    setRemoteStreamURL(null);
    setRoomId(null);
    setPeerInfo(null);
    setRemoteVideoAllowed(true);
    setRemoteCamOn(true);
    setLimitModal(false);
    setPhase("ended");
  };

  const goHome = useCallback(() => {
    const nav: any = navigation as any;

    let root: any = nav;
    try {
      while (root?.getParent?.()) root = root.getParent();
    } catch {}

    try {
      const st = root?.getState?.();
      const first = st?.routes?.[0]?.name;
      if (first) {
        root.reset({ index: 0, routes: [{ name: first }] });
        return;
      }
    } catch {}

    try {
      root?.popToTop?.();
    } catch {}
  }, [navigation]);

  const onPressBack = () => {
    stopAll();
    goHome();
  };

  const showInterstitialIfAllowed = useCallback(
    async (after: () => void) => {
      if (isPremium) {
        after();
        return;
      }

      if (!adAllowedRef.current) {
        after();
        return;
      }

      try {
        interstitialCleanupRef.current?.();
      } catch {}
      interstitialCleanupRef.current = null;

      if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
      interstitialTimerRef.current = null;

      const token = interstitialTokenRef.current + 1;
      interstitialTokenRef.current = token;

      const now = Date.now();
      const diff = now - (lastInterstitialAtRef.current || 0);
      const allowed = diff >= INTERSTITIAL_COOLDOWN_MS;

      if (!allowed) {
        adAllowedRef.current = false;
        after();
        return;
      }

      const ready = await waitAdsReady(1000);
      if (!ready) {
        adAllowedRef.current = false;
        after();
        return;
      }

      const ad = createInterstitial();

      let done = false;
      const runOnce = () => {
        if (done) return;
        if (interstitialTokenRef.current !== token) return;
        done = true;
        cleanup();
        adAllowedRef.current = false;
        after();
      };

      let unsubClosed: any = null;
      let unsubLoaded: any = null;
      let unsubError: any = null;

      const cleanup = () => {
        try {
          unsubClosed?.();
        } catch {}
        try {
          unsubLoaded?.();
        } catch {}
        try {
          unsubError?.();
        } catch {}
        unsubClosed = null;
        unsubLoaded = null;
        unsubError = null;

        if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
        interstitialTimerRef.current = null;

        interstitialCleanupRef.current = null;
      };

      interstitialCleanupRef.current = cleanup;

      unsubClosed = ad.addAdEventListener(AdEventType.CLOSED, runOnce);
      unsubLoaded = ad.addAdEventListener(AdEventType.LOADED, () => {
        if (interstitialTokenRef.current !== token) return;
        if (!adAllowedRef.current) return;

        try {
          ad.show();
          lastInterstitialAtRef.current = Date.now();
        } catch {
          runOnce();
        }
      });
      unsubError = ad.addAdEventListener(AdEventType.ERROR, runOnce);

      try {
        ad.load();
      } catch {
        runOnce();
        return;
      }

      interstitialTimerRef.current = setTimeout(runOnce, 1500);
    },
    [isPremium]
  );

  const beginCall = async (ws: SignalClient, rid: string, caller: boolean) => {
    try {
      const rtc = new WebRTCSession({
        onLocalStream: (s) => setLocalStreamURL(s.toURL()),
        onRemoteStream: (s) => setRemoteStreamURL(s.toURL()),
        onIceCandidate: (c) => ws.sendIce(rid, c),
        onAnswer: (sdp) => ws.sendAnswer(rid, sdp),
        onOffer: (sdp) => ws.sendOffer(rid, sdp),
        onConnectionState: (s) => {
          const st = String(s || "").toLowerCase();

          if (st === "connected") {
            clearWebrtcDownTimer();

            if (!iceStatsTimerRef.current) {
              updateIceInfo();
              iceStatsTimerRef.current = setInterval(() => {
                updateIceInfo();
              }, 2000);
            }
            return;
          }

          if (st === "failed" || st === "disconnected" || st === "closed") {
            clearIceStatsTimer();
            updateIceInfo();

            const tokenNow = webrtcDownTokenRef.current + 1;
            webrtcDownTokenRef.current = tokenNow;

            if (webrtcDownTimerRef.current) clearTimeout(webrtcDownTimerRef.current);
            webrtcDownTimerRef.current = setTimeout(() => {
              if (webrtcDownTokenRef.current !== tokenNow) return;
              if (phaseRef.current !== "calling") return;

              // ✅ 실제 WebRTC 끊김이 일정 시간 지속될 때만 재매칭
              endCallAndRequeue("disconnect");
            }, 8000);

            return;
          }
        },
      });

      rtcRef.current = rtc;
      await rtc.start({ isCaller: caller });

      // ✅ 사용자가 꺼둔 상태(카메라/마이크)를 새 세션에도 즉시 적용
      try {
        rtcRef.current?.setLocalVideoEnabled(Boolean(myCamOnRef.current));
      } catch {}
      try {
        rtcRef.current?.setLocalAudioEnabled(Boolean(mySoundOnRef.current));
      } catch {}

      setReMatchText("");
      setPhase("calling");

      try {
        ws.relay(rid, { type: "cam", enabled: Boolean(myCamOnRef.current) });
      } catch {}

      if (!isPremium) {
        if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
        limitTimerRef.current = setTimeout(() => {
          setRemoteVideoAllowed(false);
          setLimitModal(true);
        }, FREE_CALL_LIMIT_MS);
      }
    } catch (e) {
      useAppStore.getState().showGlobalModal(t("call.error_title"), t("call.error_start"));
      try {
        ws.leaveRoom(rid);
      } catch {}
      stopAll();
      navigation.goBack();
    }
  };

  const endCallAndRequeue = (why: "remote_left" | "disconnect" | "error" | "find_other") => {
    if (why === "remote_left") {
      setReMatchText(`${t("call.peer_left")}\n${queuedLabel}`);
    } else if (why === "find_other") {
      setReMatchText(queuedLabel);
    } else {
      setReMatchText("");
    }


    stopAll();
    setNoMatchModal(false);
    setPhase("connecting");

    if (requeueTimerRef.current) clearTimeout(requeueTimerRef.current);
    requeueTimerRef.current = setTimeout(() => {
      startQueue();
    }, 350);
  };

  const startQueue = () => {
    if (queueRunningRef.current) return;
    queueRunningRef.current = true;
    enqueuedRef.current = false;

    if (wsRef.current) {
      try {
        wsRef.current.close();
      } catch {}
      wsRef.current = null;
    }

    manualCloseRef.current = false;
    clearReconnectTimer();
    clearWebrtcDownTimer();

    noMatchShownThisCycleRef.current = false;
    setFastMatchHint(false);

    if (!canStart.current) {
      useAppStore.getState().showGlobalModal(t("call.match_title"), t("call.match_filter_missing"));
      queueRunningRef.current = false;
      navigation.goBack();
      return;
    }

    setNoMatchModal(false);
    setPhase("connecting");
    startNoMatchTimer();

    matchInterstitialRef.current = null;

    const ws = new SignalClient({
      onOpen: () => {
        // ✅ 재연결 성공 시(통화 중 포함) 네트워크 불안정 표시 해제 + backoff 초기화
        setSignalUnstable(false);
        reconnectAttemptRef.current = 0;

        // ✅ 통화 중 재연결은 "재매칭/재큐잉" 금지, 상태만 동기화
        if (phaseRef.current === "calling") {
          const rid = roomIdRef.current;

          if (rid) {
            try {
              ws.relay(rid, {
                type: "peer_info",
                country: myCountryRaw,
                language: myLangRaw,
                gender: myGenderRaw,
                flag: myFlag,
                languageLabel: myLangLabel,
                genderLabel: myGenderLabel,
              });
            } catch {}

            try {
              ws.relay(rid, { type: "cam", enabled: Boolean(myCamOnRef.current) });
            } catch {}
          }

          return;
        }

        setPhase("queued");

        if (enqueuedRef.current) return;
        enqueuedRef.current = true;

        startNoMatchTimer();
        ws.enqueue(String(prefs.country), String(prefs.gender));
      },
      onClose: () => {
        if (manualCloseRef.current) return;

        // ✅ 통화 중에는 재매칭/종료 금지 -> 재연결(backoff)만 수행 + "네트워크 불안정" 표시
        if (phaseRef.current === "calling") {
          setSignalUnstable(true);

          if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
          const attempt = reconnectAttemptRef.current + 1;
          reconnectAttemptRef.current = attempt;

          const base = Math.min(15000, 500 * Math.pow(2, attempt - 1));
          const jitter = Math.floor(Math.random() * 250);
          const delay = Math.min(30000, base + jitter);

          reconnectTimerRef.current = setTimeout(() => {
            if (manualCloseRef.current) return;
            if (phaseRef.current !== "calling") return;
            if (wsRef.current !== ws) return;

            const tokenNow = useAppStore.getState().auth.token;
            ws.connect(APP_CONFIG.SIGNALING_URL, tokenNow);
          }, delay);

          return;
        }

        if (queueRunningRef.current) {
          endCallAndRequeue("disconnect");
        }
      },
      onMessage: async (msg: SignalMessage) => {
        if (msg.type === "queued") {
          setPhase("queued");
          startNoMatchTimer();
          return;
        }

        if (msg.type === "match") {
          // ✅ 통화 중에는 재매칭 금지(순간 재연결/중복 match 방지)
          if (phaseRef.current === "calling") {
            return;
          }

          clearNoMatchTimer();
          setNoMatchModal(false);
          setFastMatchHint(false);

          // ✅ 매칭되면 더 이상 "큐가 돈다"로 취급하지 않음(WS close로 재매칭 트리거 방지)
          queueRunningRef.current = false;
          enqueuedRef.current = false;

          setRoomId(msg.roomId);
          setIsCaller(Boolean(msg.isCaller));
          setPhase("matched");

          try {
            ws.relay(msg.roomId, {
              type: "peer_info",
              country: myCountryRaw,
              language: myLangRaw,
              gender: myGenderRaw,
              flag: myFlag,
              languageLabel: myLangLabel,
              genderLabel: myGenderLabel,
            });
          } catch {}

          const run = () => beginCall(ws, msg.roomId, Boolean(msg.isCaller));

          run();
          return;
        }

        if (msg.type === "signal") {
          const d: any = (msg as any).data;
          const t = String(d?.type ?? d?.kind ?? "").toLowerCase();

          if (t === "cam") {
            setRemoteCamOn(Boolean(d?.enabled));
            return;
          }

          if (t === "peer_info") {
            setPeerInfo({
              country: String(d?.country ?? "").trim(),
              language: String(d?.language ?? d?.lang ?? "").trim(),
              gender: String(d?.gender ?? "").trim(),
              flag: String(d?.flag ?? "").trim(),
              languageLabel: String(d?.languageLabel ?? "").trim(),
              genderLabel: String(d?.genderLabel ?? "").trim(),
            });
            return;
          }
        }

        if (msg.type === "offer") {
          await rtcRef.current?.handleRemoteOffer(msg.sdp);
          return;
        }
        if (msg.type === "answer") {
          await rtcRef.current?.handleRemoteAnswer(msg.sdp);
          return;
        }
        if (msg.type === "ice") {
          await rtcRef.current?.handleRemoteIce(msg.candidate);
          return;
        }
        if (msg.type === "end") {
          endCallAndRequeue("remote_left");
          return;
        }

        if (msg.type === "error") {
          const reason = String(msg.message ?? "").trim();
          const reasonLower = reason.toLowerCase();

          if (reasonLower === "session_replaced") {
            try {
              wsRef.current?.close();
            } catch {}
            stopAll();
            goHome();
            return;
          }

          // ✅ 재연결/중복 요청 등으로 나올 수 있는 서버 응답은 무시(모달/통화 실패 방지)
          if (reasonLower === "already_in_room" || reasonLower === "not_in_room") {
            return;
          }

          if (reasonLower === "not_registered") {
            if (rebindOnceRef.current) {
              useAppStore.getState().showGlobalModal(t("auth.title"), reason || "not_registered");
              stopAll();
              navigation.goBack();
              return;
            }

            rebindOnceRef.current = true;
            stopAll();
            setNoMatchModal(false);
            setPhase("connecting");

            (async () => {
              try {
                await bootstrapDeviceBinding();
                startQueue();
              } catch (e) {
                const m = typeof e === "object" && e && "message" in (e as any) ? String((e as any).message) : String(e);
                useAppStore.getState().showGlobalModal(t("auth.title"), m || "BIND_FAILED");
                navigation.goBack();
              }
            })();

            return;
          }

          useAppStore.getState().showGlobalModal(t("call.match_title"), reason || t("common.error_occurred"));
          endCallAndRequeue("error");
          return;
        }
      },
    });

    wsRef.current = ws;

    const tokenNow = useAppStore.getState().auth.token;
    ws.connect(APP_CONFIG.SIGNALING_URL, tokenNow);
  };

  const toggleCam = () => {
    const next = !myCamOn;
    setMyCamOn(next);
    rtcRef.current?.setLocalVideoEnabled(next);

    try {
      if (roomId) wsRef.current?.relay(roomId, { type: "cam", enabled: next });
    } catch {}
  };

  const toggleSound = () => {
    const next = !mySoundOn;
    setMySoundOn(next);
    rtcRef.current?.setLocalAudioEnabled(next);
  };

  const purchase = async () => {
    await purchasePremium();
    await refreshSubscription();
    const nowPremium = useAppStore.getState().sub.isPremium;
    if (nowPremium) {
      setUpgradeModal(false);
      setLimitModal(false);
      setRemoteVideoAllowed(true);
      if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
      limitTimerRef.current = null;
    }
  };

  useEffect(() => {
    lastInterstitialAtRef.current = Date.now();
    startQueue();
    return () => stopAll();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const endCall = () => {
    const go = () => endCallAndRequeue("find_other");

    try {
      wsRef.current?.leaveRoom(roomId || "");
    } catch {}
    try {
      wsRef.current?.close();
    } catch {}

    showInterstitialIfAllowed(go);
  };

  const retry = () => {
    setNoMatchModal(false);
    endCallAndRequeue("disconnect");
  };

  const dismissNoMatch = () => {
    if (premiumNoMatchAutoCloseRef.current) clearTimeout(premiumNoMatchAutoCloseRef.current);
    premiumNoMatchAutoCloseRef.current = null;
    setNoMatchModal(false);
  };

  const onPressFindOther = () => {
    adAllowedRef.current = true;

    const go = () => {
      try {
        wsRef.current?.leaveRoom(roomId || "");
      } catch {}
      endCallAndRequeue("find_other");
    };

    showInterstitialIfAllowed(go);
  };

  const setLanguage = useCallback(
    (lang: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ language: lang });
      } else if (typeof setPref === "function") {
        setPref("language", lang);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("language", lang);
      } else {
        showGlobalModal(t("common.settings"), "언어 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal, t]
  );

  const setCountry = useCallback(
    (iso: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ country: iso });
      } else if (typeof setPref === "function") {
        setPref("country", iso);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("country", iso);
      } else {
        showGlobalModal(t("common.settings"), "나라 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal, t]
  );

  const setGender = useCallback(
    (gender: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ gender });
      } else if (typeof setPref === "function") {
        setPref("gender", gender);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("gender", gender);
      } else {
        showGlobalModal(t("common.settings"), "성별 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal, t]
  );

  const languageOptions = useMemo(
    () => [
      { key: "ko", label: "한국어" },
      { key: "en", label: "English" },
      { key: "ja", label: "日本語" },
      { key: "zh", label: "中文" },
      { key: "es", label: "Español" },
    ],
    []
  );

  const countryOptions = useMemo(
    () => [
      { key: "KR", name: "Korea" },
      { key: "US", name: "United States" },
      { key: "JP", name: "Japan" },
      { key: "CN", name: "China" },
      { key: "TW", name: "Taiwan" },
      { key: "HK", name: "Hong Kong" },
      { key: "SG", name: "Singapore" },
      { key: "TH", name: "Thailand" },
      { key: "VN", name: "Vietnam" },
      { key: "PH", name: "Philippines" },
      { key: "ID", name: "Indonesia" },
      { key: "MY", name: "Malaysia" },
      { key: "IN", name: "India" },
      { key: "AU", name: "Australia" },
      { key: "CA", name: "Canada" },
      { key: "GB", name: "United Kingdom" },
      { key: "DE", name: "Germany" },
      { key: "FR", name: "France" },
      { key: "ES", name: "Spain" },
      { key: "IT", name: "Italy" },
      { key: "BR", name: "Brazil" },
      { key: "MX", name: "Mexico" },
    ],
    []
  );

  const genderOptions = useMemo(
    () => [
      { key: "male", label: t("gender.male") },
      { key: "female", label: t("gender.female") },
    ],
    [t]
  );

  const currentLanguageLabel = useMemo(() => {
    const cur = String((prefs as any)?.language || "");
    const found = languageOptions.find((x) => x.key === cur);
    return found ? found.label : cur || t("common.not_set");
  }, [languageOptions, prefs, t]);

  const currentCountryDisplay = useMemo(() => {
    const cur = String((prefs as any)?.country || "").toUpperCase();
    const found = countryOptions.find((x) => x.key === cur);
    const nm = found ? found.name : cur || t("common.not_set");
    const cc = found ? found.key : cur;
    const flag = countryCodeToFlagEmoji(cc);
    if (!cc) return nm;
    return `${flag ? flag + " " : ""}${nm} (${cc})`;
  }, [countryOptions, prefs, t]);

  const currentGenderLabel = useMemo(() => {
    const cur = String((prefs as any)?.gender || "");
    const found = genderOptions.find((x) => x.key === cur);
    return found ? found.label : cur || t("common.not_set");
  }, [genderOptions, prefs, t]);

  return (
    <View style={styles.root}>
      {/* ✅ 상단 헤더 제거, 뒤로가기만 오버레이(테두리 없음) */}
      <Pressable
        onPress={onPressBack}
        style={({ pressed }) => [
          styles.backBtn,
          { top: insets.top + 8, left: 12 },
          pressed ? { opacity: 0.7 } : null,
        ]}
      >
        <Ionicons name="chevron-back" size={30} color="#fff" />
      </Pressable>


      <View style={styles.stage}>
        {/* ✅ 상대 영상: 9:16 박스에 cover로 렌더링(상하 약간 여백) -> 좌우 크롭 감소 */}
        <View style={styles.remoteStage}>
          <View style={[styles.remoteBox, REMOTE_BOX, { transform: [{ translateY: REMOTE_SHIFT_Y }] }]}>
            {remoteStreamURL && remoteVideoAllowed && remoteCamOn ? (
              <RTCView streamURL={remoteStreamURL} style={styles.remoteVideo} objectFit="cover" zOrder={0} />
            ) : (
              <View style={styles.placeholder}>
                {phase === "calling" && !remoteVideoAllowed ? (
                  <AppText style={styles.placeholderText}>{t("call.free_time_over")}</AppText>
                ) : phase === "calling" && !remoteCamOn ? (
                  <Ionicons name="videocam-off" size={54} color="rgba(255, 255, 255, 0.92)" />
                ) : null}
              </View>
            )}
          </View>
        </View>


        {/* ✅ 내 캠 + 버튼(카메라/마이크/설정) 아래로 이동 + 선(라인) 제거 + 캠 OFF 오버레이 */}
        {phase === "calling" ? (
          <View style={[styles.localDock, { top: insets.top + 12, right: 12 }]}>
            <View style={styles.localFrame}>
              {localStreamURL ? (
                myCamOn ? (
                  <RTCView streamURL={localStreamURL} style={styles.localVideo} objectFit="cover" zOrder={1} />
                ) : (
                  <View style={styles.localCamOffBg} />
                )
              ) : (
                <View style={styles.localEmpty} />
              )}

              {!myCamOn ? (
                <View style={styles.camOffOverlay}>
                  <Ionicons name="videocam-off" size={34} color="rgba(255, 255, 255, 0.92)" />
                </View>
              ) : null}
            </View>


            <View style={styles.localControls}>
              <Pressable onPress={toggleCam} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name={myCamOn ? "videocam" : "videocam-off"} size={20} color="#fff" />
              </Pressable>

              <Pressable onPress={toggleSound} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name={mySoundOn ? "mic" : "mic-off"} size={20} color="#fff" />
              </Pressable>

              <Pressable onPress={() => setPrefsModal(true)} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name="settings-outline" size={20} color="#fff" />
              </Pressable>
            </View>
          </View>
        ) : null}

        {!isPremium && phase !== "calling" ? (
          <View style={[styles.queueAdDock, { top: insets.top + 55 }]}>
            <QueueNativeAd256x144 />
          </View>
        ) : null}


        {/* ✅ 연결/재매칭 상태 오버레이(상대 나가면 안내문+스피너+자동 재매칭) */}
        {phase !== "calling" ? (
          <View style={styles.centerOverlay}>
            <ActivityIndicator />

            <View style={styles.centerTextDock}>
              {reMatchText ? (
                <AppText style={styles.centerText}>{reMatchText}</AppText>
              ) : fastMatchHint ? (
                <AppText style={styles.centerText}>{t("call.fast_matching")}...</AppText>
              ) : phase === "connecting" ? (
                <AppText style={styles.centerText}>{t("call.connecting")}...</AppText>
              ) : phase === "matched" ? (
                <AppText style={styles.centerText}>{t("call.matched")}</AppText>
              ) : phase === "queued" ? (
                <AppText style={styles.centerText}>{queuedLabel}</AppText>
              ) : null}
            </View>

          </View>
        ) : null}


        {/* ✅ 새로고침 버튼은 프리미엄이어도 항상 보여야 함 (배너 유무에 따라 아래로 내려옴) */}
        <Pressable
          onPress={onPressFindOther}
          style={({ pressed }) => [
            styles.findOtherBtn,
            {
              right: 12,
              bottom: Math.max(insets.bottom, 8) + (isPremium ? 8 : 8 + (adsReady ? BANNER_RESERVED_HEIGHT : 0)),
            },
            pressed ? { opacity: 0.7 } : null,
          ]}
        >
          <Ionicons name="sync-circle" size={60} color="rgba(255, 205, 230, 0.84)" />
        </Pressable>

        {/* ✅ 우측하단 배너 + 그 위 내 나라/국기/언어 */}
        <View style={[styles.bannerDock, { paddingBottom: Math.max(insets.bottom, 8), left: 0, right: 0 }]}>
          <View style={styles.myInfoRow}>
            <View style={styles.myInfoCenter}>
              {peerInfoText ? <AppText style={styles.myInfoText}>{peerInfoText}</AppText> : null}
              {phase === "calling" && iceInfoText ? <AppText style={styles.myIceText}>{iceInfoText}</AppText> : null}
              {phase === "calling" && signalUnstable ? <AppText style={styles.netUnstableText}>{t("call.network_unstable")}</AppText> : null}
            </View>
          </View>


          {!isPremium && adsReady ? <BannerBar key={`banner_${bannerMountKey}`} /> : null}
        </View>
      </View>

      <AppModal
        visible={limitModal}
        title={t("call.limit_title")}
        dismissible={false}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title={t("call.limit_premium")} onPress={() => setUpgradeModal(true)} />
            <PrimaryButton title={t("common.exit")} onPress={() => { stopAll(); goHome(); }} variant="ghost" />
          </View>
        }
      >
        <AppText style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>
          {t("call.limit_message", { seconds: Math.round(FREE_CALL_LIMIT_MS / 1000) })}
        </AppText>
      </AppModal>

      <AppModal
        visible={upgradeModal}
        title={t("premium.title")}
        dismissible={true}
        onClose={() => setUpgradeModal(false)}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title={t("premium.buy")} onPress={purchase} />
            <PrimaryButton title={t("common.close")} onPress={() => setUpgradeModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>
          {t("premium.upgrade_desc")}
        </AppText>
      </AppModal>

      <AppModal
        visible={noMatchModal}
        title={isPremium ? t("call.fast_matching") : t("call.delay_matching")}
        dismissible={true}
        onClose={dismissNoMatch}
        footer={
          isPremium ? (
            <View style={{ gap: 10 }}>
              <PrimaryButton title={t("common.exit")} onPress={() => { stopAll(); goHome(); }} variant="ghost" />
            </View>
          ) : (
            <View style={{ gap: 10 }}>
              <PrimaryButton title={t("common.retry")} onPress={retry} />
              <PrimaryButton title={t("common.exit")} onPress={() => { stopAll(); goHome(); }} variant="ghost" />
            </View>
          )
        }
      >
        {isPremium ? (
          <AppText style={{ fontSize: 16, color: theme.colors.sub, lineHeight: 20 }}>
            {t("call.fast_matching_desc")}
          </AppText>
        ) : (
          <AppText style={{ fontSize: 16, color: theme.colors.sub, lineHeight: 20 }}>
            {t("call.delay_matching_desc")}
          </AppText>
        )}
      </AppModal>

      <AppModal
        visible={prefsModal}
        title={t("common.settings")}
        dismissible={true}

        onClose={() => {
          setPrefsModal(false);
          setLangOpen(false);
          setCountryOpen(false);
          setGenderOpen(false);
        }}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title={t("common.close")} onPress={() => setPrefsModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.modalText}>{t("setting.description")}</AppText>

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>{t("setting.country")}</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setCountryOpen((v) => !v);
            setLangOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentCountryDisplay}</AppText>
          <AppText style={styles.dropdownChevron}>{countryOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {countryOpen ? (
          <View style={styles.dropdownListWrap}>
            <ScrollView
              style={styles.dropdownScroll}
              contentContainerStyle={styles.dropdownScrollContent}
              showsVerticalScrollIndicator={true}
            >
              {countryOptions.map((opt) => {
                const active = String((prefs as any)?.country || "").toUpperCase() === opt.key;
                const flag = countryCodeToFlagEmoji(opt.key);
                return (
                  <Pressable
                    key={opt.key}
                    onPress={() => {
                      setCountry(opt.key);
                      setCountryOpen(false);
                    }}
                    style={({ pressed }) => [
                      styles.dropdownRow,
                      active ? styles.dropdownRowActive : null,
                      pressed ? { opacity: 0.75 } : null,
                    ]}
                  >
                    <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>
                      {flag ? `${flag} ` : ""}
                      {opt.name}
                    </AppText>

                    <View style={styles.countryRight}>
                      <AppText style={[styles.countryCode, active ? styles.countryCodeActive : null]}>({opt.key})</AppText>
                      {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                    </View>
                  </Pressable>
                );
              })}
            </ScrollView>
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>{t("setting.language")}</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setLangOpen((v) => !v);
            setCountryOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentLanguageLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{langOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {langOpen ? (
          <View style={styles.dropdownList}>
            {languageOptions.map((opt) => {
              const active = String((prefs as any)?.language || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setLanguage(opt.key);
                    setLangOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>{t("setting.gender")}</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setGenderOpen((v) => !v);
            setCountryOpen(false);
            setLangOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentGenderLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{genderOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {genderOpen ? (
          <View style={styles.dropdownList}>
            {genderOptions.map((opt) => {
              const active = String((prefs as any)?.gender || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setGender(opt.key);
                    setGenderOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>{t("setting.font_size")}</AppText>
        <AppText style={styles.modalText}>{t("setting.font_size_desc", { percent: Math.round(fontScale * 100) })}</AppText>
        <FontSizeSlider value={fontScale} onChange={setFontScale} />
      </AppModal>
    </View>
  );
}

const W = Dimensions.get("window").width;
const H = Dimensions.get("window").height;

// ✅ 큰 창을 9:16 박스로 고정(화면 안에 항상 들어오게)
// - 세로가 긴 폰(20:9 등)에서는 상하 여백이 생기고 좌우 크롭이 줄어듭니다.
const REMOTE_BOX = (() => {
  const w = W;
  const h = Math.round((w * 16) / 9);
  if (h <= H) return { width: w, height: h };

  const hh = H;
  const ww = Math.round((hh * 9) / 16);
  return { width: ww, height: hh };
})();

// ✅ 큰 화면을 아래로 내리는 값(픽셀). 더 내리고 싶으면 숫자만 키우면 됨.
const REMOTE_SHIFT_Y = -25;

const BANNER_RESERVED_HEIGHT = 60;
const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#000" },

  stage: { flex: 1, position: "relative", backgroundColor: "#000" },

  remoteStage: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#000",
    alignItems: "center",
    justifyContent: "center",
  },

  remoteBox: {
    overflow: "hidden",
    backgroundColor: "#000",
  },

  remoteVideo: { ...StyleSheet.absoluteFillObject, backgroundColor: "#000" },

  placeholder: { ...StyleSheet.absoluteFillObject, alignItems: "center", justifyContent: "center", backgroundColor: "#000" },
  placeholderText: { fontSize: 14, color: "rgba(255,255,255,0.75)", fontWeight: "700" },

  backBtn: {
    position: "absolute",
    zIndex: 20,
    width: 44,
    height: 44,
    alignItems: "flex-start",
    justifyContent: "center",
  },

  localDock: {
    position: "absolute",
    zIndex: 15,
    alignItems: "flex-end",
    gap: 10,
  },

  localFrame: {
    width: Math.min(180, W * 0.36),
    height: Math.min(200, W * 0.46),
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "#000",
  },

  localVideo: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#000",
    transform: [{ scale: 1.03 }],
  },

  localEmpty: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,255,255,0.08)",
  },

  localCamOffBg: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#000",
    borderRadius: 12,
  },

  camOffOverlay: {
    ...StyleSheet.absoluteFillObject,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#000",
    borderRadius: 12,
  },

  localControls: {
    width: Math.min(140, W * 0.34),
    flexDirection: "row",
    justifyContent: "flex-end",
    gap: 10,
    position: "relative",
    right: -6,
  },

  iconCircle: {
    width: 44,
    height: 44,
    borderRadius: 22,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.45)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.18)",
  },

  centerOverlay: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 10,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 18,
  },

  centerTextDock: {
    marginTop: 28,
    alignItems: "center",
    justifyContent: "center",
  },

  centerText: {
    textAlign: "center",
    fontSize: 20,
    fontWeight: "600",
    color: "rgba(139, 139, 139, 0.85)",
    lineHeight: 20,
  },

  queueAdDock: {
    position: "absolute",
    zIndex: 11,
    left: 0,
    right: 0,
    alignItems: "center",
  },

  nativeAd256: {
    width: 360,
    height: 202,
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "rgba(255,255,255,0.06)",
  },
  nativeAdInner: {
    flex: 1,
  },
  nativeAdMedia: {
    flex: 1,
  },
  nativeAdFooter: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "rgba(0,0,0,0.55)",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  nativeAdHeadline: {
    flex: 1,
    fontSize: 12,
    color: "rgba(255,255,255,0.92)",
    fontWeight: "800",
  },
  nativeAdTag: {
    fontSize: 11,
    color: "rgba(255,255,255,0.75)",
    fontWeight: "900",
  },

  bannerDock: {
    position: "absolute",
    zIndex: 12,
    bottom: 0,
    left: 0,
    right: 0,
    alignItems: "center",
    gap: 6,
  },

  myInfoRow: {
    width: "100%",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 12,
    position: "relative",
    minHeight: 52,
  },

  myInfoCenter: {
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
  },

  myInfoText: {
    color: "rgba(255,255,255,0.9)",
    fontSize: 15,
    fontWeight: "600",
  },

  myIceText: {
    color: "rgba(255,255,255,0.72)",
    fontSize: 11,
    fontWeight: "700",
    marginTop: 4,
  },

  netUnstableText: {
    color: "rgba(255, 170, 170, 0.92)",
    fontSize: 11,
    fontWeight: "900",
    marginTop: 3,
  },

  findOtherBtn: {
    position: "absolute",
    zIndex: 13,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  sectionTitle: { fontSize: 14, fontWeight: "700", color: theme.colors.text },

  dropdownBtn: {
    width: "100%",
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownBtnText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownChevron: { fontSize: 12, color: theme.colors.sub, fontWeight: "900" },

  dropdownList: {
    width: "100%",
    marginTop: 8,
    gap: 8,
  },

  dropdownListWrap: {
    width: "100%",
    marginTop: 8,
    borderRadius: 12,
    overflow: "hidden",
  },
  dropdownScroll: {
    maxHeight: 210,
  },
  dropdownScrollContent: {
    gap: 8,
  },

  dropdownRow: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownRowActive: {
    borderColor: theme.colors.pinkDeep,
    backgroundColor: theme.colors.cardSoft,
  },
  dropdownText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownTextActive: { color: theme.colors.pinkDeep },
  dropdownCheck: { fontSize: 14, color: theme.colors.pinkDeep, fontWeight: "900" },

  countryRight: { flexDirection: "row", alignItems: "center", gap: 10 },
  countryCode: { fontSize: 12, color: theme.colors.sub, fontWeight: "800" },
  countryCodeActive: { color: theme.colors.pinkDeep },
});


================================================================================
 FILE: src\screens\HomeScreen.tsx
================================================================================

﻿// FILE: C:\ranchat\src\screens\HomeScreen.tsx
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { Pressable, StyleSheet, View, ScrollView } from "react-native";
import { theme } from "../config/theme";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { BannerBar, createInterstitial } from "../services/ads/AdManager";
import { useAppStore } from "../store/useAppStore";
import { AdEventType } from "react-native-google-mobile-ads";
import AppText from "../components/AppText";
import FontSizeSlider from "../components/FontSizeSlider";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useTranslation } from "../i18n/LanguageProvider";

export default function HomeScreen({ navigation }: any) {
  const insets = useSafeAreaInsets();
  const { t, currentLang } = useTranslation();

  const prefs = useAppStore((s: any) => s.prefs);
  const isPremium = useAppStore((s: any) => s.sub.isPremium);
  const showGlobalModal = useAppStore((s: any) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [prefsModal, setPrefsModal] = useState(false);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  const interstitialRef = useRef<any>(null);

  const canMatch = useMemo(() => {
    const countryOk = String(prefs.country || "").length > 0;
    const genderOk = String(prefs.gender || "").length > 0;
    const langOk = String(prefs.language || "").length > 0;
    return countryOk && genderOk && langOk;
  }, [prefs.country, prefs.gender, prefs.language]);

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: "",
      headerLeft: () => (
        <Pressable
          onPress={() => navigation.navigate("Profile")}
          style={({ pressed }) => [styles.headerBtn, pressed ? { opacity: 0.6 } : null]}
        >
          <AppText style={styles.headerBtnText}>≡</AppText>
        </Pressable>
      ),
      headerRight: () => (
        <Pressable
          onPress={() => setPrefsModal(true)}
          style={({ pressed }) => [styles.headerBtn, pressed ? { opacity: 0.6 } : null]}
        >
          <AppText style={styles.headerBtnText}>⚙</AppText>
        </Pressable>
      ),
    });
  }, [navigation, t]);


  const isoToFlag = useCallback((iso: string) => {
    const cc = String(iso || "").toUpperCase();
    if (cc.length !== 2) return "";
    const A = 0x1f1e6;
    const c1 = cc.charCodeAt(0);
    const c2 = cc.charCodeAt(1);
    if (c1 < 65 || c1 > 90 || c2 < 65 || c2 > 90) return "";
    return String.fromCodePoint(A + (c1 - 65), A + (c2 - 65));
  }, []);

  const goCall = useCallback(() => {
    navigation.navigate("Call");
  }, [navigation]);

  const setLanguage = useCallback((lang: string) => {
    const st: any = useAppStore.getState?.() ?? {};
    const setPrefs = st.setPrefs;
    const setPref = st.setPref;
    const setPrefsField = st.setPrefsField;

    if (typeof setPrefs === "function") setPrefs({ language: lang });
    else if (typeof setPref === "function") setPref("language", lang);
    else if (typeof setPrefsField === "function") setPrefsField("language", lang);
    else showGlobalModal(t("setting.title"), t("setting.language_save_error"));
  }, [showGlobalModal, t]);

  const setCountry = useCallback((iso: string) => {
    const st: any = useAppStore.getState?.() ?? {};
    const setPrefs = st.setPrefs;
    const setPref = st.setPref;
    const setPrefsField = st.setPrefsField;

    if (typeof setPrefs === "function") setPrefs({ country: iso });
    else if (typeof setPref === "function") setPref("country", iso);
    else if (typeof setPrefsField === "function") setPrefsField("country", iso);
    else showGlobalModal(t("setting.title"), t("setting.country_save_error"));
  }, [showGlobalModal, t]);

  const setGender = useCallback((gender: string) => {
    const st: any = useAppStore.getState?.() ?? {};
    const setPrefs = st.setPrefs;
    const setPref = st.setPref;
    const setPrefsField = st.setPrefsField;

    if (typeof setPrefs === "function") setPrefs({ gender });
    else if (typeof setPref === "function") setPref("gender", gender);
    else if (typeof setPrefsField === "function") setPrefsField("gender", gender);
    else showGlobalModal(t("setting.title"), t("setting.gender_save_error"));
  }, [showGlobalModal, t]);

  const getLangLabel = useCallback((lang: string) => {
    const codeRaw = String(lang || "").trim().toLowerCase();
    const code = codeRaw === "kr" ? "ko" : codeRaw;
    const ui = String(currentLang || "ko").trim().toLowerCase();

    const labelsKo: Record<string, string> = {
      ko: "한국어",
      en: "영어",
      ja: "일본어",
      zh: "중국어",
      es: "스페인어",
      de: "독일어",
      fr: "프랑스어",
      it: "이탈리아어",
      ru: "러시아어",
    };

    const labelsEn: Record<string, string> = {
      ko: "Korean",
      en: "English",
      ja: "Japanese",
      zh: "Chinese",
      es: "Spanish",
      de: "German",
      fr: "French",
      it: "Italian",
      ru: "Russian",
    };

    const map = ui === "ko" ? labelsKo : labelsEn;
    return map[code] || code || t("common.not_set");
  }, [currentLang, t]);

  const languageOptions = useMemo(() => [
    { key: "ko", label: getLangLabel("ko") },
    { key: "en", label: getLangLabel("en") },
    { key: "ja", label: getLangLabel("ja") },
    { key: "zh", label: getLangLabel("zh") },
    { key: "es", label: getLangLabel("es") },
    { key: "de", label: getLangLabel("de") },
    { key: "fr", label: getLangLabel("fr") },
    { key: "it", label: getLangLabel("it") },
    { key: "ru", label: getLangLabel("ru") },
  ], [getLangLabel]);

  const countryOptions = useMemo(() => [
    { key: "KR", name: "Korea" },
    { key: "JP", name: "Japan" },
    { key: "CN", name: "China" },
    { key: "TW", name: "Taiwan" },
    { key: "HK", name: "Hong Kong" },
    { key: "SG", name: "Singapore" },
    { key: "TH", name: "Thailand" },
    { key: "VN", name: "Vietnam" },
    { key: "PH", name: "Philippines" },
    { key: "ID", name: "Indonesia" },
    { key: "MY", name: "Malaysia" },
    { key: "IN", name: "India" },
    { key: "US", name: "United States" },
    { key: "CA", name: "Canada" },
    { key: "GB", name: "United Kingdom" },
    { key: "AU", name: "Australia" },
    { key: "DE", name: "Germany" },
    { key: "FR", name: "France" },
    { key: "RU", name: "Russia" },
    { key: "ES", name: "Spain" },
    { key: "IT", name: "Italy" },
    { key: "BR", name: "Brazil" },
    { key: "MX", name: "Mexico" },
  ], []);

  const genderOptions = useMemo(() => [
    { key: "male", label: t("gender.male") },
    { key: "female", label: t("gender.female") },
  ], [t]);

  const currentLanguageLabel = useMemo(() => {
    const raw = String(prefs.language || "").trim().toLowerCase();
    const cur = raw === "kr" ? "ko" : raw;
    const found = languageOptions.find((x) => x.key === cur);
    return found ? found.label : cur ? getLangLabel(cur) : t("common.not_set");
  }, [getLangLabel, languageOptions, prefs.language, t]);

  const currentCountryDisplay = useMemo(() => {
    const cur = String(prefs.country || "").toUpperCase();
    const found = countryOptions.find((x) => x.key === cur);
    const nm = found ? found.name : cur || t("common.not_set");
    const cc = found ? found.key : cur;
    const flag = isoToFlag(cc);
    if (!cc) return nm;
    return `${flag ? flag + " " : ""}${nm} (${cc})`;
  }, [countryOptions, isoToFlag, prefs.country, t]);

  const currentGenderLabel = useMemo(() => {
    const cur = String(prefs.gender || "");
    const found = genderOptions.find((x) => x.key === cur);
    return found ? found.label : cur || t("common.not_set");
  }, [genderOptions, prefs.gender, t]);

  const onPressMatch = useCallback(() => {
    if (!canMatch) {
      setPrefsModal(true);
      return;
    }

    if (isPremium) {
      goCall();
      return;
    }

    const ad = createInterstitial();
    interstitialRef.current = ad;

    let done = false;
    const runOnce = () => {
      if (done) return;
      done = true;
      goCall();
    };

    let unsubClosed: any = null;
    let unsubLoaded: any = null;
    let unsubError: any = null;

    const cleanup = () => {
      try { unsubClosed?.(); } catch {}
      try { unsubLoaded?.(); } catch {}
      try { unsubError?.(); } catch {}
      unsubClosed = unsubLoaded = unsubError = null;
    };

    unsubClosed = ad.addAdEventListener(AdEventType.CLOSED, () => { cleanup(); runOnce(); });
    unsubLoaded = ad.addAdEventListener(AdEventType.LOADED, () => {
      try { ad.show(); } catch { cleanup(); runOnce(); }
    });
    unsubError = ad.addAdEventListener(AdEventType.ERROR, () => { cleanup(); runOnce(); });

    try { ad.load(); } catch { cleanup(); runOnce(); return; }

    setTimeout(() => { cleanup(); runOnce(); }, 1500);
  }, [canMatch, goCall, isPremium]);

  return (
    <View style={styles.root}>
      <View style={styles.body}>
        <View style={styles.center}>
          <AppText style={styles.title}>{t("home.title")}</AppText>
          <AppText style={styles.sub}>{t("home.subtitle")}</AppText>

          <View style={styles.matchBtnWrap}>
            <PrimaryButton title={t("home.match_button")} onPress={onPressMatch} />
          </View>
        </View>
      </View>

      {!isPremium ? (
        <View style={[styles.banner, { paddingBottom: Math.max(insets.bottom, 8) }]}>
          <BannerBar />
        </View>
      ) : null}

      {/* 설정 모달 */}
      <AppModal
        visible={prefsModal}
        title={t("setting.title")}
        dismissible={true}
        onClose={() => {
          setPrefsModal(false);
          setLangOpen(false);
          setCountryOpen(false);
          setGenderOpen(false);
        }}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title={t("common.close")} onPress={() => setPrefsModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.modalText}>{t("setting.description")}</AppText>

        {/* 나라 선택 */}
        <AppText style={styles.sectionTitle}>{t("setting.country")}</AppText>
        <Pressable onPress={() => { setCountryOpen((v) => !v); setLangOpen(false); setGenderOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
          <AppText style={styles.dropdownBtnText}>{currentCountryDisplay}</AppText>
          <AppText style={styles.dropdownChevron}>{countryOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {countryOpen && (
          <View style={styles.dropdownListWrap}>
            <ScrollView style={styles.dropdownScroll} contentContainerStyle={styles.dropdownScrollContent} showsVerticalScrollIndicator>
              {countryOptions.map((opt) => {
                const active = String(prefs.country || "").toUpperCase() === opt.key;
                const flag = isoToFlag(opt.key);
                return (
                  <Pressable
                    key={opt.key}
                    onPress={() => { setCountry(opt.key); setCountryOpen(false); }}
                    style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
                  >
                    <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>
                      {flag ? `${flag} ` : ""}{opt.name}
                    </AppText>
                    <View style={styles.countryRight}>
                      <AppText style={[styles.countryCode, active ? styles.countryCodeActive : null]}>({opt.key})</AppText>
                      {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
                    </View>
                  </Pressable>
                );
              })}
            </ScrollView>
          </View>
        )}

        {/* 언어 선택 - 스크롤 리스트로 변경 */}
        <AppText style={styles.sectionTitle}>{t("setting.language")}</AppText>
        <Pressable onPress={() => { setLangOpen((v) => !v); setCountryOpen(false); setGenderOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
          <AppText style={styles.dropdownBtnText}>{currentLanguageLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{langOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {langOpen && (
          <View style={styles.dropdownListWrap}>
            <ScrollView style={styles.dropdownScroll} contentContainerStyle={styles.dropdownScrollContent} showsVerticalScrollIndicator>
              {languageOptions.map((opt) => {
                const activeRaw = String(prefs.language || "").trim().toLowerCase();
                const activeLang = activeRaw === "kr" ? "ko" : activeRaw;
                const active = activeLang === opt.key;
                return (
                  <Pressable
                    key={opt.key}
                    onPress={() => { setLanguage(opt.key); setLangOpen(false); }}
                    style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
                  >
                    <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                    {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
                  </Pressable>
                );
              })}
            </ScrollView>
          </View>
        )}

        {/* 성별 선택 */}
        <AppText style={styles.sectionTitle}>{t("setting.gender")}</AppText>
        <Pressable onPress={() => { setGenderOpen((v) => !v); setCountryOpen(false); setLangOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
          <AppText style={styles.dropdownBtnText}>{currentGenderLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{genderOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {genderOpen && (
          <View style={styles.dropdownList}>
            {genderOptions.map((opt) => {
              const active = String(prefs.gender || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => { setGender(opt.key); setGenderOpen(false); }}
                  style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
                </Pressable>
              );
            })}
          </View>
        )}

        <AppText style={styles.sectionTitle}>{t("setting.font_size")}</AppText>
        <AppText style={styles.modalText}>{t("setting.font_size_desc", { percent: Math.round(fontScale * 100) })}</AppText>
        <FontSizeSlider value={fontScale} onChange={setFontScale} />
      </AppModal>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: theme.colors.bg },
  body: { flex: 1, padding: theme.spacing.lg },
  center: { flex: 1, alignItems: "center", justifyContent: "center", gap: 12 },
  title: { fontSize: 26, fontWeight: "700", color: theme.colors.text },
  sub: { fontSize: 14, color: theme.colors.sub, textAlign: "center", lineHeight: 20 },
  matchBtnWrap: { width: "100%", maxWidth: 420 },

  banner: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.line,
    backgroundColor: theme.colors.bg,
    alignItems: "center",
  },
  headerBtn: { paddingHorizontal: 12, paddingVertical: 8 },
  headerBtnText: { fontSize: 22, color: theme.colors.text, fontWeight: "700" },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  sectionTitle: { fontSize: 14, fontWeight: "700", color: theme.colors.text },

  dropdownBtn: {
    width: "100%",
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownBtnText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownChevron: { fontSize: 12, color: theme.colors.sub, fontWeight: "900" },

  dropdownList: { width: "100%", marginTop: 8, gap: 8 },
  dropdownListWrap: { width: "100%", marginTop: 8, borderRadius: 12, overflow: "hidden" },
  dropdownScroll: { maxHeight: 210 },
  dropdownScrollContent: { gap: 8 },

  dropdownRow: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownRowActive: { borderColor: theme.colors.pinkDeep, backgroundColor: theme.colors.cardSoft },
  dropdownText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownTextActive: { color: theme.colors.pinkDeep },
  dropdownCheck: { fontSize: 14, color: theme.colors.pinkDeep, fontWeight: "900" },

  countryRight: { flexDirection: "row", alignItems: "center", gap: 10 },
  countryCode: { fontSize: 12, color: theme.colors.sub, fontWeight: "800" },
  countryCodeActive: { color: theme.colors.pinkDeep },
});

================================================================================
 FILE: src\screens\PremiumScreen.tsx
================================================================================

﻿import React, { useMemo, useState } from "react";
import { ScrollView, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "../components/AppText";
import PrimaryButton from "../components/PrimaryButton";
import PremiumPaywallModal from "../components/PremiumPaywallModal";
import { purchasePremiumByProductId, refreshSubscription, openManageSubscriptions } from "../services/purchases/PurchaseManager";
import { useAppStore } from "../store/useAppStore";
import { useTranslation } from "../i18n/LanguageProvider";

const PRODUCT_IDS = {
  weekly: "ranchat_premium:weekly_-plan",
  monthly: "ranchat_premium:monthly2_-plan",
  yearly: "ranchat_premium:yearly2_-plan",
} as const;

type PlanKey = keyof typeof PRODUCT_IDS;

const PRICES = {
  weekly: 4900,
  monthly: 14900,
  yearly: 89000,
} as const;

function formatWon(n: number) {
  return n.toLocaleString("ko-KR") + "원";
}

function calcDiscountPercent(base: number, target: number) {
  if (base <= 0) return 0;
  const p = Math.round(((base - target) / base) * 100);
  return p < 0 ? 0 : p;
}

export default function PremiumScreen() {
  const { t } = useTranslation();
  const sub = useAppStore((s) => s.sub);

  const [payModal, setPayModal] = useState(false);
  const [selected, setSelected] = useState<PlanKey>("monthly");
  const [busy, setBusy] = useState(false);

  const weeklyVsMonthlyDiscount = useMemo(() => {
    const base = PRICES.weekly * 4;
    return calcDiscountPercent(base, PRICES.monthly);
  }, []);

  const monthlyVsYearlyDiscount = useMemo(() => {
    const base = PRICES.monthly * 12;
    return calcDiscountPercent(base, PRICES.yearly);
  }, []);

  const onSelect = (k: PlanKey) => {
    setSelected(k);
    setPayModal(true);
  };

  const onPay = async () => {
    if (busy) return;
    setBusy(true);
    try {
      const productId = PRODUCT_IDS[selected];
      await purchasePremiumByProductId(productId);
      await refreshSubscription();
      setPayModal(false);
    } finally {
      setBusy(false);
    }
  };

  return (
    <ScrollView contentContainerStyle={styles.wrap}>
      <View style={styles.hero}>
        <AppText style={styles.heroTitle}>{t("premium.title")}</AppText>
        <AppText style={styles.heroDesc}>
          {t("premium.description")}
        </AppText>

        <View style={{ height: 14 }} />

        <View style={styles.badgeRow}>
          <View style={styles.badge}>
            <AppText style={styles.badgeTop}>{t("premium.benefit_ad")}</AppText>
            <AppText style={styles.badgeBottom}>{t("premium.benefit_ad_detail")}</AppText>
          </View>
          <View style={styles.badge}>
            <AppText style={styles.badgeTop}>{t("premium.benefit_ux")}</AppText>
            <AppText style={styles.badgeBottom}>{t("premium.benefit_ux_detail")}</AppText>
          </View>
        </View>

        <View style={{ height: 10 }} />

        {sub.isPremium ? (
          <View style={styles.premiumOn}>
            <AppText style={styles.premiumOnTxt}>{t("premium.current_premium")}</AppText>
          </View>
        ) : (
          <View style={styles.premiumOff}>
            <AppText style={styles.premiumOffTxt}>{t("premium.current_free")}</AppText>
          </View>
        )}
      </View>

      <View style={styles.card}>
        <AppText style={styles.h1}>{t("premium.plan_select")}</AppText>

        <View style={{ height: 10 }} />

        <View style={styles.planBox}>
          <View style={styles.planTop}>
            <AppText style={styles.planName}>{t("premium.weekly")}</AppText>
            <View style={styles.pill}>
              <AppText style={styles.pillTxt}>{t("premium.light")}</AppText>
            </View>
          </View>
          <View style={styles.planMid}>
            <AppText style={styles.planPrice}>{formatWon(PRICES.weekly)}</AppText>
            <AppText style={styles.planUnit}>/ {t("premium.week")}</AppText>
          </View>
          <PrimaryButton title={t("premium.start_weekly")} onPress={() => onSelect("weekly")} />
        </View>

        <View style={{ height: 12 }} />

        <View style={[styles.planBox, styles.planHot]}>
          <View style={styles.planTop}>
            <AppText style={styles.planName}>{t("premium.monthly")}</AppText>
            <View style={[styles.pill, styles.pillHot]}>
              <AppText style={[styles.pillTxt, styles.pillTxtHot]}>{t("premium.recommended")}</AppText>
            </View>
            <View style={[styles.discountTag]}>
              <AppText style={styles.discountTxt}>{t("premium.discount_tag", { percent: weeklyVsMonthlyDiscount })}</AppText>
            </View>
          </View>
          <View style={styles.planMid}>
            <AppText style={styles.planPrice}>{formatWon(PRICES.monthly)}</AppText>
            <AppText style={styles.planUnit}>/ {t("premium.month")}</AppText>
          </View>
          <PrimaryButton title={t("premium.pay_monthly")} onPress={() => onSelect("monthly")} />
        </View>

        <View style={{ height: 12 }} />

        <View style={styles.planBox}>
          <View style={styles.planTop}>
            <AppText style={styles.planName}>{t("premium.yearly")}</AppText>
            <View style={[styles.discountTag]}>
              <AppText style={styles.discountTxt}>{t("premium.discount_tag", { percent: monthlyVsYearlyDiscount })}</AppText>
            </View>
          </View>
          <View style={styles.planMid}>
            <AppText style={styles.planPrice}>{formatWon(PRICES.yearly)}</AppText>
            <AppText style={styles.planUnit}>/ {t("premium.year")}</AppText>
          </View>
          <PrimaryButton title={t("premium.pay_yearly")} onPress={() => onSelect("yearly")} />
        </View>

        <View style={{ height: 14 }} />

        <PrimaryButton title={t("premium.manage_subscription")} onPress={openManageSubscriptions} variant="ghost" />
      </View>

      <View style={styles.card}>
        <AppText style={styles.h1}>{t("premium.ad_remove_benefit")}</AppText>
        <View style={{ height: 8 }} />
        <View style={styles.benefitRow}>
          <View style={styles.dot} />
          <AppText style={styles.benefitTxt}>{t("premium.benefit_ad_remove")}</AppText>
        </View>
        <View style={styles.benefitRow}>
          <View style={styles.dot} />
          <AppText style={styles.benefitTxt}>{t("premium.benefit_fullscreen")}</AppText>
        </View>
      </View>

      <PremiumPaywallModal
        visible={payModal}
        onClose={() => setPayModal(false)}
        title={selected === "weekly" ? t("premium.weekly_pay") : selected === "monthly" ? t("premium.monthly_pay") : t("premium.yearly_pay")}
        price={
          selected === "weekly"
            ? `${formatWon(PRICES.weekly)} / ${t("premium.week")}`
            : selected === "monthly"
              ? `${formatWon(PRICES.monthly)} / ${t("premium.month")}`
              : `${formatWon(PRICES.yearly)} / ${t("premium.year")}`
        }
        discountText={
          selected === "monthly"
            ? `${t("premium.weekly_compare")} ${weeklyVsMonthlyDiscount}% ${t("premium.discount")}`
            : selected === "yearly"
              ? `${t("premium.monthly_compare")} ${monthlyVsYearlyDiscount}% ${t("premium.discount")}`
              : undefined
        }
        benefitLines={[
          t("premium.benefit_ad_remove"),
          t("premium.benefit_fullscreen"),
          t("premium.benefit_manage_anytime"),
        ]}
        busy={busy}
        onConfirm={onPay}
      />
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  wrap: {
    padding: theme.spacing.lg,
    gap: theme.spacing.lg,
  },

  hero: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  heroTitle: { fontSize: 22, fontWeight: "900", color: theme.colors.text, marginBottom: 6 },
  heroDesc: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  badgeRow: { flexDirection: "row", gap: 10 },
  badge: {
    flex: 1,
    backgroundColor: theme.colors.white,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    paddingVertical: 12,
    paddingHorizontal: 12,
  },
  badgeTop: { fontSize: 14, fontWeight: "900", color: theme.colors.text, marginBottom: 2 },
  badgeBottom: { fontSize: 12, fontWeight: "700", color: theme.colors.sub },

  premiumOn: {
    marginTop: 12,
    borderRadius: 999,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: theme.colors.pinkDeep,
    backgroundColor: theme.colors.pinkDeep,
    alignItems: "center",
  },
  premiumOnTxt: { fontSize: 13, fontWeight: "900", color: theme.colors.white },

  premiumOff: {
    marginTop: 12,
    borderRadius: 999,
    paddingVertical: 10,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.white,
    alignItems: "center",
  },
  premiumOffTxt: { fontSize: 13, fontWeight: "900", color: theme.colors.text },

  card: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  h1: { fontSize: 17, fontWeight: "900", color: theme.colors.text, marginBottom: 6 },

  planBox: {
    backgroundColor: theme.colors.white,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
  },
  planHot: {
    borderColor: theme.colors.pinkDeep,
  },
  planTop: { flexDirection: "row", alignItems: "center", gap: 8, marginBottom: 8 },
  planName: { fontSize: 16, fontWeight: "900", color: theme.colors.text },

  pill: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.white,
  },
  pillHot: { borderColor: theme.colors.pinkDeep, backgroundColor: theme.colors.pinkDeep },
  pillTxt: { fontSize: 12, fontWeight: "900", color: theme.colors.text },
  pillTxtHot: { color: theme.colors.white },

  discountTag: {
    marginLeft: "auto",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: theme.colors.pinkDeep,
    backgroundColor: theme.colors.white,
  },
  discountTxt: { fontSize: 12, fontWeight: "900", color: theme.colors.pinkDeep },

  planMid: { flexDirection: "row", alignItems: "flex-end", gap: 6, marginBottom: 12 },
  planPrice: { fontSize: 20, fontWeight: "900", color: theme.colors.text },
  planUnit: { fontSize: 13, fontWeight: "900", color: theme.colors.sub, paddingBottom: 2 },

  benefitRow: { flexDirection: "row", alignItems: "center", gap: 10, paddingVertical: 8 },
  dot: { width: 8, height: 8, borderRadius: 99, backgroundColor: theme.colors.pinkDeep },
  benefitTxt: { fontSize: 14, fontWeight: "800", color: theme.colors.text },
});


================================================================================
 FILE: src\screens\ProfileScreen.tsx
================================================================================

﻿// FILE: C:\ranchat\src\screens\ProfileScreen.tsx
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { Linking, Pressable, ScrollView, StyleSheet, View } from "react-native";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { theme } from "../config/theme";
import { useAppStore } from "../store/useAppStore";
import { refreshSubscription, openManageSubscriptions } from "../services/purchases/PurchaseManager";
import { APP_CONFIG, COUNTRY_OPTIONS } from "../config/app";
import AppText from "../components/AppText";
import FontSizeSlider from "../components/FontSizeSlider";
import { useNavigation } from "@react-navigation/native";
import * as Updates from "expo-updates";
import { useTranslation } from "../i18n/LanguageProvider";


function toErrMsg(e: unknown) {
  if (typeof e === "string") return e;
  if (e && typeof e === "object" && "message" in e) return String((e as any).message || "UNKNOWN_ERROR");
  return "UNKNOWN_ERROR";
}

function safeT(t: (key: string, params?: Record<string, any>) => string, key: string, fallback: string, params?: Record<string, any>) {
  const v = t(key, params);
  if (!v || v === key) {
    let text = fallback;
    if (params) {
      Object.keys(params).forEach((k) => {
        text = text.replace(`{${k}}`, String(params[k]));
      });
    }
    return text;
  }
  return v;
}

function getLangDisplayLabel(lang: string, uiLang: string) {
  const code = String(lang || "").trim().toLowerCase();
  const ui = String(uiLang || "").trim().toLowerCase();

  const labelsKo: Record<string, string> = {
    ko: "한국어",
    en: "영어",
    ja: "일본어",
    zh: "중국어",
    es: "스페인어",
    de: "독일어",
    fr: "프랑스어",
    it: "이탈리아어",
    ru: "러시아어",
  };

  const labelsEn: Record<string, string> = {
    ko: "Korean",
    en: "English",
    ja: "Japanese",
    zh: "Chinese",
    es: "Spanish",
    de: "German",
    fr: "French",
    it: "Italian",
    ru: "Russian",
  };

  const map = ui === "ko" ? labelsKo : labelsEn;
  return map[code] || code || "-";
}

export default function ProfileScreen() {
  const navigation = useNavigation<any>();
  const { t, currentLang } = useTranslation();

  const prefs = useAppStore((s) => s.prefs);
  const sub = useAppStore((s) => s.sub);
  const logoutAndWipe = useAppStore((s) => s.logoutAndWipe);

  const setPrefs = useAppStore((s) => s.setPrefs);
  const showGlobalModal = useAppStore((s) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [prefsModal, setPrefsModal] = useState(false);
  const [withdrawModal, setWithdrawModal] = useState(false);
  const [policyModal, setPolicyModal] = useState(false);
  const [langModal, setLangModal] = useState(false);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  const [updateModal, setUpdateModal] = useState(false);
  const [updateBusy, setUpdateBusy] = useState(false);
  const updateCheckedRef = useRef(false);

  const countryLabel = useMemo(() => {
    const c = COUNTRY_OPTIONS.find((x) => x.code === prefs.country);
    return c?.label ?? safeT(t, "common.hyphen", "-", undefined);
  }, [prefs.country, t]);

  const genderLabel = useMemo(() => {
    const hy = safeT(t, "common.hyphen", "-", undefined);
    if (prefs.gender === "male") return safeT(t, "gender.male", "남성", undefined);
    if (prefs.gender === "female") return safeT(t, "gender.female", "여성", undefined);
    return hy;
  }, [prefs.gender, t]);

  const languageLabel = useMemo(() => {
    const hy = safeT(t, "common.hyphen", "-", undefined);
    const ui = String(currentLang || "ko");
    const code = String(prefs.language || "").trim().toLowerCase();
    if (!code) return hy;
    return getLangDisplayLabel(code, ui);
  }, [prefs.language, t, currentLang]);

  useLayoutEffect(() => {
    navigation.setOptions({
      headerTitle: () => <AppText style={styles.headerTitle}>{safeT(t, "profile.title", "프로필", undefined)}</AppText>,
      headerTitleAlign: "center",
      animation: "slide_from_left",
      headerLeftContainerStyle: styles.headerLeftContainer,
      headerRightContainerStyle: styles.headerRightContainer,
      headerLeft: () => (
        <Pressable onPress={() => navigation.goBack()} hitSlop={10} style={styles.headerBackBtn}>
          <AppText style={styles.headerBackTxt}>{"<"}</AppText>
        </Pressable>
      ),
      headerRight: () => (
        <Pressable
          onPress={() => setPrefsModal(true)}
          style={({ pressed }) => [styles.headerBtn, pressed ? { opacity: 0.6 } : null]}
        >
          <AppText style={styles.headerBtnText}>⚙</AppText>
        </Pressable>
      ),
    });
  }, [navigation, t]);

  useEffect(() => {
    if (__DEV__) return;
    if (!Updates.isEnabled) return;
    if (updateCheckedRef.current) return;
    updateCheckedRef.current = true;

    (async () => {
      try {
        const r = await Updates.checkForUpdateAsync();
        if (r.isAvailable) setUpdateModal(true);
      } catch {}
    })();
  }, []);

  const doApplyUpdate = async () => {
    if (updateBusy) return;
    setUpdateBusy(true);

    try {
      await Updates.fetchUpdateAsync();
      await Updates.reloadAsync();
    } catch (e) {
      setUpdateBusy(false);
      showGlobalModal(safeT(t, "modal.update.title", "업데이트", undefined), toErrMsg(e));
    }
  };

  const POLICY_BASE_URL =
    ((APP_CONFIG as any)?.POLICY?.baseUrl as string | undefined)?.trim() || "https://ppicassor-cpu.github.io";

  const POLICY_URLS = useMemo(() => {
    const termsUrl =
      ((APP_CONFIG as any)?.POLICY?.termsUrl as string | undefined)?.trim() || `${POLICY_BASE_URL}/terms.html`;
    const privacyUrl =
      ((APP_CONFIG as any)?.POLICY?.privacyUrl as string | undefined)?.trim() || `${POLICY_BASE_URL}/privacy.html`;
    const operationUrl =
      ((APP_CONFIG as any)?.POLICY?.operationUrl as string | undefined)?.trim() || `${POLICY_BASE_URL}/operation.html`;

    return { termsUrl, privacyUrl, operationUrl };
  }, [POLICY_BASE_URL]);

  const openPolicy = async (kind: "terms" | "privacy" | "operation") => {
    const url =
      kind === "terms"
        ? POLICY_URLS.termsUrl
        : kind === "privacy"
        ? POLICY_URLS.privacyUrl
        : POLICY_URLS.operationUrl;

    if (!url) {
      showGlobalModal(safeT(t, "policy.title", "정책", undefined), safeT(t, "policy.url_missing", "URL이 없습니다.", undefined));
      return;
    }

    try {
      await Linking.openURL(url);
    } catch (e) {
      showGlobalModal(safeT(t, "policy.title", "정책", undefined), toErrMsg(e));
    }
  };

  const goPremium = async () => {
    await refreshSubscription();
    navigation.navigate("Premium");
  };

  const doWithdraw = async () => {
    await logoutAndWipe();
  };

  return (
    <ScrollView contentContainerStyle={styles.wrap}>
      <View style={styles.card}>
        <AppText style={styles.h1}>{safeT(t, "profile.subscription_status", "구독 상태", undefined)}</AppText>
        <AppText style={styles.p}>{sub.isPremium ? safeT(t, "profile.premium_active", "프리미엄 이용 중", undefined) : safeT(t, "profile.free_active", "무료 이용 중", undefined)}</AppText>

        <View style={{ height: 10 }} />

        {!sub.isPremium ? <PrimaryButton title={safeT(t, "profile.apply_premium", "프리미엄 적용", undefined)} onPress={goPremium} /> : null}
        <View style={{ height: 10 }} />
        <PrimaryButton title={safeT(t, "profile.manage_subscription", "구독 관리", undefined)} onPress={openManageSubscriptions} variant="ghost" />
      </View>

      <View style={styles.card}>
        <AppText style={styles.h1}>{safeT(t, "profile.language_section", "언어", undefined)}</AppText>
        <AppText style={styles.p}>{safeT(t, "profile.current_language", "현재 언어: {language}", { language: languageLabel })}</AppText>

        <View style={{ height: 14 }} />

        <PrimaryButton title={safeT(t, "profile.change_language", "언어 변경", undefined)} onPress={() => setLangModal(true)} variant="ghost" />
      </View>

      <View style={styles.card}>
        <PrimaryButton title={safeT(t, "profile.terms_and_policies", "약관 및 정책", undefined)} onPress={() => setPolicyModal(true)} variant="ghost" />
        <View style={{ height: 10 }} />
        <OutlineDangerButton title={safeT(t, "profile.withdraw", "회원탈퇴", undefined)} onPress={() => setWithdrawModal(true)} />
      </View>

      <PrefsModal
        visible={prefsModal}
        onClose={() => setPrefsModal(false)}
        prefs={prefs}
        setPrefs={setPrefs}
        countryLabel={countryLabel}
        genderLabel={genderLabel}
      />

      <LanguageModal visible={langModal} onClose={() => setLangModal(false)} prefs={prefs} setPrefs={setPrefs} />

      <PolicyModal
        visible={policyModal}
        onClose={() => setPolicyModal(false)}
        onPressTerms={() => openPolicy("terms")}
        onPressPrivacy={() => openPolicy("privacy")}
        onPressOperation={() => openPolicy("operation")}
      />

      <AppModal
        visible={updateModal}
        title={safeT(t, "modal.update.title", "업데이트", undefined)}
        onClose={() => {
          if (updateBusy) return;
          setUpdateModal(false);
        }}
        dismissible={!updateBusy}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton
              title={updateBusy ? safeT(t, "modal.update.applying", "적용 중...", undefined) : safeT(t, "modal.update.apply", "지금 적용", undefined)}
              onPress={doApplyUpdate}
              disabled={updateBusy}
            />
            <PrimaryButton title={safeT(t, "modal.update.later", "나중에", undefined)} onPress={() => setUpdateModal(false)} variant="ghost" disabled={updateBusy} />
          </View>
        }
      >
        <AppText style={styles.p}>{safeT(t, "modal.update.body", "업데이트가 있습니다.", undefined)}</AppText>
      </AppModal>

      <AppModal
        visible={withdrawModal}
        title={safeT(t, "modal.withdraw.title", "회원탈퇴", undefined)}
        onClose={() => setWithdrawModal(false)}
        dismissible={true}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title={safeT(t, "modal.withdraw.confirm", "탈퇴하기", undefined)} onPress={doWithdraw} variant="danger" />
            <PrimaryButton title={safeT(t, "modal.withdraw.cancel", "취소", undefined)} onPress={() => setWithdrawModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.p}>{safeT(t, "modal.withdraw.body", "정말 탈퇴하시겠습니까?", undefined)}</AppText>
      </AppModal>
    </ScrollView>
  );
}

function PrefsModal({
  visible,
  onClose,
  prefs,
  setPrefs,
  countryLabel,
  genderLabel,
}: {
  visible: boolean;
  onClose: () => void;
  prefs: any;
  setPrefs: (p: any) => void;
  countryLabel: string;
  genderLabel: string;
}) {
  const { t, currentLang } = useTranslation();
  const showGlobalModal = useAppStore((s: any) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  useEffect(() => {
    if (!visible) return;
    setLangOpen(false);
    setCountryOpen(false);
    setGenderOpen(false);
  }, [visible]);

  const isoToFlag = useCallback((iso: string) => {
    const cc = String(iso || "").toUpperCase();
    if (cc.length !== 2) return "";
    const A = 0x1f1e6;
    const c1 = cc.charCodeAt(0);
    const c2 = cc.charCodeAt(1);
    if (c1 < 65 || c1 > 90 || c2 < 65 || c2 > 90) return "";
    return String.fromCodePoint(A + (c1 - 65), A + (c2 - 65));
  }, []);

  const normalizeLang = useCallback((v: string) => {
    const code = String(v || "").trim().toLowerCase();
    if (code === "kr") return "ko";
    return code;
  }, []);

  const setLanguage = useCallback((lang: string) => {
    if (typeof setPrefs === "function") setPrefs({ language: lang });
    else showGlobalModal(t("setting.title"), t("setting.language_save_error"));
  }, [setPrefs, showGlobalModal, t]);

  const setCountry = useCallback((iso: string) => {
    if (typeof setPrefs === "function") setPrefs({ country: iso });
    else showGlobalModal(t("setting.title"), t("setting.country_save_error"));
  }, [setPrefs, showGlobalModal, t]);

  const setGender = useCallback((gender: string) => {
    if (typeof setPrefs === "function") setPrefs({ gender });
    else showGlobalModal(t("setting.title"), t("setting.gender_save_error"));
  }, [setPrefs, showGlobalModal, t]);

  const languageOptions = useMemo(() => {
    const ui = String(currentLang || "ko");
    return [
      { key: "ko", label: getLangDisplayLabel("ko", ui) },
      { key: "en", label: getLangDisplayLabel("en", ui) },
      { key: "ja", label: getLangDisplayLabel("ja", ui) },
      { key: "zh", label: getLangDisplayLabel("zh", ui) },
      { key: "es", label: getLangDisplayLabel("es", ui) },
      { key: "de", label: getLangDisplayLabel("de", ui) },
      { key: "fr", label: getLangDisplayLabel("fr", ui) },
      { key: "it", label: getLangDisplayLabel("it", ui) },
      { key: "ru", label: getLangDisplayLabel("ru", ui) },
    ];
  }, [currentLang]);

  const countryOptions = useMemo(() => [
    { key: "KR", name: "Korea" },
    { key: "JP", name: "Japan" },
    { key: "CN", name: "China" },
    { key: "TW", name: "Taiwan" },
    { key: "HK", name: "Hong Kong" },
    { key: "SG", name: "Singapore" },
    { key: "TH", name: "Thailand" },
    { key: "VN", name: "Vietnam" },
    { key: "PH", name: "Philippines" },
    { key: "ID", name: "Indonesia" },
    { key: "MY", name: "Malaysia" },
    { key: "IN", name: "India" },
    { key: "US", name: "United States" },
    { key: "CA", name: "Canada" },
    { key: "GB", name: "United Kingdom" },
    { key: "AU", name: "Australia" },
    { key: "DE", name: "Germany" },
    { key: "FR", name: "France" },
    { key: "RU", name: "Russia" },
    { key: "ES", name: "Spain" },
    { key: "IT", name: "Italy" },
    { key: "BR", name: "Brazil" },
    { key: "MX", name: "Mexico" },
  ], []);

  const genderOptions = useMemo(() => [
    { key: "male", label: t("gender.male") },
    { key: "female", label: t("gender.female") },
  ], [t]);

  const currentLanguageLabel = useMemo(() => {
    const cur = normalizeLang(String(prefs.language || ""));
    const found = languageOptions.find((x) => x.key === cur);
    return found ? found.label : cur || t("common.not_set");
  }, [languageOptions, normalizeLang, prefs.language, t]);

  const currentCountryDisplay = useMemo(() => {
    const cur = String(prefs.country || "").toUpperCase();
    const found = countryOptions.find((x) => x.key === cur);
    const nm = found ? found.name : cur || t("common.not_set");
    const cc = found ? found.key : cur;
    const flag = isoToFlag(cc);
    if (!cc) return nm;
    return `${flag ? flag + " " : ""}${nm} (${cc})`;
  }, [countryOptions, isoToFlag, prefs.country, t]);

  const currentGenderLabel = useMemo(() => {
    const cur = String(prefs.gender || "");
    const found = genderOptions.find((x) => x.key === cur);
    return found ? found.label : cur || t("common.not_set");
  }, [genderOptions, prefs.gender, t]);

  const activeLang = normalizeLang(String(prefs.language || ""));

  return (
    <AppModal
      visible={visible}
      title={t("setting.title")}
      dismissible={true}
      onClose={() => {
        onClose();
        setLangOpen(false);
        setCountryOpen(false);
        setGenderOpen(false);
      }}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title={t("common.close")} onPress={onClose} variant="ghost" />
        </View>
      }
    >
      <AppText style={styles.modalText}>{t("setting.description")}</AppText>

      <AppText style={styles.sectionTitle}>{t("setting.country")}</AppText>
      <Pressable onPress={() => { setCountryOpen((v) => !v); setLangOpen(false); setGenderOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
        <AppText style={styles.dropdownBtnText}>{currentCountryDisplay}</AppText>
        <AppText style={styles.dropdownChevron}>{countryOpen ? "▲" : "▼"}</AppText>
      </Pressable>

      {countryOpen && (
        <View style={styles.dropdownListWrap}>
          <ScrollView style={styles.dropdownScroll} contentContainerStyle={styles.dropdownScrollContent} showsVerticalScrollIndicator>
            {countryOptions.map((opt) => {
              const active = String(prefs.country || "").toUpperCase() === opt.key;
              const flag = isoToFlag(opt.key);
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => { setCountry(opt.key); setCountryOpen(false); }}
                  style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>
                    {flag ? `${flag} ` : ""}{opt.name}
                  </AppText>
                  <View style={styles.countryRight}>
                    <AppText style={[styles.countryCode, active ? styles.countryCodeActive : null]}>({opt.key})</AppText>
                    {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
                  </View>
                </Pressable>
              );
            })}
          </ScrollView>
        </View>
      )}

      <AppText style={styles.sectionTitle}>{t("setting.language")}</AppText>
      <Pressable onPress={() => { setLangOpen((v) => !v); setCountryOpen(false); setGenderOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
        <AppText style={styles.dropdownBtnText}>{currentLanguageLabel}</AppText>
        <AppText style={styles.dropdownChevron}>{langOpen ? "▲" : "▼"}</AppText>
      </Pressable>

      {langOpen && (
        <View style={styles.dropdownListWrap}>
          <ScrollView style={styles.dropdownScroll} contentContainerStyle={styles.dropdownScrollContent} showsVerticalScrollIndicator>
            {languageOptions.map((opt) => {
              const active = activeLang === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => { setLanguage(opt.key); setLangOpen(false); }}
                  style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
                </Pressable>
              );
            })}
          </ScrollView>
        </View>
      )}

      <AppText style={styles.sectionTitle}>{t("setting.gender")}</AppText>
      <Pressable onPress={() => { setGenderOpen((v) => !v); setCountryOpen(false); setLangOpen(false); }} style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}>
        <AppText style={styles.dropdownBtnText}>{currentGenderLabel}</AppText>
        <AppText style={styles.dropdownChevron}>{genderOpen ? "▲" : "▼"}</AppText>
      </Pressable>

      {genderOpen && (
        <View style={styles.dropdownList}>
          {genderOptions.map((opt) => {
            const active = String(prefs.gender || "") === opt.key;
            return (
              <Pressable
                key={opt.key}
                onPress={() => { setGender(opt.key); setGenderOpen(false); }}
                style={({ pressed }) => [styles.dropdownRow, active ? styles.dropdownRowActive : null, pressed ? { opacity: 0.75 } : null]}
              >
                <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                {active && <AppText style={styles.dropdownCheck}>✓</AppText>}
              </Pressable>
            );
          })}
        </View>
      )}

      <AppText style={styles.sectionTitle}>{t("setting.font_size")}</AppText>
      <AppText style={styles.modalText}>{t("setting.font_size_desc", { percent: Math.round(fontScale * 100) })}</AppText>
      <FontSizeSlider value={fontScale} onChange={setFontScale} />
    </AppModal>
  );
}


function LanguageModal({
  visible,
  onClose,
  prefs,
  setPrefs,
}: {
  visible: boolean;
  onClose: () => void;
  prefs: any;
  setPrefs: (p: any) => void;
}) {
  const { t, currentLang } = useTranslation();
  const [language, setLanguage] = useState(prefs.language);

  useEffect(() => {
    if (!visible) return;
    setLanguage(prefs.language);
  }, [visible, prefs.language]);

  const save = () => {
    if (!language) return;
    setPrefs({ language });
    onClose();
  };

  const ui = String(currentLang || "ko");
  const languageOptions = [
    { key: "ko", label: getLangDisplayLabel("ko", ui) },
    { key: "en", label: getLangDisplayLabel("en", ui) },
    { key: "ja", label: getLangDisplayLabel("ja", ui) },
    { key: "zh", label: getLangDisplayLabel("zh", ui) },
    { key: "es", label: getLangDisplayLabel("es", ui) },
    { key: "de", label: getLangDisplayLabel("de", ui) },
    { key: "fr", label: getLangDisplayLabel("fr", ui) },
    { key: "it", label: getLangDisplayLabel("it", ui) },
    { key: "ru", label: getLangDisplayLabel("ru", ui) },
  ];

  return (
    <AppModal
      visible={visible}
      title={safeT(t, "modal.lang.title", "언어 변경", undefined)}
      onClose={onClose}
      dismissible={true}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title={safeT(t, "common.save", "저장", undefined)} onPress={save} disabled={!language} />
        </View>
      }
    >
      <AppText style={styles.p}>{safeT(t, "modal.lang.body", "표시 언어를 선택하세요.", undefined)}</AppText>

      <View style={styles.pickerGroup}>
        <AppText style={styles.pickerTitle}>{safeT(t, "prefs.language_title", "언어", undefined)}</AppText>
        <View style={styles.langGrid}>
          {languageOptions.map((opt) => {
            const active = language === opt.key;
            return (
              <LangChip
                key={opt.key}
                active={active}
                label={opt.label}
                onPress={() => setLanguage(opt.key)}
              />
            );
          })}
        </View>
      </View>
    </AppModal>
  );
}

function PolicyModal({
  visible,
  onClose,
  onPressTerms,
  onPressPrivacy,
  onPressOperation,
}: {
  visible: boolean;
  onClose: () => void;
  onPressTerms: () => void;
  onPressPrivacy: () => void;
  onPressOperation: () => void;
}) {
  const { t } = useTranslation();

  return (
    <AppModal
      visible={visible}
      title={safeT(t, "modal.policy.title", "약관/정책", undefined)}
      onClose={onClose}
      dismissible={true}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title={safeT(t, "common.close", "닫기", undefined)} onPress={onClose} variant="ghost" />
        </View>
      }
    >
      <View style={{ gap: 10 }}>
        <PrimaryButton title={safeT(t, "modal.policy.terms", "이용약관", undefined)} onPress={onPressTerms} variant="ghost" />
        <PrimaryButton title={safeT(t, "modal.policy.privacy", "개인정보처리방침", undefined)} onPress={onPressPrivacy} variant="ghost" />
        <PrimaryButton title={safeT(t, "modal.policy.operation", "운영정책", undefined)} onPress={onPressOperation} variant="ghost" />
      </View>
    </AppModal>
  );
}

function PickChip({ label, active, onPress }: { label: string; active: boolean; onPress: () => void }) {
  return (
    <Pressable onPress={onPress} style={({ pressed }) => [styles.chipBtn, active ? styles.chipOn : styles.chipOff, pressed ? { opacity: 0.8 } : null]}>
      <AppText style={[styles.chipTxt, active ? styles.chipTxtOn : styles.chipTxtOff]}>{label}</AppText>
    </Pressable>
  );
}

function LangChip({ label, active, onPress }: { label: string; active: boolean; onPress: () => void }) {
  return (
    <Pressable
      onPress={onPress}
      style={({ pressed }) => [
        styles.langChipBtn,
        active ? styles.chipOn : styles.chipOff,
        pressed ? { opacity: 0.8 } : null,
      ]}
    >
      <AppText style={[styles.langChipTxt, active ? styles.chipTxtOn : styles.chipTxtOff]} numberOfLines={1}>
        {label}
      </AppText>
    </Pressable>
  );
}

function OutlineDangerButton({ title, onPress }: { title: string; onPress: () => void }) {
  return (
    <Pressable onPress={onPress} style={({ pressed }) => [styles.dangerOutlineBtn, pressed ? styles.dangerOutlineBtnPressed : null]}>
      <AppText style={styles.dangerOutlineTxt}>{title}</AppText>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  wrap: {
    padding: theme.spacing.lg,
    gap: theme.spacing.lg,
  },
  card: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  h1: { fontSize: 17, fontWeight: "700", color: theme.colors.text, marginBottom: 6 },
  p: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  headerTitle: { fontSize: 20, fontWeight: "800", color: theme.colors.text },
  headerTitleContainer: { marginLeft: -10 },
  headerLeftContainer: { paddingLeft: 6 },
  headerRightContainer: { paddingRight: 6 },

  headerBackBtn: { paddingHorizontal: 10, paddingVertical: 6, borderRadius: 10 },
  headerBackTxt: { fontSize: 20, fontWeight: "800", color: theme.colors.text, lineHeight: 20 },

  headerBtn: { paddingHorizontal: 12, paddingVertical: 8 },
  headerBtnText: { fontSize: 22, color: theme.colors.text, fontWeight: "700" },

  headerGearBtn: {
    width: 36,
    height: 36,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    alignItems: "center",
    justifyContent: "center",
    ...theme.shadow.card,
  },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },
  sectionTitle: { fontSize: 14, fontWeight: "700", color: theme.colors.text },

  dropdownBtn: {
    width: "100%",
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownBtnText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownChevron: { fontSize: 12, color: theme.colors.sub, fontWeight: "900" },

  dropdownList: { width: "100%", marginTop: 8, gap: 8 },
  dropdownListWrap: { width: "100%", marginTop: 8, borderRadius: 12, overflow: "hidden" },
  dropdownScroll: { maxHeight: 210 },
  dropdownScrollContent: { gap: 8 },

  dropdownRow: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownRowActive: { borderColor: theme.colors.pinkDeep, backgroundColor: theme.colors.cardSoft },
  dropdownText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownTextActive: { color: theme.colors.pinkDeep },
  dropdownCheck: { fontSize: 14, color: theme.colors.pinkDeep, fontWeight: "900" },

  countryRight: { flexDirection: "row", alignItems: "center", gap: 10 },
  countryCode: { fontSize: 12, color: theme.colors.sub, fontWeight: "800" },
  countryCodeActive: { color: theme.colors.pinkDeep },

  infoBox: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.line,
  },
  infoK: { fontSize: 13, color: theme.colors.sub, fontWeight: "700" },
  infoV: { fontSize: 13, color: theme.colors.text, fontWeight: "700" },

  pickerGroup: { marginTop: 10 },
  pickerTitle: { fontSize: 13, fontWeight: "700", color: theme.colors.text, marginBottom: 8 },
  pickerRow: { flexDirection: "row", gap: 10, flexWrap: "wrap" },
  countryWrap: { flexDirection: "row", flexWrap: "wrap", gap: 10 },

  chipBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    overflow: "hidden",
  },

  chipOn: { backgroundColor: theme.colors.pinkDeep, borderColor: theme.colors.pinkDeep },
  chipOff: { backgroundColor: theme.colors.white, borderColor: theme.colors.line },

  chipTxt: { fontSize: 13, fontWeight: "700" },
  chipTxtOn: { color: theme.colors.white },
  chipTxtOff: { color: theme.colors.text },

  langGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 10,
  },
  langChipBtn: {
    flexBasis: "48%",
    minHeight: 44,
    borderRadius: 14,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  langChipTxt: {
    fontSize: 13,
    fontWeight: "800",
  },

  dangerOutlineBtn: {
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: theme.radius.lg ?? 14,
    borderWidth: 1,
    borderColor: "#ff3b30",
    backgroundColor: "transparent",
    alignItems: "center",
    justifyContent: "center",
  },
  dangerOutlineBtnPressed: { opacity: 0.75 },
  dangerOutlineTxt: { fontSize: 15, fontWeight: "800", color: "#ff3b30" },
});


================================================================================
 FILE: src\screens\_GlobalModalHost.tsx
================================================================================

﻿import React, { useMemo } from "react";
import { Text, View } from "react-native";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { useAppStore } from "../store/useAppStore";
import { theme } from "../config/theme";
import { translations } from "../i18n/translations";

export default function GlobalModalHost() {
  const m = useAppStore((s) => s.globalModal);
  const hide = useAppStore((s) => s.hideGlobalModal);

  const prefsLang = useAppStore((s: any) => s.prefs?.language);

  const currentLang = useMemo(() => {
    const key = String(prefsLang || "ko") as keyof typeof translations;
    return (translations as any)[key] ? key : ("ko" as keyof typeof translations);
  }, [prefsLang]);

  const t = useMemo(() => {
    return (key: string, params?: Record<string, any>): string => {
      const dict = (translations as any)[currentLang] || (translations as any).ko || {};
      let text = String(dict[key] ?? key);

      if (params) {
        Object.keys(params).forEach((k) => {
          text = text.replace(`{${k}}`, String(params[k]));
        });
      }
      return text;
    };
  }, [currentLang]);

  return (
    <AppModal
      visible={m.visible}
      title={m.title}
      dismissible={true}
      onClose={hide}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title={t("common.confirm")} onPress={hide} />
        </View>
      }
    >
      <Text style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>{m.message}</Text>
    </AppModal>
  );
}


================================================================================
 FILE: src\services\ads\AdManager.tsx
================================================================================

﻿// FILE: C:\ranchat\src\services\ads\AdManager.tsx
import React from "react";
import { Platform } from "react-native";
import mobileAds, { BannerAd, BannerAdSize, InterstitialAd, TestIds } from "react-native-google-mobile-ads";

let _initPromise: Promise<boolean> | null = null;
let _adsReady = false;

type ReadyListener = (ready: boolean) => void;
const _readyListeners = new Set<ReadyListener>();

export function isAdsReady() {
  return _adsReady;
}

export function onAdsReady(cb: ReadyListener) {
  _readyListeners.add(cb);

  // 이미 ready면 즉시(비동기) 1회 통지
  if (_adsReady) {
    setTimeout(() => {
      try {
        cb(true);
      } catch {}
    }, 0);
  }

  return () => {
    _readyListeners.delete(cb);
  };
}

function notifyReady(v: boolean) {
  _adsReady = v;
  _readyListeners.forEach((fn) => {
    try {
      fn(v);
    } catch {}
  });
}

export function initAds() {
  if (_initPromise) return _initPromise;

  _initPromise = (async () => {
    try {
      await mobileAds().initialize();
      notifyReady(true);
      return true;
    } catch {
      // initialize 실패해도 앱은 계속 돌아가야 함(너무 빡빡하게 막지 않기)
      notifyReady(false);
      return false;
    }
  })();

  return _initPromise;
}

function getBannerUnitId() {
  const android = String(process.env.EXPO_PUBLIC_AD_UNIT_BANNER_ANDROID ?? "").trim();
  const ios = String(process.env.EXPO_PUBLIC_AD_UNIT_BANNER_IOS ?? "").trim();
  const envId = Platform.OS === "ios" ? ios : android;
  return envId || (Platform.OS === "ios" ? TestIds.BANNER : "ca-app-pub-5144004139813427/1738956911");
}

function getInterstitialUnitId() {
  const android = String(process.env.EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_ANDROID ?? "").trim();
  const ios = String(process.env.EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_IOS ?? "").trim();
  const envId = Platform.OS === "ios" ? ios : android;
  return envId || (Platform.OS === "ios" ? TestIds.INTERSTITIAL : "ca-app-pub-5144004139813427/9729127571");
}

export function createInterstitial() {
  const unitId = getInterstitialUnitId();
  return InterstitialAd.createForAdRequest(unitId, { requestNonPersonalizedAdsOnly: false });
}

export function BannerBar() {
  const unitId = getBannerUnitId();
  return (
    <BannerAd
      unitId={unitId}
      size={BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
      requestOptions={{ requestNonPersonalizedAdsOnly: false }}
    />
  );
}

export default { initAds, createInterstitial, BannerBar, isAdsReady, onAdsReady };


================================================================================
 FILE: src\services\auth\AuthBootstrap.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\auth\AuthBootstrap.ts
import { getOrCreateDeviceKey } from "../device/DeviceKey";
import { bindDeviceHttp } from "./DeviceBind";
import { useAppStore } from "../../store/useAppStore";

export async function bootstrapDeviceBinding(): Promise<void> {
  const deviceKey = await getOrCreateDeviceKey();
  useAppStore.getState().setDeviceKey(deviceKey);

  const { token, userId } = await bindDeviceHttp(deviceKey);
  useAppStore.getState().setAuth({ token, userId, verified: true });
}


================================================================================
 FILE: src\services\auth\DeviceBind.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\auth\DeviceBind.ts
import { Platform } from "react-native";
import { APP_CONFIG } from "../../config/app";

type BindResponse = {
  token: string;
  userId: string;
};

async function postBind(url: string, deviceKey: string): Promise<BindResponse> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      deviceKey,
      platform: Platform.OS,
    }),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    const err: any = new Error(`BIND_HTTP_${res.status}:${txt}`);
    err.status = res.status;
    err.body = txt;
    throw err;
  }

  const data: any = await res.json();
  const token = String(data?.token ?? "");
  const userId = String(data?.userId ?? "");
  if (!token || !userId) throw new Error("BIND_RESPONSE_INVALID");
  return { token, userId };
}

function httpsBaseFromWs(wsUrl: string): string {
  try {
    const u = new URL(wsUrl);
    return `https://${u.host}`;
  } catch {
    return "";
  }
}

function normalizeHttpsBase(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^https:\/\//i.test(s)) return s;
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "https://");
  if (/^wss:\/\//i.test(s)) return s.replace(/^wss:\/\//i, "https://");
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "https://");
  return `https://${s.replace(/^\/+/, "")}`;
}

export async function bindDeviceHttp(deviceKey: string): Promise<BindResponse> {
  const envBase = String(process.env.EXPO_PUBLIC_AUTH_HTTP_BASE_URL ?? "").trim();
  const cfgBase = String(APP_CONFIG.AUTH_HTTP_BASE_URL ?? "").trim();
  const derivedBase = httpsBaseFromWs(String(APP_CONFIG.SIGNALING_URL ?? "").trim());

  const candidates = [envBase || cfgBase, derivedBase]
    .map((v) => normalizeHttpsBase(v))
    .filter((v) => v.length > 0)
    .map((v) => v.replace(/\/$/, ""));

  const bases = Array.from(new Set(candidates));
  if (!bases.length) throw new Error("AUTH_BASE_URL_MISSING");

  let last404 = "";
  let lastErr: any = null;

  for (const base0 of bases) {
    const base = base0.replace(/\/$/, "");
    const baseHasApi = /\/api$/i.test(base);

    const paths = baseHasApi
      ? ["/device/bind", "/bind"]
      : ["/device/bind", "/bind", "/api/device/bind", "/api/bind"];

    for (const p of paths) {
      const url = `${base}${p}`;

      try {
        return await postBind(url, deviceKey);
      } catch (e: any) {
        lastErr = e;

        const status = Number(e?.status);
        if (Number.isFinite(status)) {
          if (status === 404) {
            last404 = String(e?.body ?? "");
            continue;
          }
          throw e;
        }

        continue;
      }
    }
  }

  if (last404) throw new Error(`BIND_HTTP_404:${last404}`);
  throw lastErr ?? new Error("BIND_FAILED");
}


================================================================================
 FILE: src\services\device\DeviceKey.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\device\DeviceKey.ts
import "react-native-get-random-values";
import * as SecureStore from "expo-secure-store";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { v4 as uuidv4 } from "uuid";

const KEY = "ranchat_device_key_v1";

async function getFromFallback(): Promise<string | null> {
  try {
    const v = await AsyncStorage.getItem(KEY);
    return v ? String(v) : null;
  } catch {
    return null;
  }
}

async function setToFallback(v: string): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY, String(v));
  } catch {}
}

export async function getOrCreateDeviceKey(): Promise<string> {
  // 1) SecureStore 우선
  try {
    const existing = await SecureStore.getItemAsync(KEY);
    if (existing && String(existing).trim().length > 0) return String(existing).trim();
  } catch {
    // 무시하고 fallback
  }

  // 2) AsyncStorage fallback
  const fb = await getFromFallback();
  if (fb && fb.trim().length > 0) return fb.trim();

  // 3) 생성 후 저장
  const next = uuidv4();

  try {
    await SecureStore.setItemAsync(KEY, next);
  } catch {
    // SecureStore 실패 시 fallback
    await setToFallback(next);
  }

  return next;
}


================================================================================
 FILE: src\services\purchases\PurchaseManager.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\purchases\PurchaseManager.ts
import Purchases from "react-native-purchases";
import { APP_CONFIG } from "../../config/app";
import { useAppStore } from "../../store/useAppStore";
import { useTranslation } from "../../i18n/LanguageProvider";

let inited = false;

export async function initPurchases() {
  const key = APP_CONFIG.PURCHASES.revenueCatKey;
  if (!key) return;

  if (inited) return;
  inited = true;

  try {
    Purchases.setLogLevel(Purchases.LOG_LEVEL.ERROR);
    await Purchases.configure({ apiKey: key });
    await refreshSubscription();
  } catch {}
}

export async function purchasePremiumByProductId(productId: string) {
  const offerings = await Purchases.getOfferings();
  const current = offerings.current;
  if (!current) throw new Error("No current offering");

  const allPkgs = current.availablePackages ?? [];
  const target = allPkgs.find((p) => p?.product?.identifier === productId);

  if (!target) {
    throw new Error(`Product not found in offering: ${productId}`);
  }

  await Purchases.purchasePackage(target);
}

export async function refreshSubscription() {
  const entitlementId = APP_CONFIG.PURCHASES.entitlementId;
  try {
    const customerInfo = await Purchases.getCustomerInfo();
    const active = Boolean(customerInfo?.entitlements?.active?.[entitlementId]);
    useAppStore.getState().setSub({
      isPremium: active,
      entitlementId: entitlementId,
      lastCheckedAt: Date.now(),
    });
  } catch {}
}

export async function purchasePremium() {
  const { t } = useTranslation();
  const entitlementId = APP_CONFIG.PURCHASES.entitlementId;
  try {
    const offerings = await Purchases.getOfferings();
    const current = offerings.current;
    if (!current || current.availablePackages.length === 0) {
      useAppStore.getState().showGlobalModal(t("subscription.title"), t("subscription.no_offering"));
      return;
    }

    const pick =
      current.availablePackages.find((p) => p.packageType === Purchases.PACKAGE_TYPE.WEEKLY) ||
      current.availablePackages.find((p) => p.packageType === Purchases.PACKAGE_TYPE.MONTHLY) ||
      current.availablePackages.find((p) => p.packageType === Purchases.PACKAGE_TYPE.SIX_MONTH) ||
      current.availablePackages[0];

    await Purchases.purchasePackage(pick);

    const customerInfo = await Purchases.getCustomerInfo();
    const active = Boolean(customerInfo?.entitlements?.active?.[entitlementId]);
    useAppStore.getState().setSub({
      isPremium: active,
      entitlementId: entitlementId,
      lastCheckedAt: Date.now(),
    });
  } catch (e: any) {
    const { t } = useTranslation();
    if (e?.userCancelled) return;
    useAppStore.getState().showGlobalModal(t("subscription.title"), t("subscription.payment_failed"));
  }
}

export async function openManageSubscriptions() {
  const { t } = useTranslation();
  try {
    // @ts-ignore
    await Purchases.showManageSubscriptions();
  } catch {
    useAppStore.getState().showGlobalModal(t("subscription.manage"), t("subscription.manage_failed"));
  }
}

================================================================================
 FILE: src\services\signal\SignalClient.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\signal\SignalClient.ts
import { Platform } from "react-native";
import { getOrCreateDeviceKey } from "../device/DeviceKey";

export type SignalMessage =
  | { type: "queued" }
  | { type: "match"; roomId: string; isCaller: boolean }
  | { type: "offer"; sdp: any }
  | { type: "answer"; sdp: any }
  | { type: "ice"; candidate: any }
  | { type: "end" }
  | { type: "peer_cam"; enabled: boolean }
  | { type: "signal"; roomId: string; data: any }
  | { type: "error"; message?: string };

type Cb = {
  onOpen: () => void; // ✅ "registered" 이후에 호출되도록 유지(등록 전 enqueue -> not_registered 루프 방지)
  onClose: () => void;
  onMessage: (m: SignalMessage) => void;
};

type ServerMessage =
  | { type: "hello" }
  | { type: "registered"; sessionId: string }
  | { type: "enqueued"; sessionId: string; queueSize?: number }
  | { type: "dequeued"; sessionId: string; queueSize?: number }
  | { type: "matched"; roomId: string; initiator: boolean; sessionId?: string; peerSessionId?: string }
  | { type: "signal"; roomId: string; fromSessionId?: string; data: any }
  | { type: "peer_left"; roomId?: string; sessionId?: string; peerSessionId?: string }
  | { type: "left"; roomId?: string; sessionId?: string }
  | { type: "left_ok"; roomId?: string | null; sessionId?: string } // ✅ 서버가 떠난 사람에게 주는 ack(무시)
  | { type: "error"; reason?: string; message?: string };

export class SignalClient {
  private ws: WebSocket | null = null;
  private cb: Cb;

  private baseUrl: string = "";
  private token: string = "";
  private sessionId: string = "";

  private registered = false;
  private openNotified = false;
  private closeNotified = false;

  private pending: any[] = [];

  // ✅ reconnect/backoff
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private reconnectAttempt = 0;
  private manualClose = false;

  private socketSeq = 0;
  private currentSocketId = 0;

  // ✅ 큐 유지(재연결 후 자동 enqueue 용)
  private wantEnqueue = false;
  private lastEnqueuePayload: { country: string; gender: string; platform: string } | null = null;

  constructor(cb: Cb) {
    this.cb = cb;
  }

  async connect(baseUrl: string, token: string | null) {
    // ✅ 기존 reconnect 예약이 있으면 취소
    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
    this.reconnectTimer = null;

    // ✅ 기존 ws 정리(중복 이벤트로 상태 꼬임 방지)
    try {
      this.ws?.close();
    } catch {}
    this.ws = null;

    this.baseUrl = String(baseUrl || "").trim();
    this.manualClose = false;

    const deviceKey = await getOrCreateDeviceKey();
    this.sessionId = String(deviceKey || "").trim();
    this.token = String(token || "").trim();

    this.registered = false;
    this.openNotified = false;
    this.closeNotified = false;
    this.pending = [];

    this.wantEnqueue = false;
    this.lastEnqueuePayload = null;

    this.reconnectAttempt = 0;

    this.openSocket();
  }

  private openSocket() {
    if (!this.baseUrl) {
      this.cb.onMessage({ type: "error", message: "MISSING_SIGNALING_URL" });
      return;
    }

    const socketId = ++this.socketSeq;
    this.currentSocketId = socketId;

    // ✅ 이전 ws 정리
    try {
      this.ws?.close();
    } catch {}
    this.ws = null;

    this.registered = false;
    this.closeNotified = false;

    const ws = new WebSocket(this.baseUrl);
    this.ws = ws;

    const closeOrErrorOnce = () => {
      if (this.currentSocketId !== socketId) return; // stale
      if (this.closeNotified) return;
      this.closeNotified = true;

      // ✅ 연결 끊기면 등록 상태만 초기화(통화/매칭 종료는 CallScreen에서 판단)
      this.registered = false;

      // ✅ ws 참조 제거
      try {
        this.ws?.close();
      } catch {}
      this.ws = null;

      // ✅ 수동 close가 아니면 자동 재연결(backoff)
      if (!this.manualClose) {
        this.scheduleReconnect();
        return;
      }

      // ✅ 수동 close면 기존 동작 유지(필요 시 UI 정리)
      this.cb.onClose();
    };

    ws.onopen = () => {
      if (this.currentSocketId !== socketId) return; // stale

      // 서버 요구: register(token+sessionId) 먼저
      if (!this.token || !this.sessionId) {
        this.cb.onMessage({ type: "error", message: "REGISTER_REQUIRES_TOKEN_AND_SESSIONID" });
        try {
          ws.close();
        } catch {}
        return;
      }

      // ✅ 여기서 onOpen 호출하지 않음(등록 확인 전 enqueue -> not_registered 루프 원인)
      this.sendRaw({ type: "register", token: this.token, sessionId: this.sessionId });
    };

    ws.onclose = () => {
      closeOrErrorOnce();
    };

    ws.onerror = () => {
      closeOrErrorOnce();
    };

    ws.onmessage = (ev: any) => {
      if (this.currentSocketId !== socketId) return; // stale

      try {
        const msg = JSON.parse(String(ev?.data ?? "{}")) as ServerMessage;

        if (msg?.type === "registered") {
          this.registered = true;
          this.reconnectAttempt = 0;

          if (!this.openNotified) {
            this.openNotified = true;
            this.cb.onOpen();
          }

          // ✅ 재연결 시에도 통화/대기 로직이 꼬이지 않도록:
          // 1) pending flush
          const q = this.pending.slice();
          this.pending = [];
          q.forEach((x) => this.sendRaw(x));

          // 2) 큐 유지가 필요한 경우(대기 중 끊김) 자동 enqueue
          if (this.wantEnqueue && this.lastEnqueuePayload) {
            this.sendRaw({ type: "enqueue", ...this.lastEnqueuePayload });
          }

          return;
        }

        if (msg?.type === "enqueued") {
          this.cb.onMessage({ type: "queued" });
          return;
        }

        if (msg?.type === "matched") {
          // ✅ 매칭되면 더 이상 큐 유지/자동 enqueue 하지 않음
          this.wantEnqueue = false;
          this.lastEnqueuePayload = null;

          this.cb.onMessage({ type: "match", roomId: msg.roomId, isCaller: !!msg.initiator });
          return;
        }

        // ✅ 떠난 사람에게 오는 ack는 무시(상대 종료로 오해하지 않기)
        if (msg?.type === "left_ok") {
          return;
        }

        if (msg?.type === "peer_left" || msg?.type === "left") {
          this.cb.onMessage({ type: "end" });
          return;
        }

        if (msg?.type === "signal") {
          const d: any = msg.data;
          const t = String(d?.type ?? d?.kind ?? "").toLowerCase();

          if (t === "offer") {
            this.cb.onMessage({ type: "offer", sdp: d });
            return;
          }
          if (t === "answer") {
            this.cb.onMessage({ type: "answer", sdp: d });
            return;
          }
          if (t === "ice") {
            const cand = d?.candidate ?? d;
            this.cb.onMessage({ type: "ice", candidate: cand });
            return;
          }
          if (t === "end" || t === "leave") {
            this.cb.onMessage({ type: "end" });
            return;
          }

          // ✅ 상대 카메라 ON/OFF 상태(선택적으로 사용 가능)
          if (t === "cam_state") {
            const enabled = Boolean(d?.enabled ?? d?.on ?? d?.camOn ?? d?.videoEnabled ?? d?.videoOn);
            this.cb.onMessage({ type: "peer_cam", enabled });
            return;
          }

          this.cb.onMessage({ type: "signal", roomId: msg.roomId, data: d });
          return;
        }

        if (msg?.type === "error") {
          const m = String(msg.message || msg.reason || "UNKNOWN_ERROR");
          this.cb.onMessage({ type: "error", message: m });
          return;
        }
      } catch {
        this.cb.onMessage({ type: "error", message: "INVALID_MESSAGE" });
      }
    };
  }

  private scheduleReconnect() {
    if (this.manualClose) return;

    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
    this.reconnectTimer = null;

    // backoff: 500ms * 2^n (cap 10s) + jitter(0~250ms)
    const base = 500;
    const cap = 10_000;
    const pow = Math.min(10, Math.max(0, this.reconnectAttempt));
    const backoff = Math.min(cap, base * Math.pow(2, pow));
    const jitter = Math.floor(Math.random() * 250);
    const delay = backoff + jitter;

    this.reconnectAttempt += 1;

    this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null;
      if (this.manualClose) return;

      // ✅ 다시 소켓 열기
      this.openSocket();
    }, delay);
  }

  enqueue(country: string, gender: string) {
    // ✅ 재연결 후 자동으로 다시 enqueue되게 유지
    this.wantEnqueue = true;
    this.lastEnqueuePayload = { country, gender, platform: Platform.OS };

    // ✅ 서버가 country/gender를 무시해도 문제 없음(추가 필드 허용)
    // ✅ registered 전이면 등록 후 자동 enqueue로 처리(중복 enqueue 방지)
    if (!this.registered) return;

    this.sendRaw({ type: "enqueue", ...this.lastEnqueuePayload });
  }

  // CallScreen.tsx 호환
  sendOffer(roomId: string, sdp: any) {
    this.relay(roomId, sdp);
  }

  sendAnswer(roomId: string, sdp: any) {
    this.relay(roomId, sdp);
  }

  sendIce(roomId: string, candidate: any) {
    this.relay(roomId, { type: "ice", candidate });
  }

  // ✅ 내 카메라 ON/OFF 상태를 상대에게 알림(서버 최상위 타입 추가 없이 signal로 전송)
  sendCamState(roomId: string, enabled: boolean) {
    this.relay(roomId, { type: "cam_state", enabled: !!enabled });
  }

  relay(roomId: string, data: any) {
    this.send({ type: "signal", roomId, data });
  }

  leaveQueue() {
    // ✅ 재연결 후 자동 enqueue 하지 않도록 해제
    this.wantEnqueue = false;
    this.lastEnqueuePayload = null;

    this.send({ type: "dequeue" });
  }

  // CallScreen.tsx에서 인자로 호출하므로 optional 처리
  leaveRoom(roomId?: string) {
    // ✅ 룸을 떠나면 큐 유지 플래그도 해제
    this.wantEnqueue = false;
    this.lastEnqueuePayload = null;

    // 서버는 roomId 없이도 처리하지만, 있어도 무방
    this.send({ type: "leave", roomId: roomId || undefined });
  }

  close() {
    // ✅ 수동 종료: 재연결 금지
    this.manualClose = true;

    if (this.reconnectTimer) clearTimeout(this.reconnectTimer);
    this.reconnectTimer = null;

    try {
      this.ws?.close();
    } catch {}
    this.ws = null;

    this.registered = false;
    this.openNotified = false;
    this.closeNotified = false;
    this.pending = [];

    this.wantEnqueue = false;
    this.lastEnqueuePayload = null;

    this.reconnectAttempt = 0;
  }

  private send(obj: any) {
    // ✅ registered 전이면 큐잉(등록 확인 전 enqueue로 not_registered 나는 것 방지)
    if (!this.registered && obj?.type !== "register") {
      if (this.pending.length < 100) this.pending.push(obj);
      return;
    }

    // ✅ ws가 잠깐 끊긴 상태면(재연결 중) pending으로 보관
    if (!this.ws || (this.ws as any).readyState !== 1) {
      if (obj?.type !== "register" && this.pending.length < 100) this.pending.push(obj);
      return;
    }

    this.sendRaw(obj);
  }

  private sendRaw(obj: any) {
    try {
      this.ws?.send(JSON.stringify(obj));
    } catch {
      // ✅ 전송 실패(끊김)면 pending으로 보관(재연결 후 flush)
      if (obj?.type !== "register" && this.pending.length < 100) this.pending.push(obj);
      try {
        // 재연결 예약
        if (!this.manualClose) this.scheduleReconnect();
      } catch {}
    }
  }
}


================================================================================
 FILE: src\services\webrtc\WebRTCSession.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\webrtc\WebRTCSession.ts
import { RTCPeerConnection, RTCIceCandidate, RTCSessionDescription, mediaDevices, MediaStream } from "react-native-webrtc";
import { PermissionsAndroid, Platform } from "react-native";
import { APP_CONFIG } from "../../config/app";
// @ts-ignore
import InCallManager from "react-native-incall-manager";

type Callbacks = {
  onLocalStream?: (s: MediaStream) => void;
  onRemoteStream?: (s: MediaStream) => void;
  onIceCandidate?: (c: any) => void;
  onConnectionState?: (s: string) => void;

  // ✅ CallScreen.tsx가 넘기는 콜백(없어서 TS 에러였음)
  onOffer?: (sdp: any) => void;
  onAnswer?: (sdp: any) => void;
};

const VIDEO_W = 720;
const VIDEO_H = 1280;
const VIDEO_FPS = 24;

// 모바일 체감 기준(끊김/딜레이 줄이기용 상한)
// 720p 24fps에 과하지 않은 범위로 제한
const VIDEO_MAX_BITRATE = 1_200_000; // 1.2Mbps
const AUDIO_MAX_BITRATE = 64_000; // 64kbps (옵션)

function preferH264InSdp(sdp: string) {
  try {
    const lines = String(sdp || "").split("\r\n");
    const mVideo = lines.findIndex((l) => l.startsWith("m=video "));
    if (mVideo < 0) return sdp;

    const h264Pts = new Set<string>();
    for (const l of lines) {
      const m = l.match(/^a=rtpmap:(\d+)\s+H264\/90000/i);
      if (m?.[1]) h264Pts.add(m[1]);
    }
    if (h264Pts.size === 0) return sdp;

    const parts = lines[mVideo].split(" ");
    if (parts.length <= 3) return sdp;

    const head = parts.slice(0, 3);
    const pts = parts.slice(3);

    const preferred = pts.filter((p) => h264Pts.has(p));
    const others = pts.filter((p) => !h264Pts.has(p));

    lines[mVideo] = [...head, ...preferred, ...others].join(" ");
    return lines.join("\r\n");
  } catch {
    return sdp;
  }
}

type IcePathInfo = {
  selectedPairId?: string;
  localCandidateType?: string;
  remoteCandidateType?: string;
  localProtocol?: string;
  remoteProtocol?: string;
  localAddress?: string;
  localPort?: number;
  remoteAddress?: string;
  remotePort?: number;
  currentRoundTripTimeMs?: number;
  availableOutgoingBitrate?: number;
  bytesSent?: number;
  bytesReceived?: number;
};

function forEachStat(report: any, fn: (s: any) => void) {
  if (!report) return;

  if (typeof report.forEach === "function") {
    report.forEach((v: any) => fn(v));
    return;
  }

  if (Array.isArray(report)) {
    report.forEach((v) => fn(v));
    return;
  }

  if (typeof report === "object") {
    Object.values(report).forEach((v) => fn(v));
  }
}

export class WebRTCSession {
  private pc: RTCPeerConnection;
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;
  private cb: Callbacks;
  private inCallStarted: boolean = false;

  constructor(cb: Callbacks) {
    this.cb = cb;

    const turn = APP_CONFIG.TURN;

    // ✅ 2번 반영: STUN을 TURN과 분리 (srflx 후보 확보)
    const stunUrls = (APP_CONFIG as any)?.ICE?.stunUrls ?? [];
    const stunServer =
      Array.isArray(stunUrls) && stunUrls.length > 0
        ? { urls: stunUrls }
        : { urls: ["stun:stun.l.google.com:19302", "stun:stun1.l.google.com:19302"] };

    // ✅ 3번 반영: 기본은 TURN TCP 후보 제외(딜레이 큰 TCP 릴레이 회피)
    const turnUrls = [`turn:${turn.host}:${turn.port}?transport=udp`];
    if ((turn as any).tcpEnabled === true) {
      turnUrls.push(`turn:${turn.host}:${turn.port}?transport=tcp`);
    }

    const iceServers = [
      stunServer,
      {
        urls: turnUrls,
        username: turn.username,
        credential: turn.password,
      },
    ];

    this.pc = new RTCPeerConnection(
      {
        iceServers,
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        // 연결 시 초반 후보 수집/연결 체감 조금 개선되는 경우가 있어 소량만
        iceCandidatePoolSize: 2,
      } as any
    );

    const pcAny: any = this.pc;

    pcAny.onicecandidate = (e: any) => {
      if (e?.candidate) this.cb.onIceCandidate?.(e.candidate);
    };

    pcAny.onconnectionstatechange = () => {
      this.cb.onConnectionState?.(pcAny.connectionState);
    };

    pcAny.ontrack = (e: any) => {
      const stream = (e?.streams && e.streams[0]) || null;
      if (stream) {
        this.remoteStream = stream;
        this.cb.onRemoteStream?.(stream);
      }
    };
  }

  // ✅ 1번 반영: 연결 경로( relay/srflx/host ) 확인용
  async getIcePathInfo(): Promise<IcePathInfo> {
    try {
      const pcAny: any = this.pc as any;
      if (typeof pcAny.getStats !== "function") return {};

      const report = await pcAny.getStats();
      const stats: any[] = [];
      forEachStat(report, (s) => stats.push(s));

      const byId = new Map<string, any>();
      for (const s of stats) {
        if (s && typeof s.id === "string") byId.set(s.id, s);
      }

      // 1) transport에서 selectedCandidatePairId 우선 탐색
      let selectedPairId: string | undefined = undefined;
      for (const s of stats) {
        if (s?.type === "transport" && typeof s.selectedCandidatePairId === "string") {
          selectedPairId = s.selectedCandidatePairId;
          break;
        }
      }

      // 2) 없으면 candidate-pair 중 selected/nominated 찾아서 선택
      let pair: any = selectedPairId ? byId.get(selectedPairId) : null;
      if (!pair) {
        const candidates = stats.filter((s) => s?.type === "candidate-pair");
        pair =
          candidates.find((p) => p?.selected === true) ||
          candidates.find((p) => p?.nominated === true) ||
          null;

        if (pair?.id && typeof pair.id === "string") selectedPairId = pair.id;
      }

      if (!pair) return { selectedPairId };

      const localId = pair.localCandidateId;
      const remoteId = pair.remoteCandidateId;

      const local = typeof localId === "string" ? byId.get(localId) : null;
      const remote = typeof remoteId === "string" ? byId.get(remoteId) : null;

      const info: IcePathInfo = {
        selectedPairId,
        currentRoundTripTimeMs: Number.isFinite(pair.currentRoundTripTime)
          ? Math.round(pair.currentRoundTripTime * 1000)
          : undefined,
        availableOutgoingBitrate: Number.isFinite(pair.availableOutgoingBitrate) ? pair.availableOutgoingBitrate : undefined,
        bytesSent: Number.isFinite(pair.bytesSent) ? pair.bytesSent : undefined,
        bytesReceived: Number.isFinite(pair.bytesReceived) ? pair.bytesReceived : undefined,
      };

      if (local) {
        info.localCandidateType = typeof local.candidateType === "string" ? local.candidateType : undefined;
        info.localProtocol = typeof local.protocol === "string" ? local.protocol : undefined;
        info.localAddress = typeof local.address === "string" ? local.address : typeof local.ip === "string" ? local.ip : undefined;
        info.localPort = Number.isFinite(local.port) ? local.port : undefined;
      }

      if (remote) {
        info.remoteCandidateType = typeof remote.candidateType === "string" ? remote.candidateType : undefined;
        info.remoteProtocol = typeof remote.protocol === "string" ? remote.protocol : undefined;
        info.remoteAddress = typeof remote.address === "string" ? remote.address : typeof remote.ip === "string" ? remote.ip : undefined;
        info.remotePort = Number.isFinite(remote.port) ? remote.port : undefined;
      }

      return info;
    } catch {
      return {};
    }
  }

  private startSpeakerphone() {
    try {
      if (this.inCallStarted) return;
      this.inCallStarted = true;

      const IC: any = InCallManager as any;

      IC.start?.({ media: "video" });
      IC.setKeepScreenOn?.(true);

      // 스피커폰 강제
      IC.setForceSpeakerphoneOn?.(true);
      IC.setSpeakerphoneOn?.(true);
    } catch {}
  }

  private stopSpeakerphone() {
    try {
      if (!this.inCallStarted) return;
      this.inCallStarted = false;

      const IC: any = InCallManager as any;

      IC.setKeepScreenOn?.(false);
      IC.stop?.();
    } catch {}
  }

  async ensurePermissions() {
    if (Platform.OS !== "android") return;
    const cam = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.CAMERA);
    const mic = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
    if (cam !== "granted" || mic !== "granted") throw new Error("PERMISSION_DENIED");
  }

  private async tuneSenders() {
    try {
      const senders: any[] = (this.pc as any).getSenders?.() ?? [];
      for (const sender of senders) {
        const kind = sender?.track?.kind;

        if (kind === "video" && typeof sender.getParameters === "function" && typeof sender.setParameters === "function") {
          const params = sender.getParameters() || {};
          if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];

          params.encodings[0].maxBitrate = VIDEO_MAX_BITRATE;
          params.encodings[0].maxFramerate = VIDEO_FPS;
          params.degradationPreference = "balanced";

          try {
            await sender.setParameters(params);
          } catch {}
        }

        if (kind === "audio" && typeof sender.getParameters === "function" && typeof sender.setParameters === "function") {
          const params = sender.getParameters() || {};
          if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];

          params.encodings[0].maxBitrate = AUDIO_MAX_BITRATE;

          try {
            await sender.setParameters(params);
          } catch {}
        }
      }
    } catch {}
  }

  async startLocal() {
    await this.ensurePermissions();

    // ✅ 스피커폰 ON
    this.startSpeakerphone();

    // 720p/24fps(과하지 않게) + 실패 시 한 단계 다운 폴백
    let stream: any = null;

    try {
      stream = await mediaDevices.getUserMedia({
        audio: true,
        video: {
          facingMode: "user",
          frameRate: { ideal: VIDEO_FPS, max: VIDEO_FPS },
          width: { ideal: VIDEO_W, max: VIDEO_W },
          height: { ideal: VIDEO_H, max: VIDEO_H },
        },
      } as any);
    } catch {
      stream = await mediaDevices.getUserMedia({
        audio: true,
        video: {
          facingMode: "user",
          frameRate: { ideal: 20, max: 20 },
          width: { ideal: 640, max: 640 },
          height: { ideal: 960, max: 960 },
        },
      } as any);
    }

    this.localStream = stream as any;
    (stream as any).getTracks().forEach((t: any) => (this.pc as any).addTrack(t, stream));

    await this.tuneSenders();

    this.cb.onLocalStream?.(stream as any);
  }

  async createOffer() {
    const offer = await (this.pc as any).createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });

    if (offer?.sdp) {
      // ✅ 5번 반영: H264 우선 정렬
      offer.sdp = preferH264InSdp(offer.sdp);
    }

    await (this.pc as any).setLocalDescription(offer);
    return offer;
  }

  async acceptOfferAndCreateAnswer(offer: any) {
    await (this.pc as any).setRemoteDescription(new RTCSessionDescription(offer));
    const ans = await (this.pc as any).createAnswer();

    if (ans?.sdp) {
      // ✅ 5번 반영: H264 우선 정렬
      ans.sdp = preferH264InSdp(ans.sdp);
    }

    await (this.pc as any).setLocalDescription(ans);
    return ans;
  }

  async acceptAnswer(answer: any) {
    await (this.pc as any).setRemoteDescription(new RTCSessionDescription(answer));
  }

  async addCandidate(candidate: any) {
    try {
      await (this.pc as any).addIceCandidate(new RTCIceCandidate(candidate));
    } catch {}
  }

  // ✅ CallScreen.tsx 호환 메서드들(없어서 TS 에러였음)
  async start({ isCaller }: { isCaller: boolean }) {
    await this.startLocal();

    if (isCaller) {
      const offer = await this.createOffer();
      this.cb.onOffer?.(offer);
    }
  }

  async handleRemoteOffer(offer: any) {
    const ans = await this.acceptOfferAndCreateAnswer(offer);
    this.cb.onAnswer?.(ans);
    return ans;
  }

  async handleRemoteAnswer(answer: any) {
    await this.acceptAnswer(answer);
  }

  async handleRemoteIce(candidate: any) {
    await this.addCandidate(candidate);
  }

  setLocalVideoEnabled(on: boolean) {
    const v = (this.localStream as any)?.getVideoTracks?.() ?? [];
    v.forEach((t: any) => (t.enabled = on));
  }

  setLocalAudioEnabled(on: boolean) {
    const a = (this.localStream as any)?.getAudioTracks?.() ?? [];
    a.forEach((t: any) => (t.enabled = on));
  }

  stop() {
    this.stopSpeakerphone();

    try {
      (this.localStream as any)?.getTracks?.()?.forEach((t: any) => t.stop?.());
    } catch {}
    try {
      (this.pc as any).close?.();
    } catch {}
    this.localStream = null;
    this.remoteStream = null;
  }
}


================================================================================
 FILE: src\store\useAppStore.ts
================================================================================

﻿//C:\ranchat\src\store\useAppStore.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import type { Gender, Language } from "../config/app";

type Prefs = {
  language: Language | null;
  country: string | null;
  gender: Gender | null;
};

type Sub = {
  isPremium: boolean;
  entitlementId: string | null;
  lastCheckedAt: number | null;
};

type Auth = {
  verified: boolean;
  token: string | null;
  userId: string | null;
  deviceKey: string | null;
};

type GlobalModal = {
  visible: boolean;
  title: string;
  message: string;
};

type Ui = {
  fontScale: number; // 0.85~1.25 권장
};

type Store = {
  hasHydrated: boolean;
  authNonce: number;

  prefs: Prefs;
  sub: Sub;
  auth: Auth;

  ui: Ui;

  globalModal: GlobalModal;

  setHasHydrated: (v: boolean) => void;
  bumpAuthNonce: () => void;

  setPrefs: (p: Partial<Prefs>) => void;

  setPremium: (v: boolean) => void;
  setSub: (p: Partial<Sub>) => void;

  setDeviceKey: (k: string) => void;
  setAuth: (a: Partial<Auth>) => void;

  setFontScale: (v: number) => void;

  logoutAndWipe: () => void;

  showGlobalModal: (title: string, message: string) => void;
  hideGlobalModal: () => void;
};

export const useAppStore = create<Store>()(
  persist(
    (set, get) => ({
      hasHydrated: false,
      authNonce: 0,

      prefs: { language: null, country: null, gender: null },
      sub: { isPremium: false, entitlementId: null, lastCheckedAt: null },
      auth: { verified: false, token: null, userId: null, deviceKey: null },

      ui: { fontScale: 1 },

      globalModal: { visible: false, title: "", message: "" },

      setHasHydrated: (v) => set({ hasHydrated: v }),
      bumpAuthNonce: () => set({ authNonce: get().authNonce + 1 }),

      setPrefs: (p) => set({ prefs: { ...get().prefs, ...p } }),

      setPremium: (v) => set({ sub: { ...get().sub, isPremium: v } }),
      setSub: (p) => set({ sub: { ...get().sub, ...p } }),

      setDeviceKey: (k) => set({ auth: { ...get().auth, deviceKey: k } }),
      setAuth: (a) => set({ auth: { ...get().auth, ...a } }),

      setFontScale: (v) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        const clamped = Math.min(1.25, Math.max(0.85, n));
        set({ ui: { ...get().ui, fontScale: Number(clamped.toFixed(2)) } });
      },

      logoutAndWipe: () => {
        set({
          auth: {
            ...get().auth,
            verified: false,
            token: null,
            userId: null,
          },
        });
        get().bumpAuthNonce();
      },

      showGlobalModal: (title, message) => set({ globalModal: { visible: true, title, message } }),
      hideGlobalModal: () => set({ globalModal: { visible: false, title: "", message: "" } }),
    }),
    {
      name: "ranchat_store_v1",
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (s) => ({ prefs: s.prefs, sub: s.sub, auth: s.auth, ui: s.ui }),
      onRehydrateStorage: () => (state) => {
        state?.setHasHydrated(true);
      },
    }
  )
);


================================================================================
 FILE: src\utils\storage.ts
================================================================================

﻿import AsyncStorage from "@react-native-async-storage/async-storage";

export const storage = {
  get: async <T>(key: string): Promise<T | null> => {
    const v = await AsyncStorage.getItem(key);
    if (!v) return null;
    return JSON.parse(v) as T;
  },
  set: async (key: string, value: any) => {
    await AsyncStorage.setItem(key, JSON.stringify(value));
  },
  del: async (key: string) => {
    await AsyncStorage.removeItem(key);
  },
  clear: async () => {
    await AsyncStorage.clear();
  },
};
