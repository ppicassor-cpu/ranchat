==================================================
   N_BBANG PROJECT SOURCE CODE
   Exported at: 2026-02-17 00:41:35
==================================================


================================================================================
 FILE: app.json
================================================================================

{
  "expo": {
    "name": "ranchat",
    "slug": "ranchat",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "url": "https://u.expo.dev/f6fabec8-bc52-4dc4-9088-0acb4d47a258",
      "checkAutomatically": "ON_LOAD",
      "fallbackToCacheTimeout": 0
    },
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "versionCode": 1,
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.ranchat",
      "permissions": [
        "CAMERA",
        "RECORD_AUDIO",
        "MODIFY_AUDIO_SETTINGS",
        "INTERNET",
        "ACCESS_NETWORK_STATE",
        "BLUETOOTH",
        "BLUETOOTH_CONNECT"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "./plugins/withAndroidReleaseSigning",
      "./plugins/withAdIdPermission",
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-3940256099942544~3347511713",
          "iosAppId": "ca-app-pub-3940256099942544~1458002511"
        }
      ],
      "expo-secure-store",
      "expo-font"
    ],    
    "extra": {
      "react-native-google-mobile-ads": {
        "androidAppId": "ca-app-pub-3940256099942544~3347511713",
        "iosAppId": "ca-app-pub-3940256099942544~1458002511"
      },
      "eas": {
        "projectId": "f6fabec8-bc52-4dc4-9088-0acb4d47a258"
      },
      "update": {
        "channel": "production",
        "branch": "main"
      }
    }
  }
}


================================================================================
 FILE: App.tsx
================================================================================

﻿//App.tsx
import React from "react";
import { SafeAreaProvider } from "react-native-safe-area-context";
import RootNavigator from "./src/navigation/RootNavigator";

export default function App() {
  return (
    <SafeAreaProvider>
      <RootNavigator />
    </SafeAreaProvider>
  );
}


================================================================================
 FILE: firebase.json
================================================================================

{
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}


================================================================================
 FILE: index.ts
================================================================================

import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


================================================================================
 FILE: package.json
================================================================================

{
  "name": "ranchat",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-navigation/bottom-tabs": "^7.13.0",
    "@react-navigation/native": "^7.1.28",
    "@react-navigation/native-stack": "^7.12.0",
    "event-target-shim": "^6.0.2",
    "expo": "~54.0.33",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.11",
    "expo-location": "~19.0.8",
    "expo-secure-store": "~15.0.8",
    "expo-status-bar": "~3.0.9",
    "expo-system-ui": "~6.0.9",
    "react": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-get-random-values": "~1.11.0",
    "react-native-google-mobile-ads": "^16.0.3",
    "react-native-incall-manager": "^4.2.1",
    "react-native-purchases": "^9.9.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-webrtc": "^124.0.7",
    "react-native-worklets": "0.5.1",
    "uuid": "^13.0.0",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "typescript": "~5.9.2"
  },
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": [
          "react-native-webrtc"
        ]
      }
    }
  },
  "private": true
}


================================================================================
 FILE: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  },
  "exclude": [
    "server-auth",
    "android",
    "ios",
    "node_modules"
  ]
}


================================================================================
 FILE: plugins\withAdIdPermission.js
================================================================================

﻿const { withAndroidManifest } = require("@expo/config-plugins");

const AD_ID_PERMISSION = "com.google.android.gms.permission.AD_ID";

function ensureAdIdPermission(androidManifest) {
  const manifest = androidManifest.manifest;

  if (!manifest["uses-permission"]) manifest["uses-permission"] = [];
  const list = manifest["uses-permission"];

  const exists = list.some((p) => p?.$?.["android:name"] === AD_ID_PERMISSION);
  if (!exists) {
    list.push({ $: { "android:name": AD_ID_PERMISSION } });
  }

  return androidManifest;
}

module.exports = function withAdIdPermission(config) {
  return withAndroidManifest(config, (config) => {
    config.modResults = ensureAdIdPermission(config.modResults);
    return config;
  });
};


================================================================================
 FILE: plugins\withAndroidReleaseSigning.js
================================================================================

﻿const { withAppBuildGradle, withGradleProperties } = require("@expo/config-plugins");
const fs = require("fs");
const path = require("path");

function readPropertiesFile(filePath) {
  const out = {};
  const raw = fs.readFileSync(filePath, "utf8");
  const lines = raw.split(/\r?\n/);

  for (const line of lines) {
    const s = String(line || "").trim();
    if (!s || s.startsWith("#")) continue;

    const idx = s.indexOf("=");
    if (idx < 0) continue;

    const key = s.slice(0, idx).trim();
    const value = s.slice(idx + 1).trim();
    if (!key) continue;

    out[key] = value;
  }
  return out;
}

function upsertGradleProp(list, key, value) {
  const idx = list.findIndex((x) => x.type === "property" && x.key === key);
  if (idx >= 0) {
    list[idx].value = value;
    return;
  }
  list.push({ type: "property", key, value });
}

function findBlockRange(text, name, from = 0) {
  const re = new RegExp(`\\b${name}\\b\\s*\\{`, "m");
  re.lastIndex = from;
  const m = re.exec(text);
  if (!m) return null;

  const keywordStart = m.index;
  const braceStart = text.indexOf("{", keywordStart);
  if (braceStart < 0) return null;

  let depth = 0;
  for (let i = braceStart; i < text.length; i++) {
    const ch = text[i];
    if (ch === "{") depth += 1;
    else if (ch === "}") {
      depth -= 1;
      if (depth === 0) return { keywordStart, braceStart, braceEnd: i };
    }
  }
  return null;
}

function ensureReleaseSigningConfig(gradle) {
  const android = findBlockRange(gradle, "android");
  if (!android) return gradle;

  let androidBody = gradle.slice(android.braceStart + 1, android.braceEnd);

  // 1) signingConfigs 블록 없으면 생성
  let signingConfigs = findBlockRange(androidBody, "signingConfigs");
  if (!signingConfigs) {
    const buildTypes = findBlockRange(androidBody, "buildTypes");
    const insertAt = buildTypes ? buildTypes.keywordStart : androidBody.length;

    const insert =
      "\n\n    signingConfigs {\n" +
      "    }\n";

    androidBody = androidBody.slice(0, insertAt) + insert + androidBody.slice(insertAt);
  }

  // 2) buildTypes 블록 없으면 생성
  let buildTypes = findBlockRange(androidBody, "buildTypes");
  if (!buildTypes) {
    const insert =
      "\n\n    buildTypes {\n" +
      "        release {\n" +
      "        }\n" +
      "        debug {\n" +
      "        }\n" +
      "    }\n";
    androidBody = androidBody.replace(/\s*$/, "") + insert;
  }

  // 3) signingConfigs 안에 release 없으면 추가 (기본값 제거: findProperty만 사용)
  signingConfigs = findBlockRange(androidBody, "signingConfigs");
  if (!signingConfigs) return gradle;

  let scBody = androidBody.slice(signingConfigs.braceStart + 1, signingConfigs.braceEnd);
  const hasReleaseConfig = /\brelease\s*\{/.test(scBody);

  if (!hasReleaseConfig) {
    const releaseBlock =
      "\n\n        release {\n" +
      "            def storeFilePath = findProperty('RN_STORE_FILE')\n" +
      "            storeFile file(storeFilePath)\n" +
      "            storePassword findProperty('RN_STORE_PASSWORD')\n" +
      "            keyAlias findProperty('RN_KEY_ALIAS')\n" +
      "            keyPassword findProperty('RN_KEY_PASSWORD')\n" +
      "        }\n";

    scBody = scBody.replace(/\s*$/, "") + releaseBlock + "\n";
    androidBody =
      androidBody.slice(0, signingConfigs.braceStart + 1) +
      scBody +
      androidBody.slice(signingConfigs.braceEnd);
  }

  // 4) buildTypes.release에 signingConfig signingConfigs.release 강제 + debug 제거
  buildTypes = findBlockRange(androidBody, "buildTypes");
  if (!buildTypes) return gradle;

  let btBody = androidBody.slice(buildTypes.braceStart + 1, buildTypes.braceEnd);

  let releaseBt = findBlockRange(btBody, "release");
  if (!releaseBt) {
    const addRelease =
      "\n\n        release {\n" +
      "            signingConfig signingConfigs.release\n" +
      "        }\n";
    btBody = btBody.replace(/\s*$/, "") + addRelease + "\n";
  } else {
    let releaseBody = btBody.slice(releaseBt.braceStart + 1, releaseBt.braceEnd);

    // signingConfig 라인 전부 제거 후 release로 1개만 삽입
    releaseBody = releaseBody.replace(/^\s*signingConfig\s+signingConfigs\.\w+\s*$/gm, "");
    releaseBody = releaseBody.replace(/\n{3,}/g, "\n\n");
    releaseBody = releaseBody.replace(/^\s*\n/, "\n");

    const hasReleaseSigning = /^\s*signingConfig\s+signingConfigs\.release\s*$/m.test(releaseBody);
    if (!hasReleaseSigning) {
      releaseBody = "\n            signingConfig signingConfigs.release\n" + releaseBody;
    }

    btBody =
      btBody.slice(0, releaseBt.braceStart + 1) +
      releaseBody +
      btBody.slice(releaseBt.braceEnd);
  }

  androidBody =
    androidBody.slice(0, buildTypes.braceStart + 1) +
    btBody +
    androidBody.slice(buildTypes.braceEnd);

  // android 블록 재조립
  return gradle.slice(0, android.braceStart + 1) + androidBody + gradle.slice(android.braceEnd);
}

module.exports = function withAndroidReleaseSigning(config) {
  // ✅ 목표 1) 루트 keystore.properties -> android/gradle.properties에 매번 주입 (prebuild에도 유지)
  config = withGradleProperties(config, (config) => {
    const projectRoot = config.modRequest.projectRoot;
    const srcPath = path.join(projectRoot, "keystore.properties");

    if (!fs.existsSync(srcPath)) {
      throw new Error(`Missing ${srcPath} (RN_STORE_* values source).`);
    }

    const props = readPropertiesFile(srcPath);
    const required = ["RN_STORE_FILE", "RN_STORE_PASSWORD", "RN_KEY_ALIAS", "RN_KEY_PASSWORD"];

    for (const k of required) {
      const v = String(props[k] ?? "").trim();
      if (!v) throw new Error(`Missing "${k}" in ${srcPath}`);
    }

    const list = config.modResults;

    upsertGradleProp(list, "RN_STORE_FILE", props.RN_STORE_FILE);
    upsertGradleProp(list, "RN_STORE_PASSWORD", props.RN_STORE_PASSWORD);
    upsertGradleProp(list, "RN_KEY_ALIAS", props.RN_KEY_ALIAS);
    upsertGradleProp(list, "RN_KEY_PASSWORD", props.RN_KEY_PASSWORD);

    config.modResults = list;
    return config;
  });

  // ✅ 목표 2) app/build.gradle의 release 빌드 타입에 release signingConfig 강제 (debug 서명 방지)
  return withAppBuildGradle(config, (config) => {
    const src = config.modResults.contents;
    config.modResults.contents = ensureReleaseSigningConfig(src);
    return config;
  });
};


================================================================================
 FILE: src\components\AppModal.tsx
================================================================================

﻿//C:\ranchat\src\components\AppModal.tsx
import React from "react";
import { Modal, Pressable, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";

type Props = {
  visible: boolean;
  title?: string;
  children?: React.ReactNode;
  onClose?: () => void;
  footer?: React.ReactNode;
  dismissible?: boolean;
};

export default function AppModal({ visible, title, children, onClose, footer, dismissible = true }: Props) {
  return (
    <Modal transparent visible={visible} animationType="fade" statusBarTranslucent>
      <View style={styles.backdrop}>
        <Pressable
          style={styles.backdropPress}
          onPress={() => {
            if (dismissible) onClose?.();
          }}
        />
        <View style={styles.card}>
          {title ? <AppText style={styles.title}>{title}</AppText> : null}
          <View style={styles.body}>{children}</View>
          {footer ? <View style={styles.footer}>{footer}</View> : null}
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  backdrop: {
    flex: 1,
    backgroundColor: theme.colors.dim,
    alignItems: "center",
    justifyContent: "center",
    padding: theme.spacing.lg,
  },
  backdropPress: {
    ...StyleSheet.absoluteFillObject,
  },
  card: {
    width: "100%",
    maxWidth: 520,
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  title: {
    width: "100%",
    textAlign: "center",
    fontSize: 18,
    fontWeight: "700",
    color: theme.colors.text,
    marginBottom: theme.spacing.sm,
  },
  body: {
    width: "100%",
    alignItems: "center",
    gap: theme.spacing.sm,
  },
  footer: {
    width: "100%",
    marginTop: theme.spacing.md,
  },
});


================================================================================
 FILE: src\components\AppText.tsx
================================================================================

//C:\ranchat\src\components\AppText.tsx
import React, { useMemo } from "react";
import { Text, TextProps, TextStyle, StyleProp } from "react-native";
import { useAppStore } from "../store/useAppStore";

function scaleOneStyle(s: TextStyle, scale: number): TextStyle {
  const out: TextStyle = { ...s };

  if (typeof out.fontSize === "number") out.fontSize = Math.round(out.fontSize * scale);
  if (typeof out.lineHeight === "number") out.lineHeight = Math.round(out.lineHeight * scale);

  // fontWeight 700 초과 방지
  if (typeof out.fontWeight === "string") {
    const n = Number(out.fontWeight);
    if (!Number.isNaN(n) && n > 700) out.fontWeight = "700";
  }

  return out;
}

function scaleStyle(style: StyleProp<TextStyle>, scale: number): StyleProp<TextStyle> {
  if (!style) return style;

  if (Array.isArray(style)) {
    return style.map((x) => scaleStyle(x as any, scale)) as any;
  }

  if (typeof style === "object") {
    return scaleOneStyle(style as TextStyle, scale);
  }

  return style;
}

type Props = TextProps & {
  children?: React.ReactNode;
};

export default function AppText(props: Props) {
  const scale = useAppStore((s) => s.ui.fontScale);

  const scaledStyle = useMemo(() => scaleStyle(props.style as any, scale), [props.style, scale]);

  return (
    <Text
      {...props}
      allowFontScaling={false}
      maxFontSizeMultiplier={1}
      style={scaledStyle}
    >
      {props.children}
    </Text>
  );
}


================================================================================
 FILE: src\components\FontSizeSlider.tsx
================================================================================

//C:\ranchat\src\components\FontSizeSlider.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import { LayoutChangeEvent, PanResponder, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";

type Props = {
  value: number;          // 예: 1.0
  min?: number;           // 기본 0.85
  max?: number;           // 기본 1.25
  onChange: (v: number) => void;
};

export default function FontSizeSlider({ value, min = 0.85, max = 1.25, onChange }: Props) {
  const [w, setW] = useState(1);
  const draggingRef = useRef(false);
  const wrapRef = useRef<View>(null);

  const clamp = (v: number) => Math.min(max, Math.max(min, v));

  const pct = useMemo(() => {
    const p = (value - min) / (max - min);
    return Math.min(1, Math.max(0, p));
  }, [value, min, max]);

  const knobLeft = useMemo(() => Math.max(0, Math.round(pct * (w - 18))), [pct, w]);

  const setFromX = (x: number) => {
    const denom = Math.max(1, w - 18);
    const p = Math.min(1, Math.max(0, x / denom));
    const v = min + p * (max - min);
    onChange(Number(clamp(v).toFixed(2)));
  };

  const pan = useMemo(
    () =>
      PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponder: () => true,
        onPanResponderGrant: (evt) => {
          draggingRef.current = true;
          const x = evt.nativeEvent.locationX - 9;
          setFromX(x);
        },
        onPanResponderMove: (evt, g) => {
          // g.moveX는 화면 절대좌표라서 locationX 기반으로 처리하기가 더 안정적임
          const x = evt.nativeEvent.locationX - 9;
          setFromX(x);
        },
        onPanResponderRelease: () => {
          draggingRef.current = false;
        },
      }),
    [w, min, max]
  );

  // move 이벤트는 PanResponder에서 locationX로 처리, onTouchMove는 보조로만 유지
  const onTouchMove = (evt: any) => {
    if (!draggingRef.current) return;
    const x = evt?.nativeEvent?.locationX - 9;
    if (typeof x === "number") setFromX(x);
  };

  const onLayout = (e: LayoutChangeEvent) => {
    const next = Math.max(1, Math.floor(e.nativeEvent.layout.width));
    setW(next);

    // Release에서 onLayout 폭이 0~1로 잡히는 케이스 보정
    if (next <= 1) {
      requestAnimationFrame(() => {
        wrapRef.current?.measure((_x, _y, width) => {
          const measured = Math.max(1, Math.floor(width));
          if (measured > 1) setW(measured);
        });
      });
    }
  };

  useEffect(() => {
    if (!Number.isFinite(value)) onChange(1);
  }, [value, onChange]);

  return (
    <View ref={wrapRef} style={styles.wrap} onLayout={onLayout} {...pan.panHandlers} onTouchMove={onTouchMove}>
      <View style={styles.track} />
      <View style={[styles.fill, { width: Math.max(0, knobLeft + 9) }]} />
      <View style={[styles.knob, { left: knobLeft }]} />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    height: 28,
    justifyContent: "center",
    width: "100%",
    alignSelf: "stretch",
  },
  track: {
    height: 8,
    borderRadius: 999,
    backgroundColor: theme.colors.line,
  },
  fill: {
    position: "absolute",
    left: 0,
    height: 8,
    borderRadius: 999,
    backgroundColor: theme.colors.pinkDeep,
  },
  knob: {
    position: "absolute",
    width: 18,
    height: 18,
    borderRadius: 999,
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.line,
  },
});


================================================================================
 FILE: src\components\PrimaryButton.tsx
================================================================================

﻿//C:\ranchat\src\components\PrimaryButton.tsx
import React from "react";
import { Pressable, StyleSheet, ViewStyle } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";

type Props = {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  variant?: "primary" | "ghost" | "danger";
  style?: ViewStyle;
};

export default function PrimaryButton({ title, onPress, disabled, variant = "primary", style }: Props) {
  const bg =
    variant === "primary" ? theme.colors.pinkDeep : variant === "danger" ? theme.colors.danger : "transparent";
  const border = variant === "ghost" ? theme.colors.line : "transparent";
  const text = variant === "ghost" ? theme.colors.text : theme.colors.white;

  return (
    <Pressable
      onPress={onPress}
      disabled={disabled}
      style={[
        styles.btn,
        { backgroundColor: bg, borderColor: border, opacity: disabled ? 0.5 : 1 },
        style,
      ]}
    >
      <AppText style={[styles.txt, { color: text }]}>{title}</AppText>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  btn: {
    height: 50,
    borderRadius: theme.radius.lg,
    alignItems: "center",
    justifyContent: "center",
    borderWidth: 1,
  },
  txt: {
    fontSize: 16,
    fontWeight: "700",
  },
});


================================================================================
 FILE: src\components\Spinner.tsx
================================================================================

﻿import React from "react";
import { ActivityIndicator, StyleSheet, View } from "react-native";
import { theme } from "../config/theme";
import AppText from "./AppText";

export default function Spinner() {
  return (
    <View style={styles.wrap}>
      <AppText style={styles.text}>매칭 연결중</AppText>
      <ActivityIndicator size={48} />
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    paddingVertical: theme.spacing.sm,
    alignItems: "center",
    justifyContent: "center",
    gap: 10,
  },
  text: {
    color: "rgba(112, 112, 112, 0.85)",
    fontSize: 18,
    fontWeight: "400",
    textAlign: "center",
  },
});


================================================================================
 FILE: src\config\app.ts
================================================================================

﻿// FILE: C:\ranchat\src\config\app.ts
import Constants from "expo-constants";

const env = (Constants.expoConfig?.extra ?? {}) as Record<string, any>;

const read = (k: string, fallback = ""): string => {
  const v = (process.env as any)?.[k];
  if (typeof v === "string" && v.trim().length > 0) return v.trim();
  const e = env?.[k];
  if (typeof e === "string" && e.trim().length > 0) return e.trim();
  return fallback;
};

const readNumber = (k: string, fallback: number): number => {
  const raw = read(k, String(fallback));
  const n = Number(raw);
  return Number.isFinite(n) ? n : fallback;
};

const readPort = (k: string, fallback: number): number => {
  const n = readNumber(k, fallback);
  if (!Number.isFinite(n) || n < 1 || n > 65535) return fallback;
  return Math.trunc(n);
};

function normalizeWssUrl(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^wss:\/\//i.test(s)) return s;
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "wss://");
  if (/^https:\/\//i.test(s)) return s.replace(/^https:\/\//i, "wss://");
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "wss://");
  return `wss://${s.replace(/^\/+/, "")}`;
}

function normalizeHttpsBase(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^https:\/\//i.test(s)) return s;
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "https://");
  if (/^wss:\/\//i.test(s)) return s.replace(/^wss:\/\//i, "https://");
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "https://");
  return `https://${s.replace(/^\/+/, "")}`;
}

const freeRemoteVideoSeconds = readNumber("EXPO_PUBLIC_FREE_REMOTE_VIDEO_SECONDS", 3000);

export const APP_CONFIG = {
  SIGNALING_URL: normalizeWssUrl(read("EXPO_PUBLIC_SIGNALING_URL", "wss://comspc.duckdns.org")),

  TURN: {
    host: read("EXPO_PUBLIC_TURN_HOST", "152.67.213.225"),
    port: readPort("EXPO_PUBLIC_TURN_PORT", 3478),
    username: read("EXPO_PUBLIC_TURN_USERNAME", "testuser"),
    password: read("EXPO_PUBLIC_TURN_PASSWORD", "testpass"),
  },

  // ✅ 4000(다른 프로젝트) 안 건드리고, 기본값을 3001로 고정
  AUTH_HTTP_BASE_URL: normalizeHttpsBase(read("EXPO_PUBLIC_AUTH_HTTP_BASE_URL", "https://comspc.duckdns.org")),

  ADS: {
    bannerAndroid: read("EXPO_PUBLIC_AD_UNIT_BANNER_ANDROID", ""),
    interstitialAndroid: read("EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_ANDROID", ""),
  },

  PURCHASES: {
    revenueCatKey: read("EXPO_PUBLIC_REVENUECAT_PUBLIC_SDK_KEY", ""),
    entitlementId: read("EXPO_PUBLIC_REVENUECAT_ENTITLEMENT_ID", "premium"),
  },

  POLICY: {
    privacyUrl: read("EXPO_PUBLIC_PRIVACY_POLICY_URL", ""),
  },

  MATCH_TIMEOUT_MS: readNumber("EXPO_PUBLIC_MATCH_TIMEOUT_MS", 20000),
  FREE_CALL_LIMIT_MS: readNumber("EXPO_PUBLIC_FREE_CALL_LIMIT_MS", freeRemoteVideoSeconds * 1000),

  FREE_LIMITS: {
    remoteVideoSeconds: freeRemoteVideoSeconds,
  },

  PLANS: {
    weekly: { label: "1주", price: 4900 },
    monthly: { label: "1개월", price: 14900 },
    halfYear: { label: "6개월", price: 44900 },
  },
} as const;

export type Gender = "male" | "female";
export type Language = "ko" | "en";

export const COUNTRY_OPTIONS: { code: string; label: string; dial?: string }[] = [
  { code: "KR", label: "대한민국", dial: "+82" },
  { code: "JP", label: "일본", dial: "+81" },
  { code: "US", label: "미국", dial: "+1" },
  { code: "CA", label: "캐나다", dial: "+1" },
  { code: "GB", label: "영국", dial: "+44" },
  { code: "AU", label: "호주", dial: "+61" },
  { code: "DE", label: "독일", dial: "+49" },
  { code: "FR", label: "프랑스", dial: "+33" },
  { code: "SG", label: "싱가포르", dial: "+65" },
  { code: "TH", label: "태국", dial: "+66" },
];


================================================================================
 FILE: src\config\theme.ts
================================================================================

﻿export const theme = {
  colors: {
    bg: "#FFF5FA",
    card: "#FFFFFF",
    cardSoft: "#FFE8F2",
    line: "#F3C7D9",
    text: "#2B2230",
    sub: "#6F5E6A",
    danger: "#D93A5A",
    ok: "#2E7D5B",
    pink: "#F2A8C6",
    pinkDeep: "#E983AD",
    black: "#111111",
    white: "#FFFFFF",
    dim: "rgba(0,0,0,0.45)",
  },
  radius: {
    xl: 22,
    lg: 16,
    md: 12,
  },
  spacing: {
    xs: 8,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 28,
  },
  shadow: {
    card: {
      shadowColor: "#000",
      shadowOpacity: 0.08,
      shadowRadius: 10,
      shadowOffset: { width: 0, height: 6 },
      elevation: 3,
    },
  },
};

================================================================================
 FILE: src\navigation\MainStack.tsx
================================================================================

﻿//C:\ranchat\src\navigation\MainStack.tsx
import React from "react";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import HomeScreen from "../screens/HomeScreen";
import CallScreen from "../screens/CallScreen";
import ProfileScreen from "../screens/ProfileScreen";
import { theme } from "../config/theme";

export type MainStackParamList = {
  Home: undefined;
  Call: undefined;
  Profile: undefined;
};

const Stack = createNativeStackNavigator<MainStackParamList>();

export default function MainStack() {
  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: { backgroundColor: theme.colors.bg },
        headerShadowVisible: false,
        headerTitleStyle: { fontWeight: "700" },
        contentStyle: { backgroundColor: theme.colors.bg },
      }}
    >
      <Stack.Screen name="Home" component={HomeScreen} options={{ title: "RanChat" }} />
      <Stack.Screen name="Call" component={CallScreen} options={{ title: "매칭" }} />
      <Stack.Screen name="Profile" component={ProfileScreen} options={{ title: "프로필" }} />
    </Stack.Navigator>
  );
}


================================================================================
 FILE: src\navigation\RootNavigator.tsx
================================================================================

﻿// C:\ranchat\src\navigation\RootNavigator.tsx
import React, { useEffect } from "react";
import { NavigationContainer } from "@react-navigation/native";

import MainStack from "./MainStack";
import { useAppStore } from "../store/useAppStore";

import { initAds } from "../services/ads/AdManager";
import { initPurchases } from "../services/purchases/PurchaseManager";
import { bootstrapDeviceBinding } from "../services/auth/AuthBootstrap";
import GlobalModalHost from "../screens/_GlobalModalHost";

function toErrMsg(e: unknown) {
  if (typeof e === "string") return e;
  if (e && typeof e === "object" && "message" in e) return String((e as any).message || "UNKNOWN_ERROR");
  return "UNKNOWN_ERROR";
}

export default function RootNavigator() {
  const hasHydrated = useAppStore((s) => s.hasHydrated);
  const authNonce = useAppStore((s) => s.authNonce);

  const setAuth = useAppStore((s) => s.setAuth);
  const showGlobalModal = useAppStore((s) => s.showGlobalModal);

  useEffect(() => {
    initAds();
    initPurchases();
  }, []);

  useEffect(() => {
    if (!hasHydrated) return;

    (async () => {
      try {
        await bootstrapDeviceBinding();
      } catch (e) {
        setAuth({ verified: true, token: null, userId: null });
        showGlobalModal("인증", toErrMsg(e));
      }
    })();
  }, [hasHydrated, authNonce, setAuth, showGlobalModal]);

  return (
    <NavigationContainer>
      <MainStack />
      <GlobalModalHost />
    </NavigationContainer>
  );
}


================================================================================
 FILE: src\screens\CallScreen.tsx
================================================================================

﻿// FILE: C:\ranchat\src\screens\CallScreen.tsx
import React, { useEffect, useRef, useState, useCallback, useMemo } from "react";
import { StyleSheet, View, Pressable, Dimensions, ScrollView } from "react-native";
import { RTCView } from "react-native-webrtc";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { Ionicons } from "@expo/vector-icons";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import Spinner from "../components/Spinner";
import { theme } from "../config/theme";
import { APP_CONFIG } from "../config/app";
import { bootstrapDeviceBinding } from "../services/auth/AuthBootstrap";
import { useAppStore } from "../store/useAppStore";
import { SignalClient, SignalMessage } from "../services/signal/SignalClient";
import { WebRTCSession } from "../services/webrtc/WebRTCSession";
import { BannerBar, createInterstitial } from "../services/ads/AdManager";
import { AdEventType, NativeAd, NativeAdView, NativeAsset, NativeAssetType, NativeMediaView, NativeMediaAspectRatio, TestIds } from "react-native-google-mobile-ads";
import { purchasePremium, refreshSubscription } from "../services/purchases/PurchaseManager";
import type { MainStackParamList } from "../navigation/MainStack";
import AppText from "../components/AppText";
import FontSizeSlider from "../components/FontSizeSlider";
import { useSafeAreaInsets } from "react-native-safe-area-context";

type Props = NativeStackScreenProps<MainStackParamList, "Call">;

type Phase = "connecting" | "queued" | "matched" | "calling" | "ended";

// ✅ APP_CONFIG 타입에 값이 없어도 TS 에러 없이 동작하도록 fallback 상수로 사용
const MATCH_TIMEOUT_MS = (() => {
  const v = Number((APP_CONFIG as any)?.MATCH_TIMEOUT_MS);
  return Number.isFinite(v) ? v : 20000;
})();

// ✅ 무료 30초 제한을 3000초로 변경(사실상 비활성 수준)
const FREE_CALL_LIMIT_MS = (() => {
  const direct = Number((APP_CONFIG as any)?.FREE_CALL_LIMIT_MS);
  if (Number.isFinite(direct)) return direct;

  const sec = Number((APP_CONFIG as any)?.FREE_LIMITS?.remoteVideoSeconds);
  if (Number.isFinite(sec)) return sec * 1000;

  return 3000 * 1000;
})();

// ✅ 전면광고 재노출 쿨다운(3분)
const INTERSTITIAL_COOLDOWN_MS = 3 * 60 * 1000;

function countryCodeToFlagEmoji(code: string) {
  const cc = String(code || "").trim().toUpperCase();
  if (cc.length !== 2) return "";
  const A = 0x1f1e6;
  const c1 = cc.charCodeAt(0) - 65;
  const c2 = cc.charCodeAt(1) - 65;
  if (c1 < 0 || c1 > 25 || c2 < 0 || c2 > 25) return "";
  return String.fromCodePoint(A + c1, A + c2);
}

function normalizeLanguageLabel(v: string) {
  const s = String(v || "").trim();
  const lower = s.toLowerCase();
  if (!s) return "";
  if (lower === "ko" || lower === "kor" || lower === "korean") return "한국어";
  if (lower === "en" || lower === "eng" || lower === "english") return "English";
  if (lower === "ja" || lower === "jpn" || lower === "japanese") return "日本語";
  if (lower === "zh" || lower === "chi" || lower === "chinese") return "中文";
  return s;
}

const NATIVE_UNIT_ID = (process.env.EXPO_PUBLIC_AD_UNIT_NATIVE_ANDROID ?? "").trim() || TestIds.NATIVE;

function QueueNativeAd256x144() {
  const [nativeAd, setNativeAd] = useState<NativeAd | null>(null);
  const adRef = useRef<NativeAd | null>(null);

  useEffect(() => {
    let alive = true;

    NativeAd.createForAdRequest(NATIVE_UNIT_ID, { aspectRatio: NativeMediaAspectRatio.LANDSCAPE })
      .then((ad) => {
        if (!alive) {
          try {
            ad.destroy();
          } catch {}
          return;
        }
        adRef.current = ad;
        setNativeAd(ad);
      })
      .catch(() => {});

    return () => {
      alive = false;
      try {
        adRef.current?.destroy();
      } catch {}
      adRef.current = null;
    };
  }, []);

  if (!nativeAd) return null;

  return (
    <NativeAdView nativeAd={nativeAd} style={[styles.nativeAd256, { width: 360, height: 202 }]}>
      <View style={styles.nativeAdInner}>
        <NativeMediaView style={styles.nativeAdMedia} resizeMode="cover" />
        <View style={styles.nativeAdFooter}>
          <NativeAsset assetType={NativeAssetType.HEADLINE}>
            <AppText style={styles.nativeAdHeadline}>{nativeAd.headline}</AppText>
          </NativeAsset>
          <AppText style={styles.nativeAdTag}>광고</AppText>
        </View>
      </View>
    </NativeAdView>
  );
}

export default function CallScreen({ navigation }: Props) {

  const insets = useSafeAreaInsets();

  const prefs = useAppStore((s) => s.prefs);
  const token = useAppStore((s) => s.auth.token);
  const isPremium = useAppStore((s) => s.sub.isPremium);
  const showGlobalModal = useAppStore((s: any) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [phase, setPhase] = useState<Phase>("connecting");
  const [roomId, setRoomId] = useState<string | null>(null);
  const [isCaller, setIsCaller] = useState(false);

  const [localStreamURL, setLocalStreamURL] = useState<string | null>(null);
  const [remoteStreamURL, setRemoteStreamURL] = useState<string | null>(null);

  const [remoteCamOn, setRemoteCamOn] = useState(true);

  const [myCamOn, setMyCamOn] = useState(true);
  const [mySoundOn, setMySoundOn] = useState(true);

  const [limitModal, setLimitModal] = useState(false);
  const [remoteVideoAllowed, setRemoteVideoAllowed] = useState(true);

  const [upgradeModal, setUpgradeModal] = useState(false);
  const [noMatchModal, setNoMatchModal] = useState(false);

  const [reMatchText, setReMatchText] = useState<string>("");

  const [prefsModal, setPrefsModal] = useState(false);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  const wsRef = useRef<SignalClient | null>(null);
  const rtcRef = useRef<WebRTCSession | null>(null);
  const limitTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const matchInterstitialRef = useRef<ReturnType<typeof createInterstitial> | null>(null);
  const lastInterstitialAtRef = useRef<number>(0);

  const enqueuedRef = useRef(false);
  const queueRunningRef = useRef(false);

  const rebindOnceRef = useRef(false);

  const noMatchTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const requeueTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const canStart = useRef(false);

  const adAllowedRef = useRef(false);
  const interstitialTokenRef = useRef(0);
  const interstitialCleanupRef = useRef<(() => void) | null>(null);
  const interstitialTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [peerInfo, setPeerInfo] = useState<any>(null);

  const peerCountryRaw = useMemo(() => String((peerInfo as any)?.country ?? ""), [peerInfo]);
  const peerLangRaw = useMemo(() => String((peerInfo as any)?.language ?? (peerInfo as any)?.lang ?? ""), [peerInfo]);
  const peerFlag = useMemo(() => {
    const direct = String((peerInfo as any)?.flag ?? "").trim();
    return direct || countryCodeToFlagEmoji(peerCountryRaw);
  }, [peerInfo, peerCountryRaw]);
  const peerLangLabel = useMemo(() => {
    const direct = String((peerInfo as any)?.languageLabel ?? "").trim();
    return direct || normalizeLanguageLabel(peerLangRaw);
  }, [peerInfo, peerLangRaw]);
  const peerGenderRaw = useMemo(() => String((peerInfo as any)?.gender ?? ""), [peerInfo]);
  const peerGenderLabel = useMemo(() => {
    const direct = String((peerInfo as any)?.genderLabel ?? "").trim();
    if (direct) return direct;
    const g = String(peerGenderRaw || "").trim().toLowerCase();
    if (!g) return "";
    if (g === "male" || g === "m") return "남성";
    if (g === "female" || g === "f") return "여성";
    return peerGenderRaw;
  }, [peerInfo, peerGenderRaw]);

  const peerInfoText = useMemo(() => {
    const parts: string[] = [];
    if (peerLangLabel) parts.push(peerLangLabel);

    const countryPart = (peerFlag ? `${peerFlag} ` : "") + (peerCountryRaw || "");
    if (countryPart.trim()) parts.push(countryPart.trim());

    if (peerGenderLabel) parts.push(peerGenderLabel);

    return parts.join(" · ");
  }, [peerLangLabel, peerFlag, peerCountryRaw, peerGenderLabel]);

  const myCountryRaw = useMemo(() => String((prefs as any)?.country ?? ""), [prefs]);
  const myLangRaw = useMemo(() => String((prefs as any)?.language ?? (prefs as any)?.lang ?? ""), [prefs]);
  const myFlag = useMemo(() => countryCodeToFlagEmoji(myCountryRaw), [myCountryRaw]);
  const myLangLabel = useMemo(() => normalizeLanguageLabel(myLangRaw), [myLangRaw]);
  const myGenderRaw = useMemo(() => String((prefs as any)?.gender ?? ""), [prefs]);
  const myGenderLabel = useMemo(() => {
    const g = String(myGenderRaw || "").trim().toLowerCase();
    if (!g) return "";
    if (g === "male" || g === "m") return "남성";
    if (g === "female" || g === "f") return "여성";
    return myGenderRaw;
  }, [myGenderRaw]);


  useEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  useEffect(() => {
    canStart.current = Boolean(String(prefs.country || "").length > 0 && String(prefs.gender || "").length > 0);
  }, [prefs.country, prefs.gender]);

  const startNoMatchTimer = () => {
    if (isPremium) return;
    if (noMatchTimerRef.current) clearTimeout(noMatchTimerRef.current);

    noMatchTimerRef.current = setTimeout(() => {
      queueRunningRef.current = false;
      enqueuedRef.current = false;

      try {
        wsRef.current?.leaveQueue();
      } catch {}
      try {
        wsRef.current?.close();
      } catch {}
      wsRef.current = null;

      setNoMatchModal(true);
    }, MATCH_TIMEOUT_MS);
  };

  const clearNoMatchTimer = () => {
    if (noMatchTimerRef.current) clearTimeout(noMatchTimerRef.current);
    noMatchTimerRef.current = null;
  };

  const stopAll = () => {
    adAllowedRef.current = false;
    interstitialTokenRef.current += 1;

    if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
    interstitialTimerRef.current = null;

    try {
      interstitialCleanupRef.current?.();
    } catch {}
    interstitialCleanupRef.current = null;

    matchInterstitialRef.current = null;

    if (requeueTimerRef.current) clearTimeout(requeueTimerRef.current);
    requeueTimerRef.current = null;

    clearNoMatchTimer();

    queueRunningRef.current = false;
    enqueuedRef.current = false;

    try {
      wsRef.current?.leaveQueue();
    } catch {}
    try {
      wsRef.current?.close();
    } catch {}
    wsRef.current = null;

    try {
      rtcRef.current?.stop();
    } catch {}
    rtcRef.current = null;

    if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
    limitTimerRef.current = null;

    setLocalStreamURL(null);
    setRemoteStreamURL(null);
    setRoomId(null);
    setPeerInfo(null);
    setRemoteVideoAllowed(true);
    setRemoteCamOn(true);
    setLimitModal(false);
    setPhase("ended");
  };

  const goHome = useCallback(() => {
    const nav: any = navigation as any;

    let root: any = nav;
    try {
      while (root?.getParent?.()) root = root.getParent();
    } catch {}

    try {
      const st = root?.getState?.();
      const first = st?.routes?.[0]?.name;
      if (first) {
        root.reset({ index: 0, routes: [{ name: first }] });
        return;
      }
    } catch {}

    try {
      root?.popToTop?.();
    } catch {}
  }, [navigation]);

  const onPressBack = () => {
    stopAll();
    goHome();
  };

  const showInterstitialIfAllowed = useCallback(
    async (after: () => void) => {
      if (isPremium) {
        after();
        return;
      }

      if (!adAllowedRef.current) {
        after();
        return;
      }

      try {
        interstitialCleanupRef.current?.();
      } catch {}
      interstitialCleanupRef.current = null;

      if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
      interstitialTimerRef.current = null;

      const token = interstitialTokenRef.current + 1;
      interstitialTokenRef.current = token;

      const now = Date.now();
      const diff = now - (lastInterstitialAtRef.current || 0);
      const allowed = diff >= INTERSTITIAL_COOLDOWN_MS;

      if (!allowed) {
        adAllowedRef.current = false;
        after();
        return;
      }

      const ad = createInterstitial();

      let done = false;
      const runOnce = () => {
        if (done) return;
        if (interstitialTokenRef.current !== token) return;
        done = true;
        cleanup();
        adAllowedRef.current = false;
        after();
      };

      let unsubClosed: any = null;
      let unsubLoaded: any = null;
      let unsubError: any = null;

      const cleanup = () => {
        try {
          unsubClosed?.();
        } catch {}
        try {
          unsubLoaded?.();
        } catch {}
        try {
          unsubError?.();
        } catch {}
        unsubClosed = null;
        unsubLoaded = null;
        unsubError = null;

        if (interstitialTimerRef.current) clearTimeout(interstitialTimerRef.current);
        interstitialTimerRef.current = null;

        interstitialCleanupRef.current = null;
      };

      interstitialCleanupRef.current = cleanup;

      unsubClosed = ad.addAdEventListener(AdEventType.CLOSED, runOnce);
      unsubLoaded = ad.addAdEventListener(AdEventType.LOADED, () => {
        if (interstitialTokenRef.current !== token) return;
        if (!adAllowedRef.current) return;

        try {
          ad.show();
          lastInterstitialAtRef.current = Date.now();
        } catch {
          runOnce();
        }
      });
      unsubError = ad.addAdEventListener(AdEventType.ERROR, runOnce);

      try {
        ad.load();
      } catch {
        runOnce();
        return;
      }

      interstitialTimerRef.current = setTimeout(runOnce, 1500);
    },
    [isPremium]
  );

  const beginCall = async (ws: SignalClient, rid: string, caller: boolean) => {
    try {
      const rtc = new WebRTCSession({
        onLocalStream: (s) => setLocalStreamURL(s.toURL()),
        onRemoteStream: (s) => setRemoteStreamURL(s.toURL()),
        onIceCandidate: (c) => ws.sendIce(rid, c),
        onAnswer: (sdp) => ws.sendAnswer(rid, sdp),
        onOffer: (sdp) => ws.sendOffer(rid, sdp),
      });

      rtcRef.current = rtc;
      await rtc.start({ isCaller: caller });

      setReMatchText("");
      setPhase("calling");

      try {
        ws.relay(rid, { type: "cam", enabled: Boolean(myCamOn) });
      } catch {}


      if (!isPremium) {
        if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
        limitTimerRef.current = setTimeout(() => {
          setRemoteVideoAllowed(false);
          setLimitModal(true);
        }, FREE_CALL_LIMIT_MS);
      }
    } catch (e) {
      useAppStore.getState().showGlobalModal("통화", "통화를 시작할 수 없습니다.");
      ws.leaveRoom(rid);
      stopAll();
      navigation.goBack();
    }
  };

  const endCallAndRequeue = (why: "remote_left" | "disconnect" | "error" | "find_other") => {
    if (why === "remote_left") {
      setReMatchText("상대방이 방을 떠났습니다.\n새로운 매칭을 시작합니다.");
    } else if (why === "find_other") {
      setReMatchText("새로운 상대를 찾는 중...");
    } else {
      setReMatchText("");
    }


    stopAll();
    setNoMatchModal(false);
    setPhase("connecting");

    if (requeueTimerRef.current) clearTimeout(requeueTimerRef.current);
    requeueTimerRef.current = setTimeout(() => {
      startQueue();
    }, 350);
  };

  const startQueue = () => {
    if (queueRunningRef.current) return;
    queueRunningRef.current = true;
    enqueuedRef.current = false;

    if (!canStart.current) {
      useAppStore.getState().showGlobalModal("매칭", "필터(나라/성별)가 설정되지 않았습니다.");
      queueRunningRef.current = false;
      navigation.goBack();
      return;
    }

    setNoMatchModal(false);
    setPhase("connecting");
    startNoMatchTimer();

    matchInterstitialRef.current = null;

    const ws = new SignalClient({
      onOpen: () => {
        setPhase("queued");

        if (enqueuedRef.current) return;
        enqueuedRef.current = true;

        startNoMatchTimer();
        ws.enqueue(String(prefs.country), String(prefs.gender));
      },
      onClose: () => {
        if (queueRunningRef.current) {
          endCallAndRequeue("disconnect");
        }
      },
      onMessage: async (msg: SignalMessage) => {
        if (msg.type === "queued") {
          setPhase("queued");
          startNoMatchTimer();
          return;
        }

        if (msg.type === "match") {
          clearNoMatchTimer();

          setRoomId(msg.roomId);
          setIsCaller(Boolean(msg.isCaller));
          setPhase("matched");

          try {
            ws.relay(msg.roomId, {
              type: "peer_info",
              country: myCountryRaw,
              language: myLangRaw,
              gender: myGenderRaw,
              flag: myFlag,
              languageLabel: myLangLabel,
              genderLabel: myGenderLabel,
            });
          } catch {}

          const run = () => beginCall(ws, msg.roomId, Boolean(msg.isCaller));

          run();
          return;
        }

        if (msg.type === "signal") {
          const d: any = (msg as any).data;
          const t = String(d?.type ?? d?.kind ?? "").toLowerCase();

          if (t === "cam") {
            setRemoteCamOn(Boolean(d?.enabled));
            return;
          }

          if (t === "peer_info") {
            setPeerInfo({
              country: String(d?.country ?? "").trim(),
              language: String(d?.language ?? d?.lang ?? "").trim(),
              gender: String(d?.gender ?? "").trim(),
              flag: String(d?.flag ?? "").trim(),
              languageLabel: String(d?.languageLabel ?? "").trim(),
              genderLabel: String(d?.genderLabel ?? "").trim(),
            });
            return;
          }
        }

        if (msg.type === "offer") {
          await rtcRef.current?.handleRemoteOffer(msg.sdp);
          return;
        }
        if (msg.type === "answer") {
          await rtcRef.current?.handleRemoteAnswer(msg.sdp);
          return;
        }
        if (msg.type === "ice") {
          await rtcRef.current?.handleRemoteIce(msg.candidate);
          return;
        }
        if (msg.type === "end") {
          endCallAndRequeue("remote_left");
          return;
        }

        if (msg.type === "error") {
          const reason = String(msg.message ?? "").trim();
          const reasonLower = reason.toLowerCase();

          if (reasonLower === "not_registered") {
            if (rebindOnceRef.current) {
              useAppStore.getState().showGlobalModal("인증", reason || "not_registered");
              stopAll();
              navigation.goBack();
              return;
            }

            rebindOnceRef.current = true;
            stopAll();
            setNoMatchModal(false);
            setPhase("connecting");

            (async () => {
              try {
                await bootstrapDeviceBinding();
                startQueue();
              } catch (e) {
                const m = typeof e === "object" && e && "message" in (e as any) ? String((e as any).message) : String(e);
                useAppStore.getState().showGlobalModal("인증", m || "BIND_FAILED");
                navigation.goBack();
              }
            })();

            return;
          }

          useAppStore.getState().showGlobalModal("매칭", reason || "오류가 발생했습니다.");
          endCallAndRequeue("error");
          return;
        }
      },
    });

    wsRef.current = ws;

    const tokenNow = useAppStore.getState().auth.token;
    ws.connect(APP_CONFIG.SIGNALING_URL, tokenNow);
  };

  const toggleCam = () => {
    const next = !myCamOn;
    setMyCamOn(next);
    rtcRef.current?.setLocalVideoEnabled(next);

    try {
      if (roomId) wsRef.current?.relay(roomId, { type: "cam", enabled: next });
    } catch {}
  };

  const toggleSound = () => {
    const next = !mySoundOn;
    setMySoundOn(next);
    rtcRef.current?.setLocalAudioEnabled(next);
  };

  const purchase = async () => {
    await purchasePremium();
    await refreshSubscription();
    const nowPremium = useAppStore.getState().sub.isPremium;
    if (nowPremium) {
      setUpgradeModal(false);
      setLimitModal(false);
      setRemoteVideoAllowed(true);
      if (limitTimerRef.current) clearTimeout(limitTimerRef.current);
      limitTimerRef.current = null;
    }
  };

  useEffect(() => {
    lastInterstitialAtRef.current = Date.now();
    startQueue();
    return () => stopAll();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const endCall = () => {
    const go = () => endCallAndRequeue("find_other");

    try {
      wsRef.current?.leaveRoom(roomId || "");
    } catch {}

    showInterstitialIfAllowed(go);
  };

  const retry = () => {
    setNoMatchModal(false);
    endCallAndRequeue("disconnect");
  };

  const dismissNoMatch = () => {
    setNoMatchModal(false);
  };

  const onPressFindOther = () => {
    adAllowedRef.current = true;

    const go = () => {
      try {
        wsRef.current?.leaveRoom(roomId || "");
      } catch {}
      endCallAndRequeue("find_other");
    };

    showInterstitialIfAllowed(go);
  };

  const setLanguage = useCallback(
    (lang: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ language: lang });
      } else if (typeof setPref === "function") {
        setPref("language", lang);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("language", lang);
      } else {
        showGlobalModal("설정", "언어 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const setCountry = useCallback(
    (iso: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ country: iso });
      } else if (typeof setPref === "function") {
        setPref("country", iso);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("country", iso);
      } else {
        showGlobalModal("설정", "나라 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const setGender = useCallback(
    (gender: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ gender });
      } else if (typeof setPref === "function") {
        setPref("gender", gender);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("gender", gender);
      } else {
        showGlobalModal("설정", "성별 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const languageOptions = useMemo(
    () => [
      { key: "ko", label: "한국어" },
      { key: "en", label: "English" },
      { key: "ja", label: "日本語" },
      { key: "zh", label: "中文" },
      { key: "es", label: "Español" },
    ],
    []
  );

  const countryOptions = useMemo(
    () => [
      { key: "KR", name: "Korea" },
      { key: "US", name: "United States" },
      { key: "JP", name: "Japan" },
      { key: "CN", name: "China" },
      { key: "TW", name: "Taiwan" },
      { key: "HK", name: "Hong Kong" },
      { key: "SG", name: "Singapore" },
      { key: "TH", name: "Thailand" },
      { key: "VN", name: "Vietnam" },
      { key: "PH", name: "Philippines" },
      { key: "ID", name: "Indonesia" },
      { key: "MY", name: "Malaysia" },
      { key: "IN", name: "India" },
      { key: "AU", name: "Australia" },
      { key: "CA", name: "Canada" },
      { key: "GB", name: "United Kingdom" },
      { key: "DE", name: "Germany" },
      { key: "FR", name: "France" },
      { key: "ES", name: "Spain" },
      { key: "IT", name: "Italy" },
      { key: "BR", name: "Brazil" },
      { key: "MX", name: "Mexico" },
    ],
    []
  );

  const genderOptions = useMemo(
    () => [
      { key: "male", label: "남성" },
      { key: "female", label: "여성" },
    ],
    []
  );

  const currentLanguageLabel = useMemo(() => {
    const cur = String((prefs as any)?.language || "");
    const found = languageOptions.find((x) => x.key === cur);
    return found ? found.label : cur || "미설정";
  }, [languageOptions, prefs]);

  const currentCountryDisplay = useMemo(() => {
    const cur = String((prefs as any)?.country || "").toUpperCase();
    const found = countryOptions.find((x) => x.key === cur);
    const nm = found ? found.name : cur || "미설정";
    const cc = found ? found.key : cur;
    const flag = countryCodeToFlagEmoji(cc);
    if (!cc) return nm;
    return `${flag ? flag + " " : ""}${nm} (${cc})`;
  }, [countryOptions, prefs]);

  const currentGenderLabel = useMemo(() => {
    const cur = String((prefs as any)?.gender || "");
    const found = genderOptions.find((x) => x.key === cur);
    return found ? found.label : cur || "미설정";
  }, [genderOptions, prefs]);

  return (
    <View style={styles.root}>
      {/* ✅ 상단 헤더 제거, 뒤로가기만 오버레이(테두리 없음) */}
      <Pressable
        onPress={onPressBack}
        style={({ pressed }) => [
          styles.backBtn,
          { top: insets.top + 8, left: 12 },
          pressed ? { opacity: 0.7 } : null,
        ]}
      >
        <Ionicons name="chevron-back" size={30} color="#fff" />
      </Pressable>


      <View style={styles.stage}>
        {/* ✅ 상대 영상 풀스크린/배경 블랙 */}
        {remoteStreamURL && remoteVideoAllowed && remoteCamOn ? (
          <RTCView streamURL={remoteStreamURL} style={styles.remote} objectFit="cover" zOrder={0} />
        ) : (
          <View style={styles.placeholder}>
            {phase === "calling" && !remoteVideoAllowed ? (
              <AppText style={styles.placeholderText}>무료 통화 시간이 종료되었습니다.</AppText>
            ) : phase === "calling" && !remoteCamOn ? (
              <Ionicons name="videocam-off" size={54} color="rgba(255, 255, 255, 0.92)" />
            ) : null}
          </View>
        )}


        {/* ✅ 내 캠 + 버튼(카메라/마이크/설정) 아래로 이동 + 선(라인) 제거 + 캠 OFF 오버레이 */}
        {phase === "calling" ? (
          <View style={[styles.localDock, { top: insets.top + 12, right: 12 }]}>
            <View style={styles.localFrame}>
              {localStreamURL ? (
                myCamOn ? (
                  <RTCView streamURL={localStreamURL} style={styles.localVideo} objectFit="cover" zOrder={1} />
                ) : (
                  <View style={styles.localCamOffBg} />
                )
              ) : (
                <View style={styles.localEmpty} />
              )}

              {!myCamOn ? (
                <View style={styles.camOffOverlay}>
                  <Ionicons name="videocam-off" size={34} color="rgba(255, 255, 255, 0.92)" />
                </View>
              ) : null}
            </View>


            <View style={styles.localControls}>
              <Pressable onPress={toggleCam} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name={myCamOn ? "videocam" : "videocam-off"} size={20} color="#fff" />
              </Pressable>

              <Pressable onPress={toggleSound} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name={mySoundOn ? "mic" : "mic-off"} size={20} color="#fff" />
              </Pressable>

              <Pressable onPress={() => setPrefsModal(true)} style={({ pressed }) => [styles.iconCircle, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name="settings-outline" size={20} color="#fff" />
              </Pressable>
            </View>
          </View>
        ) : null}

        {!isPremium && phase !== "calling" ? (
          <View style={[styles.queueAdDock, { top: insets.top + 96 }]}>
            <QueueNativeAd256x144 />
          </View>
        ) : null}


        {/* ✅ 연결/재매칭 상태 오버레이(상대 나가면 안내문+스피너+자동 재매칭) */}
        {phase !== "calling" ? (
          <View style={styles.centerOverlay}>
            <Spinner />

            {reMatchText || phase === "connecting" || phase === "matched" ? <View style={{ height: 12 }} /> : null}

            {reMatchText ? (
              <AppText style={styles.centerText}>{reMatchText}</AppText>
            ) : phase === "connecting" ? (
              <AppText style={styles.centerText}>연결 중...</AppText>
            ) : phase === "matched" ? (
              <AppText style={styles.centerText}>매칭됨</AppText>
            ) : null}

          </View>
        ) : null}


        {/* ✅ 우측하단 배너 + 그 위 내 나라/국기/언어 + 아이콘(다른상대찾기) */}
        {!isPremium ? (
          <View style={[styles.bannerDock, { paddingBottom: Math.max(insets.bottom, 8), left: 0, right: 0 }]}>
            <View style={styles.myInfoRow}>
              <View style={styles.myInfoCenter}>
                {peerInfoText ? <AppText style={styles.myInfoText}>{peerInfoText}</AppText> : null}
              </View>

              <Pressable onPress={onPressFindOther} style={({ pressed }) => [styles.findOtherBtn, pressed ? { opacity: 0.7 } : null]}>
                <Ionicons name="sync-circle" size={60} color="rgba(255, 205, 230, 0.84)" />
              </Pressable>
            </View>

            <BannerBar />
          </View>
        ) : null}
      </View>

      <AppModal
        visible={limitModal}
        title="무료 이용 시간 종료"
        dismissible={false}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="프리미엄 구매" onPress={() => setUpgradeModal(true)} />
            <PrimaryButton title="나가기" onPress={() => { stopAll(); goHome(); }} variant="ghost" />
          </View>
        }
      >
        <AppText style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>
          무료 통화 시간(예: {Math.round(FREE_CALL_LIMIT_MS / 1000)}초)이 종료되었습니다.
          {"\n"}프리미엄을 구매하면 제한 없이 이용할 수 있습니다.
        </AppText>
      </AppModal>

      <AppModal
        visible={upgradeModal}
        title="프리미엄"
        dismissible={true}
        onClose={() => setUpgradeModal(false)}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="구매하기" onPress={purchase} />
            <PrimaryButton title="닫기" onPress={() => setUpgradeModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>
          프리미엄 구매 시 광고 제거 및 통화 제한이 해제됩니다.
        </AppText>
      </AppModal>

      <AppModal
        visible={noMatchModal}
        title="매칭이 지연되고 있습니다"
        dismissible={true}
        onClose={dismissNoMatch}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="다시 시도" onPress={retry} />
            <PrimaryButton title="나가기" onPress={() => { stopAll(); goHome(); }} variant="ghost" />
          </View>
        }
      >
        <AppText style={{ fontSize: 16, color: theme.colors.sub, lineHeight: 20 }}>
          조금만 기다렸다가 다시 시도해 주세요.
        </AppText>
      </AppModal>

      <AppModal
        visible={prefsModal}
        title="설정"
        dismissible={true}
        onClose={() => {
          setPrefsModal(false);
          setLangOpen(false);
          setCountryOpen(false);
          setGenderOpen(false);
        }}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="닫기" onPress={() => setPrefsModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.modalText}>나라/언어/성별을 설정하세요.</AppText>

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>나라(지역)</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setCountryOpen((v) => !v);
            setLangOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentCountryDisplay}</AppText>
          <AppText style={styles.dropdownChevron}>{countryOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {countryOpen ? (
          <View style={styles.dropdownListWrap}>
            <ScrollView
              style={styles.dropdownScroll}
              contentContainerStyle={styles.dropdownScrollContent}
              showsVerticalScrollIndicator={true}
            >
              {countryOptions.map((opt) => {
                const active = String((prefs as any)?.country || "").toUpperCase() === opt.key;
                const flag = countryCodeToFlagEmoji(opt.key);
                return (
                  <Pressable
                    key={opt.key}
                    onPress={() => {
                      setCountry(opt.key);
                      setCountryOpen(false);
                    }}
                    style={({ pressed }) => [
                      styles.dropdownRow,
                      active ? styles.dropdownRowActive : null,
                      pressed ? { opacity: 0.75 } : null,
                    ]}
                  >
                    <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>
                      {flag ? `${flag} ` : ""}
                      {opt.name}
                    </AppText>

                    <View style={styles.countryRight}>
                      <AppText style={[styles.countryCode, active ? styles.countryCodeActive : null]}>({opt.key})</AppText>
                      {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                    </View>
                  </Pressable>
                );
              })}
            </ScrollView>
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>언어</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setLangOpen((v) => !v);
            setCountryOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentLanguageLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{langOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {langOpen ? (
          <View style={styles.dropdownList}>
            {languageOptions.map((opt) => {
              const active = String((prefs as any)?.language || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setLanguage(opt.key);
                    setLangOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>성별</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setGenderOpen((v) => !v);
            setCountryOpen(false);
            setLangOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentGenderLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{genderOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {genderOpen ? (
          <View style={styles.dropdownList}>
            {genderOptions.map((opt) => {
              const active = String((prefs as any)?.gender || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setGender(opt.key);
                    setGenderOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>글자 크기</AppText>
        <AppText style={styles.modalText}>바를 좌우로 드래그해서 조절하세요. ({Math.round(fontScale * 100)}%)</AppText>
        <FontSizeSlider value={fontScale} onChange={setFontScale} />
      </AppModal>
    </View>
  );
}

const W = Dimensions.get("window").width;

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#000" },

  stage: { flex: 1, position: "relative", backgroundColor: "#000" },

  remote: { ...StyleSheet.absoluteFillObject, backgroundColor: "#000" },

  placeholder: { ...StyleSheet.absoluteFillObject, alignItems: "center", justifyContent: "center", backgroundColor: "#000" },
  placeholderText: { fontSize: 14, color: "rgba(255,255,255,0.75)", fontWeight: "700" },

  backBtn: {
    position: "absolute",
    zIndex: 20,
    width: 44,
    height: 44,
    alignItems: "flex-start",
    justifyContent: "center",
  },

  localDock: {
    position: "absolute",
    zIndex: 15,
    alignItems: "flex-end",
    gap: 10,
  },

  localFrame: {
    width: Math.min(180, W * 0.36),
    height: Math.min(200, W * 0.46),
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "#000",
  },

  localVideo: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#000",
    transform: [{ scale: 1.03 }],
  },

  localEmpty: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(255,255,255,0.08)",
  },

  localCamOffBg: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "#000",
    borderRadius: 12,
  },

  camOffOverlay: {
    ...StyleSheet.absoluteFillObject,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "#000",
    borderRadius: 12,
  },

  localControls: {
    width: Math.min(140, W * 0.34),
    flexDirection: "row",
    justifyContent: "flex-end",
    gap: 10,
    position: "relative",
    right: -6,
  },

  iconCircle: {
    width: 44,
    height: 44,
    borderRadius: 22,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0,0,0,0.45)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.18)",
  },

  centerOverlay: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 10,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 18,
  },

  centerText: {
    textAlign: "center",
    fontSize: 16,
    fontWeight: "700",
    color: "rgba(201, 201, 201, 0.85)",
    lineHeight: 20,
  },

  queueAdDock: {
    position: "absolute",
    zIndex: 11,
    left: 0,
    right: 0,
    alignItems: "center",
  },

  nativeAd256: {
    width: 360,
    height: 202,
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "rgba(255,255,255,0.06)",
  },
  nativeAdInner: {
    flex: 1,
  },
  nativeAdMedia: {
    flex: 1,
  },
  nativeAdFooter: {
    position: "absolute",
    left: 0,
    right: 0,
    bottom: 0,
    paddingHorizontal: 10,
    paddingVertical: 8,
    backgroundColor: "rgba(0,0,0,0.55)",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    gap: 8,
  },
  nativeAdHeadline: {
    flex: 1,
    fontSize: 12,
    color: "rgba(255,255,255,0.92)",
    fontWeight: "800",
  },
  nativeAdTag: {
    fontSize: 11,
    color: "rgba(255,255,255,0.75)",
    fontWeight: "900",
  },

  bannerDock: {
    position: "absolute",
    zIndex: 12,
    bottom: 0,
    left: 0,
    right: 0,
    alignItems: "center",
    gap: 6,
  },

  myInfoRow: {
    width: "100%",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 12,
    position: "relative",
    minHeight: 52,
  },

  myInfoCenter: {
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
  },

  myInfoText: {
    color: "rgba(255,255,255,0.9)",
    fontSize: 15,
    fontWeight: "600",
  },

  findOtherBtn: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    position: "absolute",
    right: 12,
    top: -40,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
  },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  sectionTitle: { fontSize: 14, fontWeight: "700", color: theme.colors.text },

  dropdownBtn: {
    width: "100%",
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownBtnText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownChevron: { fontSize: 12, color: theme.colors.sub, fontWeight: "900" },

  dropdownList: {
    width: "100%",
    marginTop: 8,
    gap: 8,
  },

  dropdownListWrap: {
    width: "100%",
    marginTop: 8,
    borderRadius: 12,
    overflow: "hidden",
  },
  dropdownScroll: {
    maxHeight: 210,
  },
  dropdownScrollContent: {
    gap: 8,
  },

  dropdownRow: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownRowActive: {
    borderColor: theme.colors.pinkDeep,
    backgroundColor: theme.colors.cardSoft,
  },
  dropdownText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownTextActive: { color: theme.colors.pinkDeep },
  dropdownCheck: { fontSize: 14, color: theme.colors.pinkDeep, fontWeight: "900" },

  countryRight: { flexDirection: "row", alignItems: "center", gap: 10 },
  countryCode: { fontSize: 12, color: theme.colors.sub, fontWeight: "800" },
  countryCodeActive: { color: theme.colors.pinkDeep },
});


================================================================================
 FILE: src\screens\HomeScreen.tsx
================================================================================

﻿// FILE: C:\ranchat\src\screens\HomeScreen.tsx
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { PermissionsAndroid, Platform, Pressable, StyleSheet, View, ScrollView } from "react-native";
import { theme } from "../config/theme";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { BannerBar, createInterstitial } from "../services/ads/AdManager";
import { useAppStore } from "../store/useAppStore";
import { AdEventType } from "react-native-google-mobile-ads";
import AppText from "../components/AppText";
import FontSizeSlider from "../components/FontSizeSlider";
import { useSafeAreaInsets } from "react-native-safe-area-context";

export default function HomeScreen({ navigation }: any) {
  const insets = useSafeAreaInsets();

  const prefs = useAppStore((s: any) => s.prefs);
  const isPremium = useAppStore((s: any) => s.sub.isPremium);
  const showGlobalModal = useAppStore((s: any) => s.showGlobalModal);

  const fontScale = useAppStore((s: any) => s.ui.fontScale);
  const setFontScale = useAppStore((s: any) => s.setFontScale);

  const [permModal, setPermModal] = useState(false);
  const [permBusy, setPermBusy] = useState(false);

  const [prefsModal, setPrefsModal] = useState(false);

  const [langOpen, setLangOpen] = useState(false);
  const [countryOpen, setCountryOpen] = useState(false);
  const [genderOpen, setGenderOpen] = useState(false);

  const [permState, setPermState] = useState({ cam: false, mic: false, loc: false });

  const interstitialRef = useRef<any>(null);

  const canMatch = useMemo(() => {
    const countryOk = String(prefs.country || "").length > 0;
    const genderOk = String(prefs.gender || "").length > 0;
    const langOk = String(prefs.language || "").length > 0;
    return countryOk && genderOk && langOk;
  }, [prefs.country, prefs.gender, prefs.language]);

  useLayoutEffect(() => {
    navigation.setOptions({
      headerLeft: () => (
        <Pressable
          onPress={() => navigation.navigate("Profile")}
          style={({ pressed }) => [styles.headerBtn, pressed ? { opacity: 0.6 } : null]}
        >
          <AppText style={styles.headerBtnText}>≡</AppText>
        </Pressable>
      ),
      headerRight: () => (
        <Pressable
          onPress={() => setPrefsModal(true)}
          style={({ pressed }) => [styles.headerBtn, pressed ? { opacity: 0.6 } : null]}
        >
          <AppText style={styles.headerBtnText}>⚙</AppText>
        </Pressable>
      ),
    });
  }, [navigation]);

  const isoToFlag = useCallback((iso: string) => {
    const cc = String(iso || "").toUpperCase();
    if (cc.length !== 2) return "";
    const A = 0x1f1e6;
    const c1 = cc.charCodeAt(0);
    const c2 = cc.charCodeAt(1);
    if (c1 < 65 || c1 > 90 || c2 < 65 || c2 > 90) return "";
    return String.fromCodePoint(A + (c1 - 65), A + (c2 - 65));
  }, []);

  const hasAndroidPermission = useCallback(async (perm: string) => {
    try {
      const r = await PermissionsAndroid.check(perm as any);
      return Boolean(r);
    } catch {
      return false;
    }
  }, []);

  const checkPermissions = useCallback(async () => {
    if (Platform.OS !== "android") {
      setPermModal(false);
      setPermState({ cam: true, mic: true, loc: true });
      return;
    }

    const cam = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA);
    const mic = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
    const loc =
      (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
      (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

    setPermState({ cam, mic, loc });

    const ok = cam && mic && loc;
    setPermModal(!ok);
  }, [hasAndroidPermission]);

  useEffect(() => {
    checkPermissions();
  }, [checkPermissions]);

  const requestPermissions = useCallback(async () => {
    if (permBusy) return;
    setPermBusy(true);

    try {
      if (Platform.OS !== "android") {
        setPermModal(false);
        setPermState({ cam: true, mic: true, loc: true });
        return;
      }

      const camBefore = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA);
      const micBefore = await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
      const locBefore =
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

      const needs: string[] = [];
      if (!camBefore) needs.push(PermissionsAndroid.PERMISSIONS.CAMERA);
      if (!micBefore) needs.push(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
      if (!locBefore) needs.push(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION);

      const results: Record<string, string> = {};

      if (needs.length > 0) {
        const multi = await PermissionsAndroid.requestMultiple(needs as any);
        results.camera = multi[PermissionsAndroid.PERMISSIONS.CAMERA];
        results.mic = multi[PermissionsAndroid.PERMISSIONS.RECORD_AUDIO];
        results.loc = multi[PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION];
      }

      const cam =
        camBefore ||
        results.camera === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.CAMERA));

      const mic =
        micBefore ||
        results.mic === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO));

      const loc =
        locBefore ||
        results.loc === PermissionsAndroid.RESULTS.GRANTED ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION)) ||
        (await hasAndroidPermission(PermissionsAndroid.PERMISSIONS.ACCESS_COARSE_LOCATION));

      setPermState({ cam, mic, loc });

      const ok = cam && mic && loc;

      if (!ok) {
        showGlobalModal("권한허용이 필요합니다", "카메라/마이크/위치(GPS)권한을 설정에서 직접 켜야 합니다.");
        setPermModal(true);
      } else {
        setPermModal(false);
      }
    } catch {
      showGlobalModal("권한", "권한 요청에 실패했습니다.");
      setPermModal(true);
    } finally {
      setPermBusy(false);
    }
  }, [hasAndroidPermission, permBusy, showGlobalModal]);

  const goCall = useCallback(() => {
    navigation.navigate("Call");
  }, [navigation]);

  const setLanguage = useCallback(
    (lang: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ language: lang });
      } else if (typeof setPref === "function") {
        setPref("language", lang);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("language", lang);
      } else {
        showGlobalModal("설정", "언어 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const setCountry = useCallback(
    (iso: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ country: iso });
      } else if (typeof setPref === "function") {
        setPref("country", iso);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("country", iso);
      } else {
        showGlobalModal("설정", "나라 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const setGender = useCallback(
    (gender: string) => {
      const st: any = useAppStore.getState?.() ?? {};
      const setPrefs = st.setPrefs;
      const setPref = st.setPref;
      const setPrefsField = st.setPrefsField;

      if (typeof setPrefs === "function") {
        setPrefs({ gender });
      } else if (typeof setPref === "function") {
        setPref("gender", gender);
      } else if (typeof setPrefsField === "function") {
        setPrefsField("gender", gender);
      } else {
        showGlobalModal("설정", "성별 저장 함수가 스토어에 없습니다. (setPrefs/setPref/setPrefsField)");
      }
    },
    [showGlobalModal]
  );

  const languageOptions = useMemo(
    () => [
      { key: "ko", label: "한국어" },
      { key: "en", label: "English" },
      { key: "ja", label: "日本語" },
      { key: "zh", label: "中文" },
      { key: "es", label: "Español" },
    ],
    []
  );

  const countryOptions = useMemo(
    () => [
      { key: "KR", name: "Korea" },
      { key: "US", name: "United States" },
      { key: "JP", name: "Japan" },
      { key: "CN", name: "China" },
      { key: "TW", name: "Taiwan" },
      { key: "HK", name: "Hong Kong" },
      { key: "SG", name: "Singapore" },
      { key: "TH", name: "Thailand" },
      { key: "VN", name: "Vietnam" },
      { key: "PH", name: "Philippines" },
      { key: "ID", name: "Indonesia" },
      { key: "MY", name: "Malaysia" },
      { key: "IN", name: "India" },
      { key: "AU", name: "Australia" },
      { key: "CA", name: "Canada" },
      { key: "GB", name: "United Kingdom" },
      { key: "DE", name: "Germany" },
      { key: "FR", name: "France" },
      { key: "ES", name: "Spain" },
      { key: "IT", name: "Italy" },
      { key: "BR", name: "Brazil" },
      { key: "MX", name: "Mexico" },
    ],
    []
  );

  const genderOptions = useMemo(
    () => [
      { key: "male", label: "남성" },
      { key: "female", label: "여성" },
    ],
    []
  );

  const currentLanguageLabel = useMemo(() => {
    const cur = String(prefs.language || "");
    const found = languageOptions.find((x) => x.key === cur);
    return found ? found.label : cur || "미설정";
  }, [languageOptions, prefs.language]);

  const currentCountryDisplay = useMemo(() => {
    const cur = String(prefs.country || "").toUpperCase();
    const found = countryOptions.find((x) => x.key === cur);
    const nm = found ? found.name : cur || "미설정";
    const cc = found ? found.key : cur;
    const flag = isoToFlag(cc);
    if (!cc) return nm;
    return `${flag ? flag + " " : ""}${nm} (${cc})`;
  }, [countryOptions, isoToFlag, prefs.country]);

  const currentGenderLabel = useMemo(() => {
    const cur = String(prefs.gender || "");
    const found = genderOptions.find((x) => x.key === cur);
    return found ? found.label : cur || "미설정";
  }, [genderOptions, prefs.gender]);

  const permOk = Boolean(permState.cam && permState.mic && permState.loc);

  const onPressMatch = useCallback(() => {
    if (Platform.OS === "android" && !permOk) {
      setPermModal(true);
      requestPermissions();
      return;
    }

    if (!canMatch) {
      setPrefsModal(true);
      return;
    }

    if (isPremium) {
      goCall();
      return;
    }

    const ad = createInterstitial();
    interstitialRef.current = ad;

    let done = false;
    const runOnce = () => {
      if (done) return;
      done = true;
      goCall();
    };

    let unsubClosed: any = null;
    let unsubLoaded: any = null;
    let unsubError: any = null;

    const cleanup = () => {
      try {
        unsubClosed?.();
      } catch {}
      try {
        unsubLoaded?.();
      } catch {}
      try {
        unsubError?.();
      } catch {}
      unsubClosed = null;
      unsubLoaded = null;
      unsubError = null;
    };

    unsubClosed = ad.addAdEventListener(AdEventType.CLOSED, () => {
      cleanup();
      runOnce();
    });

    unsubLoaded = ad.addAdEventListener(AdEventType.LOADED, () => {
      try {
        ad.show();
      } catch {
        cleanup();
        runOnce();
      }
    });

    unsubError = ad.addAdEventListener(AdEventType.ERROR, () => {
      cleanup();
      runOnce();
    });

    try {
      ad.load();
    } catch {
      cleanup();
      runOnce();
      return;
    }

    setTimeout(() => {
      cleanup();
      runOnce();
    }, 1500);
  }, [canMatch, goCall, isPremium, permOk, requestPermissions]);

  return (
    <View style={styles.root}>
      <View style={styles.body}>
        <View style={styles.center}>
          <AppText style={styles.title}>랜덤 영상채팅</AppText>
          <AppText style={styles.sub}>지역/언어/성별을 설정한 뒤 매칭을 시작하세요.</AppText>

          <View style={styles.matchBtnWrap}>
            <PrimaryButton title="매칭하기" onPress={onPressMatch} />
          </View>

          <Pressable
            onPress={() => setPermModal(true)}
            style={({ pressed }) => [styles.smallLink, pressed ? { opacity: 0.6 } : null]}
          >
            <AppText style={styles.smallLinkText}>권한 설정</AppText>
          </Pressable>
        </View>
      </View>

      {!isPremium ? (
        <View style={[styles.banner, { paddingBottom: Math.max(insets.bottom, 8) }]}>
          <BannerBar />
        </View>
      ) : null}

      <AppModal
        visible={permModal}
        title=""
        dismissible={false}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton
              title={permBusy ? "요청 중..." : permOk ? "모든 권한 허용됨" : "권한 허용하기"}
              onPress={requestPermissions}
              disabled={permBusy || permOk}
            />
            <PrimaryButton title="닫기" onPress={() => setPermModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.permTitle}>권한이 필요합니다</AppText>
        <AppText style={styles.modalText}>아래 권한을 허용해야 영상채팅을 시작할 수 있습니다.</AppText>

        <View style={{ height: 12 }} />

        <View style={styles.permList}>
          <View style={styles.permRow}>
            <AppText style={[styles.permLeft, !permState.cam ? styles.permLeftNeed : null]}>• 카메라</AppText>
            {!permState.cam ? <AppText style={styles.permNeed}>(권한허용필요)</AppText> : null}
          </View>

          <View style={styles.permRow}>
            <AppText style={[styles.permLeft, !permState.mic ? styles.permLeftNeed : null]}>• 마이크(소리)</AppText>
            {!permState.mic ? <AppText style={styles.permNeed}>(권한허용필요)</AppText> : null}
          </View>

          <View style={styles.permRow}>
            <AppText style={[styles.permLeft, !permState.loc ? styles.permLeftNeed : null]}>• 위치(GPS)</AppText>
            {!permState.loc ? <AppText style={styles.permNeed}>(권한허용필요)</AppText> : null}
          </View>
        </View>
      </AppModal>

      <AppModal
        visible={prefsModal}
        title="설정"
        dismissible={true}
        onClose={() => {
          setPrefsModal(false);
          setLangOpen(false);
          setCountryOpen(false);
          setGenderOpen(false);
        }}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="닫기" onPress={() => setPrefsModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.modalText}>나라/언어/성별을 설정하세요.</AppText>

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>나라(지역)</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setCountryOpen((v) => !v);
            setLangOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentCountryDisplay}</AppText>
          <AppText style={styles.dropdownChevron}>{countryOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {countryOpen ? (
          <View style={styles.dropdownListWrap}>
            <ScrollView
              style={styles.dropdownScroll}
              contentContainerStyle={styles.dropdownScrollContent}
              showsVerticalScrollIndicator={true}
            >
              {countryOptions.map((opt) => {
                const active = String(prefs.country || "").toUpperCase() === opt.key;
                const flag = isoToFlag(opt.key);
                return (
                  <Pressable
                    key={opt.key}
                    onPress={() => {
                      setCountry(opt.key);
                      setCountryOpen(false);
                    }}
                    style={({ pressed }) => [
                      styles.dropdownRow,
                      active ? styles.dropdownRowActive : null,
                      pressed ? { opacity: 0.75 } : null,
                    ]}
                  >
                    <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>
                      {flag ? `${flag} ` : ""}
                      {opt.name}
                    </AppText>

                    <View style={styles.countryRight}>
                      <AppText style={[styles.countryCode, active ? styles.countryCodeActive : null]}>({opt.key})</AppText>
                      {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                    </View>
                  </Pressable>
                );
              })}
            </ScrollView>
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>언어</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setLangOpen((v) => !v);
            setCountryOpen(false);
            setGenderOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentLanguageLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{langOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {langOpen ? (
          <View style={styles.dropdownList}>
            {languageOptions.map((opt) => {
              const active = String(prefs.language || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setLanguage(opt.key);
                    setLangOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>성별</AppText>

        <View style={{ height: 0 }} />

        <Pressable
          onPress={() => {
            setGenderOpen((v) => !v);
            setCountryOpen(false);
            setLangOpen(false);
          }}
          style={({ pressed }) => [styles.dropdownBtn, pressed ? { opacity: 0.8 } : null]}
        >
          <AppText style={styles.dropdownBtnText}>{currentGenderLabel}</AppText>
          <AppText style={styles.dropdownChevron}>{genderOpen ? "▲" : "▼"}</AppText>
        </Pressable>

        {genderOpen ? (
          <View style={styles.dropdownList}>
            {genderOptions.map((opt) => {
              const active = String(prefs.gender || "") === opt.key;
              return (
                <Pressable
                  key={opt.key}
                  onPress={() => {
                    setGender(opt.key);
                    setGenderOpen(false);
                  }}
                  style={({ pressed }) => [
                    styles.dropdownRow,
                    active ? styles.dropdownRowActive : null,
                    pressed ? { opacity: 0.75 } : null,
                  ]}
                >
                  <AppText style={[styles.dropdownText, active ? styles.dropdownTextActive : null]}>{opt.label}</AppText>
                  {active ? <AppText style={styles.dropdownCheck}>✓</AppText> : null}
                </Pressable>
              );
            })}
          </View>
        ) : null}

        <View style={{ height: 0 }} />

        <AppText style={styles.sectionTitle}>글자 크기</AppText>
        <AppText style={styles.modalText}>바를 좌우로 드래그해서 조절하세요. ({Math.round(fontScale * 100)}%)</AppText>
        <FontSizeSlider value={fontScale} onChange={setFontScale} />
      </AppModal>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: theme.colors.bg },
  body: { flex: 1, padding: theme.spacing.lg },
  center: { flex: 1, alignItems: "center", justifyContent: "center", gap: 12 },
  title: { fontSize: 26, fontWeight: "700", color: theme.colors.text },
  sub: { fontSize: 14, color: theme.colors.sub, textAlign: "center", lineHeight: 20 },
  matchBtnWrap: { width: "100%", maxWidth: 420 },

  banner: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.line,
    backgroundColor: theme.colors.bg,
    alignItems: "center",
  },
  headerBtn: { paddingHorizontal: 12, paddingVertical: 8 },
  headerBtnText: { fontSize: 22, color: theme.colors.text, fontWeight: "700" },

  smallLink: { paddingVertical: 8, paddingHorizontal: 8 },
  smallLinkText: { color: theme.colors.sub, textDecorationLine: "underline" },

  modalText: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  permTitle: { fontSize: 18, fontWeight: "900", color: theme.colors.text, marginBottom: 6 },
  permList: { width: "100%", gap: 8 },
  permRow: { width: "100%", flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  permLeft: { fontSize: 14, color: theme.colors.text, fontWeight: "800" },
  permLeftNeed: { color: "#ff4d4f" },
  permNeed: { fontSize: 12, color: "#ff4d4f", fontWeight: "900" },

  sectionTitle: { fontSize: 14, fontWeight: "700", color: theme.colors.text },

  dropdownBtn: {
    width: "100%",
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownBtnText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownChevron: { fontSize: 12, color: theme.colors.sub, fontWeight: "900" },

  dropdownList: {
    width: "100%",
    marginTop: 8,
    gap: 8,
  },

  dropdownListWrap: {
    width: "100%",
    marginTop: 8,
    borderRadius: 12,
    overflow: "hidden",
  },
  dropdownScroll: {
    maxHeight: 210,
  },
  dropdownScrollContent: {
    gap: 8,
  },

  dropdownRow: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: theme.colors.line,
    backgroundColor: theme.colors.card,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  dropdownRowActive: {
    borderColor: theme.colors.pinkDeep,
    backgroundColor: theme.colors.cardSoft,
  },
  dropdownText: { fontSize: 14, color: theme.colors.text, fontWeight: "700" },
  dropdownTextActive: { color: theme.colors.pinkDeep },
  dropdownCheck: { fontSize: 14, color: theme.colors.pinkDeep, fontWeight: "900" },

  countryRight: { flexDirection: "row", alignItems: "center", gap: 10 },
  countryCode: { fontSize: 12, color: theme.colors.sub, fontWeight: "800" },
  countryCodeActive: { color: theme.colors.pinkDeep },
});


================================================================================
 FILE: src\screens\ProfileScreen.tsx
================================================================================

﻿//C:\ranchat\src\screens\ProfileScreen.tsx
import React, { useMemo, useState } from "react";
import { Linking, ScrollView, StyleSheet, View } from "react-native";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { theme } from "../config/theme";
import { useAppStore } from "../store/useAppStore";
import { purchasePremium, refreshSubscription, openManageSubscriptions } from "../services/purchases/PurchaseManager";
import { APP_CONFIG, COUNTRY_OPTIONS } from "../config/app";
import AppText from "../components/AppText";

export default function ProfileScreen() {
  const prefs = useAppStore((s) => s.prefs);
  const sub = useAppStore((s) => s.sub);
  const logoutAndWipe = useAppStore((s) => s.logoutAndWipe);

  const setPrefs = useAppStore((s) => s.setPrefs);

  const [prefsModal, setPrefsModal] = useState(false);
  const [withdrawModal, setWithdrawModal] = useState(false);

  const countryLabel = useMemo(() => {
    const c = COUNTRY_OPTIONS.find((x) => x.code === prefs.country);
    return c?.label ?? "-";
  }, [prefs.country]);

  const openPrivacy = async () => {
    const url = APP_CONFIG.POLICY.privacyUrl;
    if (!url) {
      useAppStore.getState().showGlobalModal("정책", "개인정보처리방침 URL이 설정되지 않았습니다.");
      return;
    }
    await Linking.openURL(url);
  };

  const doPurchase = async () => {
    await purchasePremium();
    await refreshSubscription();
  };

  const doWithdraw = async () => {
    await logoutAndWipe();
  };

  return (
    <ScrollView contentContainerStyle={styles.wrap}>
      <View style={styles.card}>
        <AppText style={styles.h1}>구독 상태</AppText>
        <AppText style={styles.p}>{sub.isPremium ? "프리미엄 이용 중" : "무료 이용 중"}</AppText>

        <View style={{ height: 10 }} />

        {!sub.isPremium ? <PrimaryButton title="프리미엄 신청" onPress={doPurchase} /> : null}
        <View style={{ height: 10 }} />
        <PrimaryButton title="구독 관리" onPress={openManageSubscriptions} variant="ghost" />
      </View>

      <View style={styles.card}>
        <AppText style={styles.h1}>개인정보</AppText>

        <View style={styles.row}>
          <AppText style={styles.k}>언어</AppText>
          <AppText style={styles.v}>{prefs.language === "ko" ? "한국어" : prefs.language === "en" ? "English" : "-"}</AppText>
        </View>
        <View style={styles.row}>
          <AppText style={styles.k}>나라</AppText>
          <AppText style={styles.v}>{countryLabel}</AppText>
        </View>
        <View style={styles.row}>
          <AppText style={styles.k}>성별</AppText>
          <AppText style={styles.v}>{prefs.gender === "male" ? "남성" : prefs.gender === "female" ? "여성" : "-"}</AppText>
        </View>

        <View style={{ height: 14 }} />

        <PrimaryButton title="개인정보 변경" onPress={() => setPrefsModal(true)} variant="ghost" />
      </View>

      <View style={styles.card}>
        <PrimaryButton title="개인정보 처리방침" onPress={openPrivacy} variant="ghost" />
        <View style={{ height: 10 }} />
        <PrimaryButton title="탈퇴하기" onPress={() => setWithdrawModal(true)} variant="danger" />
      </View>

      <PrefsModal visible={prefsModal} onClose={() => setPrefsModal(false)} prefs={prefs} setPrefs={setPrefs} />

      <AppModal
        visible={withdrawModal}
        title="탈퇴하기"
        onClose={() => setWithdrawModal(false)}
        dismissible={true}
        footer={
          <View style={{ gap: 10 }}>
            <PrimaryButton title="탈퇴" onPress={doWithdraw} variant="danger" />
            <PrimaryButton title="취소" onPress={() => setWithdrawModal(false)} variant="ghost" />
          </View>
        }
      >
        <AppText style={styles.p}>탈퇴 시 로컬 데이터가 삭제되고 다시 인증이 필요합니다.</AppText>
      </AppModal>
    </ScrollView>
  );
}

function PrefsModal({
  visible,
  onClose,
  prefs,
  setPrefs,
}: {
  visible: boolean;
  onClose: () => void;
  prefs: any;
  setPrefs: (p: any) => void;
}) {
  const [language, setLanguage] = useState(prefs.language);
  const [country, setCountry] = useState(prefs.country);
  const [gender, setGender] = useState(prefs.gender);

  const save = () => {
    if (!language || !country || !gender) return;
    setPrefs({ language, country, gender });
    onClose();
  };

  return (
    <AppModal
      visible={visible}
      title="개인정보 변경"
      onClose={onClose}
      dismissible={true}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title="저장" onPress={save} disabled={!language || !country || !gender} />
        </View>
      }
    >
      <AppText style={styles.p}>언어/나라/성별을 변경할 수 있습니다.</AppText>

      <View style={styles.pickerGroup}>
        <AppText style={styles.pickerTitle}>언어</AppText>
        <View style={styles.pickerRow}>
          <PickChip active={language === "ko"} label="한국어" onPress={() => setLanguage("ko")} />
          <PickChip active={language === "en"} label="English" onPress={() => setLanguage("en")} />
        </View>
      </View>

      <View style={styles.pickerGroup}>
        <AppText style={styles.pickerTitle}>나라</AppText>
        <View style={styles.countryWrap}>
          {COUNTRY_OPTIONS.map((c) => (
            <PickChip key={c.code} active={country === c.code} label={c.label} onPress={() => setCountry(c.code)} />
          ))}
        </View>
      </View>

      <View style={styles.pickerGroup}>
        <AppText style={styles.pickerTitle}>성별</AppText>
        <View style={styles.pickerRow}>
          <PickChip active={gender === "male"} label="남성" onPress={() => setGender("male")} />
          <PickChip active={gender === "female"} label="여성" onPress={() => setGender("female")} />
        </View>
      </View>
    </AppModal>
  );
}

function PickChip({ label, active, onPress }: { label: string; active: boolean; onPress: () => void }) {
  return (
    <AppText onPress={onPress} style={[styles.chip, active ? styles.chipOn : styles.chipOff, styles.chipTxt]}>
      {label}
    </AppText>
  );
}

const styles = StyleSheet.create({
  wrap: {
    padding: theme.spacing.lg,
    gap: theme.spacing.lg,
  },
  card: {
    backgroundColor: theme.colors.card,
    borderRadius: theme.radius.xl,
    borderWidth: 1,
    borderColor: theme.colors.line,
    padding: theme.spacing.lg,
    ...theme.shadow.card,
  },
  h1: { fontSize: 17, fontWeight: "700", color: theme.colors.text, marginBottom: 6 },
  p: { fontSize: 14, color: theme.colors.sub, lineHeight: 20 },

  row: { flexDirection: "row", justifyContent: "space-between", paddingVertical: 8 },
  k: { fontSize: 13, color: theme.colors.sub, fontWeight: "700" },
  v: { fontSize: 13, color: theme.colors.text, fontWeight: "700" },

  pickerGroup: { marginTop: 10 },
  pickerTitle: { fontSize: 13, fontWeight: "700", color: theme.colors.text, marginBottom: 8 },
  pickerRow: { flexDirection: "row", gap: 10, flexWrap: "wrap" },
  countryWrap: { flexDirection: "row", flexWrap: "wrap", gap: 10 },

  chip: {
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderRadius: 999,
    borderWidth: 1,
    overflow: "hidden",
  },
  chipOn: { backgroundColor: theme.colors.pinkDeep, borderColor: theme.colors.pinkDeep, color: theme.colors.white },
  chipOff: { backgroundColor: theme.colors.white, borderColor: theme.colors.line, color: theme.colors.text },
  chipTxt: { fontSize: 13, fontWeight: "700" },
});


================================================================================
 FILE: src\screens\_GlobalModalHost.tsx
================================================================================

﻿//C:\ranchat\src\screens\_GlobalModalHost.tsx
import React from "react";
import { Text, View } from "react-native";
import AppModal from "../components/AppModal";
import PrimaryButton from "../components/PrimaryButton";
import { useAppStore } from "../store/useAppStore";
import { theme } from "../config/theme";

export default function GlobalModalHost() {
  const m = useAppStore((s) => s.globalModal);
  const hide = useAppStore((s) => s.hideGlobalModal);

  return (
    <AppModal
      visible={m.visible}
      title={m.title}
      dismissible={true}
      onClose={hide}
      footer={
        <View style={{ gap: 10 }}>
          <PrimaryButton title="확인" onPress={hide} />
        </View>
      }
    >
      <Text style={{ fontSize: 14, color: theme.colors.sub, lineHeight: 20 }}>{m.message}</Text>
    </AppModal>
  );
}


================================================================================
 FILE: src\services\ads\AdManager.tsx
================================================================================

﻿//C:\ranchat\src\services\ads\AdManager.tsx
import React from "react";
import { Platform } from "react-native";
import mobileAds, { BannerAd, BannerAdSize, InterstitialAd, TestIds } from "react-native-google-mobile-ads";

let _adsInited = false;

export function initAds() {
  if (_adsInited) return;
  _adsInited = true;

  try {
    const p = mobileAds().initialize();
    if (p && typeof (p as any).catch === "function") (p as any).catch(() => {});
  } catch {}
}

function getBannerUnitId() {
  const android = String(process.env.EXPO_PUBLIC_AD_UNIT_BANNER_ANDROID ?? "").trim();
  const ios = String(process.env.EXPO_PUBLIC_AD_UNIT_BANNER_IOS ?? "").trim();
  const envId = Platform.OS === "ios" ? ios : android;
  return envId || TestIds.BANNER;
}

function getInterstitialUnitId() {
  const android = String(process.env.EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_ANDROID ?? "").trim();
  const ios = String(process.env.EXPO_PUBLIC_AD_UNIT_INTERSTITIAL_IOS ?? "").trim();
  const envId = Platform.OS === "ios" ? ios : android;
  return envId || TestIds.INTERSTITIAL;
}

export function createInterstitial() {
  const unitId = getInterstitialUnitId();
  return InterstitialAd.createForAdRequest(unitId, { requestNonPersonalizedAdsOnly: false });
}

export function BannerBar() {
  const unitId = getBannerUnitId();
  return (
    <BannerAd
      unitId={unitId}
      size={BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
      requestOptions={{ requestNonPersonalizedAdsOnly: false }}
    />
  );
}

export default { initAds, createInterstitial, BannerBar };


================================================================================
 FILE: src\services\auth\AuthBootstrap.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\auth\AuthBootstrap.ts
import { getOrCreateDeviceKey } from "../device/DeviceKey";
import { bindDeviceHttp } from "./DeviceBind";
import { useAppStore } from "../../store/useAppStore";

export async function bootstrapDeviceBinding(): Promise<void> {
  const deviceKey = await getOrCreateDeviceKey();
  useAppStore.getState().setDeviceKey(deviceKey);

  const { token, userId } = await bindDeviceHttp(deviceKey);
  useAppStore.getState().setAuth({ token, userId, verified: true });
}


================================================================================
 FILE: src\services\auth\DeviceBind.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\auth\DeviceBind.ts
import { Platform } from "react-native";
import { APP_CONFIG } from "../../config/app";

type BindResponse = {
  token: string;
  userId: string;
};

async function postBind(url: string, deviceKey: string): Promise<BindResponse> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      deviceKey,
      platform: Platform.OS,
    }),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    const err: any = new Error(`BIND_HTTP_${res.status}:${txt}`);
    err.status = res.status;
    err.body = txt;
    throw err;
  }

  const data: any = await res.json();
  const token = String(data?.token ?? "");
  const userId = String(data?.userId ?? "");
  if (!token || !userId) throw new Error("BIND_RESPONSE_INVALID");
  return { token, userId };
}

function httpsBaseFromWs(wsUrl: string): string {
  try {
    const u = new URL(wsUrl);
    return `https://${u.host}`;
  } catch {
    return "";
  }
}

function normalizeHttpsBase(v: string): string {
  const s = String(v || "").trim();
  if (!s) return "";
  if (/^https:\/\//i.test(s)) return s;
  if (/^http:\/\//i.test(s)) return s.replace(/^http:\/\//i, "https://");
  if (/^wss:\/\//i.test(s)) return s.replace(/^wss:\/\//i, "https://");
  if (/^ws:\/\//i.test(s)) return s.replace(/^ws:\/\//i, "https://");
  return `https://${s.replace(/^\/+/, "")}`;
}

export async function bindDeviceHttp(deviceKey: string): Promise<BindResponse> {
  const envBase = String(process.env.EXPO_PUBLIC_AUTH_HTTP_BASE_URL ?? "").trim();
  const cfgBase = String(APP_CONFIG.AUTH_HTTP_BASE_URL ?? "").trim();
  const derivedBase = httpsBaseFromWs(String(APP_CONFIG.SIGNALING_URL ?? "").trim());

  const candidates = [envBase || cfgBase, derivedBase]
    .map((v) => normalizeHttpsBase(v))
    .filter((v) => v.length > 0)
    .map((v) => v.replace(/\/$/, ""));

  const bases = Array.from(new Set(candidates));
  if (!bases.length) throw new Error("AUTH_BASE_URL_MISSING");

  let last404 = "";
  let lastErr: any = null;

  for (const base0 of bases) {
    const base = base0.replace(/\/$/, "");
    const baseHasApi = /\/api$/i.test(base);

    const paths = baseHasApi
      ? ["/device/bind", "/bind"]
      : ["/device/bind", "/bind", "/api/device/bind", "/api/bind"];

    for (const p of paths) {
      const url = `${base}${p}`;

      try {
        return await postBind(url, deviceKey);
      } catch (e: any) {
        lastErr = e;

        const status = Number(e?.status);
        if (Number.isFinite(status)) {
          if (status === 404) {
            last404 = String(e?.body ?? "");
            continue;
          }
          throw e;
        }

        continue;
      }
    }
  }

  if (last404) throw new Error(`BIND_HTTP_404:${last404}`);
  throw lastErr ?? new Error("BIND_FAILED");
}


================================================================================
 FILE: src\services\device\DeviceKey.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\device\DeviceKey.ts
import "react-native-get-random-values";
import * as SecureStore from "expo-secure-store";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { v4 as uuidv4 } from "uuid";

const KEY = "ranchat_device_key_v1";

async function getFromFallback(): Promise<string | null> {
  try {
    const v = await AsyncStorage.getItem(KEY);
    return v ? String(v) : null;
  } catch {
    return null;
  }
}

async function setToFallback(v: string): Promise<void> {
  try {
    await AsyncStorage.setItem(KEY, String(v));
  } catch {}
}

export async function getOrCreateDeviceKey(): Promise<string> {
  // 1) SecureStore 우선
  try {
    const existing = await SecureStore.getItemAsync(KEY);
    if (existing && String(existing).trim().length > 0) return String(existing).trim();
  } catch {
    // 무시하고 fallback
  }

  // 2) AsyncStorage fallback
  const fb = await getFromFallback();
  if (fb && fb.trim().length > 0) return fb.trim();

  // 3) 생성 후 저장
  const next = uuidv4();

  try {
    await SecureStore.setItemAsync(KEY, next);
  } catch {
    // SecureStore 실패 시 fallback
    await setToFallback(next);
  }

  return next;
}


================================================================================
 FILE: src\services\purchases\PurchaseManager.ts
================================================================================

﻿import Purchases from "react-native-purchases";
import { APP_CONFIG } from "../../config/app";
import { useAppStore } from "../../store/useAppStore";

let inited = false;

export async function initPurchases() {
  const key = APP_CONFIG.PURCHASES.revenueCatKey;
  if (!key) return;

  if (inited) return;
  inited = true;

  try {
    Purchases.setLogLevel(Purchases.LOG_LEVEL.ERROR);
    await Purchases.configure({ apiKey: key });
    await refreshSubscription();
  } catch {
    // UI는 글로벌 모달에서 처리
  }
}

export async function refreshSubscription() {
  const entitlementId = APP_CONFIG.PURCHASES.entitlementId;
  try {
    const customerInfo = await Purchases.getCustomerInfo();
    const active = Boolean(customerInfo?.entitlements?.active?.[entitlementId]);
    useAppStore.getState().setSub({
      isPremium: active,
      entitlementId: entitlementId,
      lastCheckedAt: Date.now(),
    });
  } catch {
    // 무응답
  }
}

export async function purchasePremium() {
  const entitlementId = APP_CONFIG.PURCHASES.entitlementId;
  try {
    const offerings = await Purchases.getOfferings();
    const current = offerings.current;
    if (!current || current.availablePackages.length === 0) {
      useAppStore.getState().showGlobalModal("구독", "현재 구매 가능한 상품을 불러오지 못했습니다.");
      return;
    }

    // 실서비스에서는 RevenueCat Offering에서 정렬/패키지명을 맞추는 것을 전제로 합니다.
    // 여기서는 가장 일반적인 패키지 우선순위: weekly -> monthly -> 6months (없으면 availablePackages 순서)
    const pick =
      current.availablePackages.find(p => p.packageType === Purchases.PACKAGE_TYPE.WEEKLY) ||
      current.availablePackages.find(p => p.packageType === Purchases.PACKAGE_TYPE.MONTHLY) ||
      current.availablePackages.find(p => p.packageType === Purchases.PACKAGE_TYPE.SIX_MONTH) ||
      current.availablePackages[0];

    await Purchases.purchasePackage(pick);

    const customerInfo = await Purchases.getCustomerInfo();
    const active = Boolean(customerInfo?.entitlements?.active?.[entitlementId]);
    useAppStore.getState().setSub({
      isPremium: active,
      entitlementId: entitlementId,
      lastCheckedAt: Date.now(),
    });
  } catch (e: any) {
    if (e?.userCancelled) return;
    useAppStore.getState().showGlobalModal("구독", "결제를 완료하지 못했습니다. 잠시 후 다시 시도해 주세요.");
  }
}

export async function openManageSubscriptions() {
  try {
    // 일부 환경에서 미지원일 수 있어 예외 처리
    // @ts-ignore
    await Purchases.showManageSubscriptions();
  } catch {
    useAppStore.getState().showGlobalModal("구독관리", "기기에서 구독관리 화면을 열 수 없습니다.");
  }
}

================================================================================
 FILE: src\services\signal\SignalClient.ts
================================================================================

﻿// FILE: C:\ranchat\src\services\signal\SignalClient.ts
import { Platform } from "react-native";
import { getOrCreateDeviceKey } from "../device/DeviceKey";

export type SignalMessage =
  | { type: "queued" }
  | { type: "match"; roomId: string; isCaller: boolean }
  | { type: "offer"; sdp: any }
  | { type: "answer"; sdp: any }
  | { type: "ice"; candidate: any }
  | { type: "end" }
  | { type: "peer_cam"; enabled: boolean }
  | { type: "signal"; roomId: string; data: any }
  | { type: "error"; message?: string };

type Cb = {
  onOpen: () => void; // ✅ "registered" 이후에 호출되도록 유지(등록 전 enqueue -> not_registered 루프 방지)
  onClose: () => void;
  onMessage: (m: SignalMessage) => void;
};

type ServerMessage =
  | { type: "hello" }
  | { type: "registered"; sessionId: string }
  | { type: "enqueued"; sessionId: string; queueSize?: number }
  | { type: "dequeued"; sessionId: string; queueSize?: number }
  | { type: "matched"; roomId: string; initiator: boolean; sessionId?: string; peerSessionId?: string }
  | { type: "signal"; roomId: string; fromSessionId?: string; data: any }
  | { type: "peer_left"; roomId?: string; sessionId?: string; peerSessionId?: string }
  | { type: "left"; roomId?: string; sessionId?: string }
  | { type: "left_ok"; roomId?: string | null; sessionId?: string } // ✅ 서버가 떠난 사람에게 주는 ack(무시)
  | { type: "error"; reason?: string; message?: string };

export class SignalClient {
  private ws: WebSocket | null = null;
  private cb: Cb;

  private token: string = "";
  private sessionId: string = "";

  private registered = false;
  private openNotified = false;
  private closeNotified = false;
  private pending: any[] = [];

  constructor(cb: Cb) {
    this.cb = cb;
  }

  async connect(baseUrl: string, token: string | null) {
    // ✅ 기존 연결이 남아있으면 정리(중복 onClose/onError로 상태 꼬임 방지)
    try {
      this.ws?.close();
    } catch {}
    this.ws = null;

    const deviceKey = await getOrCreateDeviceKey();
    this.sessionId = String(deviceKey || "").trim();
    this.token = String(token || "").trim();

    this.registered = false;
    this.openNotified = false;
    this.closeNotified = false;
    this.pending = [];

    this.ws = new WebSocket(baseUrl);

    this.ws.onopen = () => {
      // 서버 요구: register(token+sessionId) 먼저
      if (!this.token || !this.sessionId) {
        this.cb.onMessage({ type: "error", message: "REGISTER_REQUIRES_TOKEN_AND_SESSIONID" });
        try {
          this.ws?.close();
        } catch {}
        return;
      }

      // ✅ 여기서 onOpen 호출하지 않음(등록 확인 전 enqueue -> not_registered 루프 원인)
      this.sendRaw({ type: "register", token: this.token, sessionId: this.sessionId });
    };

    const closeOnce = () => {
      if (this.closeNotified) return;
      this.closeNotified = true;

      // 연결 끊기면 등록 상태도 초기화
      this.registered = false;
      this.openNotified = false;
      this.pending = [];

      this.cb.onClose();
    };

    this.ws.onclose = () => {
      closeOnce();
    };

    this.ws.onerror = () => {
      closeOnce();
    };

    this.ws.onmessage = (ev: any) => {
      try {
        const msg = JSON.parse(String(ev?.data ?? "{}")) as ServerMessage;

        if (msg?.type === "registered") {
          this.registered = true;

          if (!this.openNotified) {
            this.openNotified = true;
            this.cb.onOpen();
          }

          // pending flush
          const q = this.pending.slice();
          this.pending = [];
          q.forEach((x) => this.sendRaw(x));
          return;
        }

        if (msg?.type === "enqueued") {
          this.cb.onMessage({ type: "queued" });
          return;
        }

        if (msg?.type === "matched") {
          this.cb.onMessage({ type: "match", roomId: msg.roomId, isCaller: !!msg.initiator });
          return;
        }

        // ✅ 떠난 사람에게 오는 ack는 무시(상대 종료로 오해하지 않기)
        if (msg?.type === "left_ok") {
          return;
        }

        if (msg?.type === "peer_left" || msg?.type === "left") {
          this.cb.onMessage({ type: "end" });
          return;
        }

        if (msg?.type === "signal") {
          const d: any = msg.data;
          const t = String(d?.type ?? d?.kind ?? "").toLowerCase();

          if (t === "offer") {
            this.cb.onMessage({ type: "offer", sdp: d });
            return;
          }
          if (t === "answer") {
            this.cb.onMessage({ type: "answer", sdp: d });
            return;
          }
          if (t === "ice") {
            const cand = d?.candidate ?? d;
            this.cb.onMessage({ type: "ice", candidate: cand });
            return;
          }
          if (t === "end" || t === "leave") {
            this.cb.onMessage({ type: "end" });
            return;
          }

          // ✅ 상대 카메라 ON/OFF 상태(선택적으로 사용 가능)
          if (t === "cam_state") {
            const enabled = Boolean(d?.enabled ?? d?.on ?? d?.camOn ?? d?.videoEnabled ?? d?.videoOn);
            this.cb.onMessage({ type: "peer_cam", enabled });
            return;
          }

          this.cb.onMessage({ type: "signal", roomId: msg.roomId, data: d });
          return;
        }

        if (msg?.type === "error") {
          const m = String(msg.message || msg.reason || "UNKNOWN_ERROR");
          this.cb.onMessage({ type: "error", message: m });
          return;
        }
      } catch {
        this.cb.onMessage({ type: "error", message: "INVALID_MESSAGE" });
      }
    };
  }

  enqueue(country: string, gender: string) {
    // 서버가 country/gender를 무시해도 문제 없음(추가 필드 허용)
    this.send({ type: "enqueue", country, gender, platform: Platform.OS });
  }

  // CallScreen.tsx 호환
  sendOffer(roomId: string, sdp: any) {
    this.relay(roomId, sdp);
  }

  sendAnswer(roomId: string, sdp: any) {
    this.relay(roomId, sdp);
  }

  sendIce(roomId: string, candidate: any) {
    this.relay(roomId, { type: "ice", candidate });
  }

  // ✅ 내 카메라 ON/OFF 상태를 상대에게 알림(서버 최상위 타입 추가 없이 signal로 전송)
  sendCamState(roomId: string, enabled: boolean) {
    this.relay(roomId, { type: "cam_state", enabled: !!enabled });
  }

  relay(roomId: string, data: any) {
    this.send({ type: "signal", roomId, data });
  }

  leaveQueue() {
    this.send({ type: "dequeue" });
  }

  // CallScreen.tsx에서 인자로 호출하므로 optional 처리
  leaveRoom(roomId?: string) {
    // 서버는 roomId 없이도 처리하지만, 있어도 무방
    this.send({ type: "leave", roomId: roomId || undefined });
  }

  close() {
    try {
      this.ws?.close();
    } catch {}
    this.ws = null;

    this.registered = false;
    this.openNotified = false;
    this.closeNotified = false;
    this.pending = [];
  }

  private send(obj: any) {
    // ✅ registered 전이면 큐잉(등록 확인 전 enqueue로 not_registered 나는 것 방지)
    if (!this.registered && obj?.type !== "register") {
      if (this.pending.length < 50) this.pending.push(obj);
      return;
    }
    this.sendRaw(obj);
  }

  private sendRaw(obj: any) {
    try {
      this.ws?.send(JSON.stringify(obj));
    } catch {}
  }
}


================================================================================
 FILE: src\services\webrtc\WebRTCSession.ts
================================================================================

﻿//WebRTCSession.ts
import { RTCPeerConnection, RTCIceCandidate, RTCSessionDescription, mediaDevices, MediaStream } from "react-native-webrtc";
import { PermissionsAndroid, Platform } from "react-native";
import { APP_CONFIG } from "../../config/app";
// @ts-ignore
import InCallManager from "react-native-incall-manager";

type Callbacks = {
  onLocalStream?: (s: MediaStream) => void;
  onRemoteStream?: (s: MediaStream) => void;
  onIceCandidate?: (c: any) => void;
  onConnectionState?: (s: string) => void;

  // ✅ CallScreen.tsx가 넘기는 콜백(없어서 TS 에러였음)
  onOffer?: (sdp: any) => void;
  onAnswer?: (sdp: any) => void;
};

const VIDEO_W = 720;
const VIDEO_H = 1280;
const VIDEO_FPS = 24;

// 모바일 체감 기준(끊김/딜레이 줄이기용 상한)
// 720p 24fps에 과하지 않은 범위로 제한
const VIDEO_MAX_BITRATE = 1_200_000; // 1.2Mbps
const AUDIO_MAX_BITRATE = 64_000; // 64kbps (옵션)

function preferH264InSdp(sdp: string) {
  try {
    const lines = String(sdp || "").split("\r\n");
    const mVideo = lines.findIndex((l) => l.startsWith("m=video "));
    if (mVideo < 0) return sdp;

    const h264Pts = new Set<string>();
    for (const l of lines) {
      const m = l.match(/^a=rtpmap:(\d+)\s+H264\/90000/i);
      if (m?.[1]) h264Pts.add(m[1]);
    }
    if (h264Pts.size === 0) return sdp;

    const parts = lines[mVideo].split(" ");
    if (parts.length <= 3) return sdp;

    const head = parts.slice(0, 3);
    const pts = parts.slice(3);

    const preferred = pts.filter((p) => h264Pts.has(p));
    const others = pts.filter((p) => !h264Pts.has(p));

    lines[mVideo] = [...head, ...preferred, ...others].join(" ");
    return lines.join("\r\n");
  } catch {
    return sdp;
  }
}

export class WebRTCSession {
  private pc: RTCPeerConnection;
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;
  private cb: Callbacks;
  private inCallStarted: boolean = false;

  constructor(cb: Callbacks) {
    this.cb = cb;

    const turn = APP_CONFIG.TURN;
    const iceServers = [
      { urls: [`stun:${turn.host}:${turn.port}`] },
      {
        urls: [`turn:${turn.host}:${turn.port}?transport=udp`, `turn:${turn.host}:${turn.port}?transport=tcp`],
        username: turn.username,
        credential: turn.password,
      },
    ];

    this.pc = new RTCPeerConnection(
      {
        iceServers,
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        // 연결 시 초반 후보 수집/연결 체감 조금 개선되는 경우가 있어 소량만
        iceCandidatePoolSize: 2,
      } as any
    );

    const pcAny: any = this.pc;

    pcAny.onicecandidate = (e: any) => {
      if (e?.candidate) this.cb.onIceCandidate?.(e.candidate);
    };

    pcAny.onconnectionstatechange = () => {
      this.cb.onConnectionState?.(pcAny.connectionState);
    };

    pcAny.ontrack = (e: any) => {
      const stream = (e?.streams && e.streams[0]) || null;
      if (stream) {
        this.remoteStream = stream;
        this.cb.onRemoteStream?.(stream);
      }
    };
  }

  private startSpeakerphone() {
    try {
      if (this.inCallStarted) return;
      this.inCallStarted = true;

      const IC: any = InCallManager as any;

      IC.start?.({ media: "video" });
      IC.setKeepScreenOn?.(true);

      // 스피커폰 강제
      IC.setForceSpeakerphoneOn?.(true);
      IC.setSpeakerphoneOn?.(true);
    } catch {}
  }

  private stopSpeakerphone() {
    try {
      if (!this.inCallStarted) return;
      this.inCallStarted = false;

      const IC: any = InCallManager as any;

      IC.setKeepScreenOn?.(false);
      IC.stop?.();
    } catch {}
  }

  async ensurePermissions() {
    if (Platform.OS !== "android") return;
    const cam = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.CAMERA);
    const mic = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.RECORD_AUDIO);
    if (cam !== "granted" || mic !== "granted") throw new Error("PERMISSION_DENIED");
  }

  private async tuneSenders() {
    try {
      const senders: any[] = (this.pc as any).getSenders?.() ?? [];
      for (const sender of senders) {
        const kind = sender?.track?.kind;

        if (kind === "video" && typeof sender.getParameters === "function" && typeof sender.setParameters === "function") {
          const params = sender.getParameters() || {};
          if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];

          params.encodings[0].maxBitrate = VIDEO_MAX_BITRATE;
          params.encodings[0].maxFramerate = VIDEO_FPS;
          params.degradationPreference = "balanced";

          try {
            await sender.setParameters(params);
          } catch {}
        }

        if (kind === "audio" && typeof sender.getParameters === "function" && typeof sender.setParameters === "function") {
          const params = sender.getParameters() || {};
          if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];

          params.encodings[0].maxBitrate = AUDIO_MAX_BITRATE;

          try {
            await sender.setParameters(params);
          } catch {}
        }
      }
    } catch {}
  }

  async startLocal() {
    await this.ensurePermissions();

    // ✅ 스피커폰 ON
    this.startSpeakerphone();

    // 720p/24fps(과하지 않게) + 실패 시 한 단계 다운 폴백
    let stream: any = null;

    try {
      stream = await mediaDevices.getUserMedia({
        audio: true,
        video: {
          facingMode: "user",
          frameRate: { ideal: VIDEO_FPS, max: VIDEO_FPS },
          width: { ideal: VIDEO_W, max: VIDEO_W },
          height: { ideal: VIDEO_H, max: VIDEO_H },
        },
      } as any);
    } catch {
      stream = await mediaDevices.getUserMedia({
        audio: true,
        video: {
          facingMode: "user",
          frameRate: { ideal: 20, max: 20 },
          width: { ideal: 640, max: 640 },
          height: { ideal: 960, max: 960 },
        },
      } as any);
    }

    this.localStream = stream as any;
    (stream as any).getTracks().forEach((t: any) => (this.pc as any).addTrack(t, stream));

    await this.tuneSenders();

    this.cb.onLocalStream?.(stream as any);
  }

  async createOffer() {
    const offer = await (this.pc as any).createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });

    if (offer?.sdp) {
      offer.sdp = preferH264InSdp(offer.sdp);
    }

    await (this.pc as any).setLocalDescription(offer);
    return offer;
  }

  async acceptOfferAndCreateAnswer(offer: any) {
    await (this.pc as any).setRemoteDescription(new RTCSessionDescription(offer));
    const ans = await (this.pc as any).createAnswer();

    if (ans?.sdp) {
      ans.sdp = preferH264InSdp(ans.sdp);
    }

    await (this.pc as any).setLocalDescription(ans);
    return ans;
  }

  async acceptAnswer(answer: any) {
    await (this.pc as any).setRemoteDescription(new RTCSessionDescription(answer));
  }

  async addCandidate(candidate: any) {
    try {
      await (this.pc as any).addIceCandidate(new RTCIceCandidate(candidate));
    } catch {}
  }

  // ✅ CallScreen.tsx 호환 메서드들(없어서 TS 에러였음)
  async start({ isCaller }: { isCaller: boolean }) {
    await this.startLocal();

    if (isCaller) {
      const offer = await this.createOffer();
      this.cb.onOffer?.(offer);
    }
  }

  async handleRemoteOffer(offer: any) {
    const ans = await this.acceptOfferAndCreateAnswer(offer);
    this.cb.onAnswer?.(ans);
    return ans;
  }

  async handleRemoteAnswer(answer: any) {
    await this.acceptAnswer(answer);
  }

  async handleRemoteIce(candidate: any) {
    await this.addCandidate(candidate);
  }

  setLocalVideoEnabled(on: boolean) {
    const v = (this.localStream as any)?.getVideoTracks?.() ?? [];
    v.forEach((t: any) => (t.enabled = on));
  }

  setLocalAudioEnabled(on: boolean) {
    const a = (this.localStream as any)?.getAudioTracks?.() ?? [];
    a.forEach((t: any) => (t.enabled = on));
  }

  stop() {
    this.stopSpeakerphone();

    try {
      (this.localStream as any)?.getTracks?.()?.forEach((t: any) => t.stop?.());
    } catch {}
    try {
      (this.pc as any).close?.();
    } catch {}
    this.localStream = null;
    this.remoteStream = null;
  }
}


================================================================================
 FILE: src\store\useAppStore.ts
================================================================================

﻿//C:\ranchat\src\store\useAppStore.ts
import AsyncStorage from "@react-native-async-storage/async-storage";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import type { Gender, Language } from "../config/app";

type Prefs = {
  language: Language | null;
  country: string | null;
  gender: Gender | null;
};

type Sub = {
  isPremium: boolean;
  entitlementId: string | null;
  lastCheckedAt: number | null;
};

type Auth = {
  verified: boolean;
  token: string | null;
  userId: string | null;
  deviceKey: string | null;
};

type GlobalModal = {
  visible: boolean;
  title: string;
  message: string;
};

type Ui = {
  fontScale: number; // 0.85~1.25 권장
};

type Store = {
  hasHydrated: boolean;
  authNonce: number;

  prefs: Prefs;
  sub: Sub;
  auth: Auth;

  ui: Ui;

  globalModal: GlobalModal;

  setHasHydrated: (v: boolean) => void;
  bumpAuthNonce: () => void;

  setPrefs: (p: Partial<Prefs>) => void;

  setPremium: (v: boolean) => void;
  setSub: (p: Partial<Sub>) => void;

  setDeviceKey: (k: string) => void;
  setAuth: (a: Partial<Auth>) => void;

  setFontScale: (v: number) => void;

  logoutAndWipe: () => void;

  showGlobalModal: (title: string, message: string) => void;
  hideGlobalModal: () => void;
};

export const useAppStore = create<Store>()(
  persist(
    (set, get) => ({
      hasHydrated: false,
      authNonce: 0,

      prefs: { language: null, country: null, gender: null },
      sub: { isPremium: false, entitlementId: null, lastCheckedAt: null },
      auth: { verified: false, token: null, userId: null, deviceKey: null },

      ui: { fontScale: 1 },

      globalModal: { visible: false, title: "", message: "" },

      setHasHydrated: (v) => set({ hasHydrated: v }),
      bumpAuthNonce: () => set({ authNonce: get().authNonce + 1 }),

      setPrefs: (p) => set({ prefs: { ...get().prefs, ...p } }),

      setPremium: (v) => set({ sub: { ...get().sub, isPremium: v } }),
      setSub: (p) => set({ sub: { ...get().sub, ...p } }),

      setDeviceKey: (k) => set({ auth: { ...get().auth, deviceKey: k } }),
      setAuth: (a) => set({ auth: { ...get().auth, ...a } }),

      setFontScale: (v) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        const clamped = Math.min(1.25, Math.max(0.85, n));
        set({ ui: { ...get().ui, fontScale: Number(clamped.toFixed(2)) } });
      },

      logoutAndWipe: () => {
        set({
          auth: {
            ...get().auth,
            verified: false,
            token: null,
            userId: null,
          },
        });
        get().bumpAuthNonce();
      },

      showGlobalModal: (title, message) => set({ globalModal: { visible: true, title, message } }),
      hideGlobalModal: () => set({ globalModal: { visible: false, title: "", message: "" } }),
    }),
    {
      name: "ranchat_store_v1",
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (s) => ({ prefs: s.prefs, sub: s.sub, auth: s.auth, ui: s.ui }),
      onRehydrateStorage: () => (state) => {
        state?.setHasHydrated(true);
      },
    }
  )
);


================================================================================
 FILE: src\utils\storage.ts
================================================================================

﻿import AsyncStorage from "@react-native-async-storage/async-storage";

export const storage = {
  get: async <T>(key: string): Promise<T | null> => {
    const v = await AsyncStorage.getItem(key);
    if (!v) return null;
    return JSON.parse(v) as T;
  },
  set: async (key: string, value: any) => {
    await AsyncStorage.setItem(key, JSON.stringify(value));
  },
  del: async (key: string) => {
    await AsyncStorage.removeItem(key);
  },
  clear: async () => {
    await AsyncStorage.clear();
  },
};
